{
  "api/Elements.Analysis.AnalysisMesh.html": {
    "href": "api/Elements.Analysis.AnalysisMesh.html",
    "title": "Class AnalysisMesh | Hypar Docs",
    "keywords": "Class AnalysisMesh A visualization of computed values at locations in space. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Analysis_AnalysisMesh.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var perimeter1 = Polygon.L(10, 10, 3); var perimeter2 = Polygon.Ngon(5, 5); var move = new Transform(3, 7, 0); var perimeter = perimeter1.Union((Polygon)perimeter2.Transformed(move)); var mc = new ModelCurve(perimeter); this.Model.AddElement(mc); // Construct a mass from which we will measure // distance to the analysis mesh's cells. var center = perimeter.Centroid(); var mass = new Mass(Polygon.Rectangle(1, 1)); mass.Transform.Move(center); this.Model.AddElement(mass); // The analyze function computes the distance // to the attractor. var analyze = new Func<Vector3, double>((v) => { return center.DistanceTo(v); }); // Construct a color scale from a small number // of colors. var colorScale = new ColorScale(new List<Color>() { Colors.Cyan, Colors.Purple, Colors.Orange }, 10); var analysisMesh = new AnalysisMesh(perimeter, 0.2, 0.2, colorScale, analyze); analysisMesh.Analyze(); Inheritance System.Object Element GeometricElement AnalysisMesh Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.UpdateRepresentations() GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Analysis Assembly : Hypar.Elements.dll Syntax public class AnalysisMesh : GeometricElement, INotifyPropertyChanged, ITessellate Constructors AnalysisMesh(Polygon, Double, Double, ColorScale, Func<Vector3, Double>, Guid, String) Construct an analysis mesh. Declaration public AnalysisMesh(Polygon perimeter, double uLength, double vLength, ColorScale colorScale, Func<Vector3, double> analyze, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The perimeter of the mesh. System.Double uLength The number of divisions in the u direction. System.Double vLength The number of divisions in the v direction. ColorScale colorScale The color scale to be used in the visualization. System.Func < Vector3 , System.Double > analyze A function which takes a location and computes a value. System.Guid id The id of the analysis mesh. System.String name The name of the analysis mesh. Properties ColorScale The color scale used to represent this analysis mesh. Declaration public ColorScale ColorScale { get; set; } Property Value Type Description ColorScale Perimeter The perimeter of the analysis mesh. Declaration public Polygon Perimeter { get; set; } Property Value Type Description Polygon TotalAnalysisLocations The total number of analysis locations. Declaration public double TotalAnalysisLocations { get; } Property Value Type Description System.Double ULength The length of the cells in the u direction. Declaration public double ULength { get; set; } Property Value Type Description System.Double VLength The length of the cells in the v direction. Declaration public double VLength { get; set; } Property Value Type Description System.Double Methods Analyze() Compute a value for each grid cell. Declaration public void Analyze() Tessellate(ref Mesh, Transform, Color) Tessellate the analysis mesh. Declaration public void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh Transform transform Color color Implements System.ComponentModel.INotifyPropertyChanged ITessellate"
  },
  "api/Elements.Analysis.ColorScale.html": {
    "href": "api/Elements.Analysis.ColorScale.html",
    "title": "Class ColorScale | Hypar Docs",
    "keywords": "Class ColorScale A range of colors interpolated between a number of key values. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Analysis_ColorScale.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Construct a color scale specifying only // a few colors. The rest will be interpolated. var colorScale = new ColorScale(new List<Color>(){Colors.Cyan, Colors.Purple, Colors.Orange}, 10); var i=0; foreach(var c in colorScale.Colors) { var panel = new Panel(Polygon.Rectangle(1,1), new Material($\"Material{i}\", c)); panel.Transform.Move(new Vector3(i * 1.1, 0, 0)); this.Model.AddElement(panel); i++; } Inheritance System.Object ColorScale Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Analysis Assembly : Hypar.Elements.dll Syntax public class ColorScale Constructors ColorScale(List<Color>) Construct a color scale. Declaration public ColorScale(List<Color> colors) Parameters Type Name Description System.Collections.Generic.List < Color > colors The colors which define the color scale. ColorScale(List<Color>, Int32) Construct a color scale. Declaration public ColorScale(List<Color> colors, int colorCount) Parameters Type Name Description System.Collections.Generic.List < Color > colors The color scale's key values. System.Int32 colorCount The number of colors in the final color scale These values will be interpolated between the provided colors. Properties Colors The colors of the scale. Declaration public List<Color> Colors { get; } Property Value Type Description System.Collections.Generic.List < Color > Methods GetColorForValue(Double) Get the color from the color scale most closely approximating the provided value. Declaration public Color GetColorForValue(double t) Parameters Type Name Description System.Double t A number between 0.0 and 1.0 Returns Type Description Color A color."
  },
  "api/Elements.Analysis.html": {
    "href": "api/Elements.Analysis.html",
    "title": "Namespace Elements.Analysis | Hypar Docs",
    "keywords": "Namespace Elements.Analysis Classes AnalysisMesh A visualization of computed values at locations in space. ColorScale A range of colors interpolated between a number of key values."
  },
  "api/Elements.Beam.html": {
    "href": "api/Elements.Beam.html",
    "title": "Class Beam | Hypar Docs",
    "keywords": "Class Beam A structural framing element defined by a center line curve and a profile. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Beam.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a framing type. var profile = WideFlangeProfileServer.Instance.GetProfileByType(WideFlangeProfileType.W10x100); // Create a straight beam. var line = new Line(Vector3.Origin, new Vector3(5, 0, 5)); var linearBeam = new Beam(line, profile, BuiltInMaterials.Wood, 0, 0, 15); var lineT = line.TransformAt(0).ToModelCurves(linearBeam.Transform); // Create a polygon beam. var polygon = Polygon.Ngon(5, 2); var polygonBeam = new Beam(polygon, profile, BuiltInMaterials.Steel, 0, 0, 45.0, new Transform(6, 0, 0)); var polyT = polygon.TransformAt(0).ToModelCurves(polygonBeam.Transform); // Create a curved beam. var arc = new Arc(Vector3.Origin, 5.0, 45.0, 135.0); var arcBeam = new Beam(arc, profile, BuiltInMaterials.Steel, 0, 0, 45.0, new Transform(12, 0, 0)); var arcT = arc.TransformAt(0).ToModelCurves(arcBeam.Transform); Inheritance System.Object Element GeometricElement StructuralFraming Beam Implements System.ComponentModel.INotifyPropertyChanged Inherited Members StructuralFraming.Curve StructuralFraming.StartSetback StructuralFraming.EndSetback StructuralFraming.Profile StructuralFraming.Rotation StructuralFraming.Volume() StructuralFraming.ProfileTransformed() StructuralFraming.UpdateRepresentations() GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Beam : StructuralFraming, INotifyPropertyChanged Constructors Beam(Curve, Profile, Material, Double, Double, Double, Transform, Boolean, Guid, String) Construct a beam. Declaration public Beam(Curve curve, Profile profile, Material material = null, double startSetback = 0, double endSetback = 0, double rotation = 0, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Curve curve The beam's center line. Profile profile The beam's profile. Material material The beam's material. System.Double startSetback The setback of the beam's geometry at the start. System.Double endSetback The setback of the beam's geometry at the end. System.Double rotation An optional rotation of the beam's cross section around it's axis. Transform transform The beam's transform. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the transform. System.String name The name of the transform. Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Brace.html": {
    "href": "api/Elements.Brace.html",
    "title": "Class Brace | Hypar Docs",
    "keywords": "Class Brace A Brace is a structural framing element which is often diagonal. Inheritance System.Object Element GeometricElement StructuralFraming Brace Implements System.ComponentModel.INotifyPropertyChanged Inherited Members StructuralFraming.Curve StructuralFraming.StartSetback StructuralFraming.EndSetback StructuralFraming.Profile StructuralFraming.Rotation StructuralFraming.Volume() StructuralFraming.ProfileTransformed() StructuralFraming.UpdateRepresentations() GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Brace : StructuralFraming, INotifyPropertyChanged Constructors Brace(Curve, Profile, Material, Double, Double, Double, Transform, Boolean, Guid, String) Construct a Brace. Declaration public Brace(Curve curve, Profile profile, Material material, double startSetback = 0, double endSetback = 0, double rotation = 0, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Curve curve The brace's center line. Profile profile The brace's profile. Material material The brace's material. System.Double startSetback The setback of the brace's geometry at the start. System.Double endSetback The setback of the brace's geometry at the end. System.Double rotation An optional rotation of the beam's profile around its axis. Transform transform The brace's transform. System.Boolean isElementDefinition Is this an element definition? System.Guid id The brace's id. System.String name The brace's name. Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.BuiltInMaterials.html": {
    "href": "api/Elements.BuiltInMaterials.html",
    "title": "Class BuiltInMaterials | Hypar Docs",
    "keywords": "Class BuiltInMaterials Built in materials. Inheritance System.Object BuiltInMaterials Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class BuiltInMaterials Fields Concrete Concrete. Declaration public static Material Concrete Field Value Type Description Material Properties Black Black Declaration public static Material Black { get; } Property Value Type Description Material Default The default material. Declaration public static Material Default { get; } Property Value Type Description Material Edges Edges Declaration public static Material Edges { get; } Property Value Type Description Material EdgesHighlighted Edges Highlighted Declaration public static Material EdgesHighlighted { get; } Property Value Type Description Material Glass Glass. Declaration public static Material Glass { get; } Property Value Type Description Material Mass Default material used to represent masses. Declaration public static Material Mass { get; } Property Value Type Description Material Points Points Declaration public static Material Points { get; } Property Value Type Description Material Steel Steel. Declaration public static Material Steel { get; } Property Value Type Description Material Topography Topography Declaration public static Material Topography { get; } Property Value Type Description Material Trans Fully transparent material. Declaration public static Material Trans { get; } Property Value Type Description Material Void Void Declaration public static Material Void { get; } Property Value Type Description Material Wood Wood. Declaration public static Material Wood { get; } Property Value Type Description Material XAxis X Axis Declaration public static Material XAxis { get; } Property Value Type Description Material YAxis Y Axis Declaration public static Material YAxis { get; } Property Value Type Description Material ZAxis Z Axis Declaration public static Material ZAxis { get; } Property Value Type Description Material"
  },
  "api/Elements.Column.html": {
    "href": "api/Elements.Column.html",
    "title": "Class Column | Hypar Docs",
    "keywords": "Class Column A vertical structural framing element. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Column.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a framing type. var profile = WideFlangeProfileServer.Instance.GetProfileByType(WideFlangeProfileType.W10x100); // Create a column. var column = new Column(Vector3.Origin, 3.0, profile, BuiltInMaterials.Steel); Inheritance System.Object Element GeometricElement StructuralFraming Column Implements System.ComponentModel.INotifyPropertyChanged Inherited Members StructuralFraming.Curve StructuralFraming.StartSetback StructuralFraming.EndSetback StructuralFraming.Profile StructuralFraming.Rotation StructuralFraming.Volume() StructuralFraming.ProfileTransformed() StructuralFraming.UpdateRepresentations() GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Column : StructuralFraming, INotifyPropertyChanged Constructors Column(Vector3, Double, Profile, Material, Transform, Double, Double, Double, Boolean, Guid, String) Construct a Column. Declaration public Column(Vector3 location, double height, Profile profile, Material material = null, Transform transform = null, double startSetback = 0, double endSetback = 0, double rotation = 0, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Vector3 location The location of the base of the column. System.Double height The column's height. Profile profile The column's profile. Material material The column's material. Transform transform The column's transform. System.Double startSetback The setback of the column's extrusion from the base of the column. System.Double endSetback The setback of the column's extrusion from the top of the column. System.Double rotation An optional rotation of the column's profile around its axis. System.Boolean isElementDefinition Is this an element definition? System.Guid id The column's id. System.String name The column's name. Properties Height The height of the column. Declaration public double Height { get; set; } Property Value Type Description System.Double Location The location of the base of the column. Declaration public Vector3 Location { get; set; } Property Value Type Description Vector3 Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.ContentCatalog.html": {
    "href": "api/Elements.ContentCatalog.html",
    "title": "Class ContentCatalog | Hypar Docs",
    "keywords": "Class ContentCatalog A collection of ContentElements Inheritance System.Object Element ContentCatalog Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ContentCatalog : Element, INotifyPropertyChanged Constructors ContentCatalog(IList<ContentElement>, Guid, String) Declaration public ContentCatalog(IList<ContentElement> content, Guid id, string name) Parameters Type Name Description System.Collections.Generic.IList < ContentElement > content System.Guid id System.String name Properties Content The content elements in this catalog. Declaration public IList<ContentElement> Content { get; set; } Property Value Type Description System.Collections.Generic.IList < ContentElement > Methods FromJson(String) Deserialize the give JSON text into the ContentCatalog Declaration public static ContentCatalog FromJson(string json) Parameters Type Name Description System.String json Returns Type Description ContentCatalog ToJson() Convert the ContentCatalog into it's JSON representation. Declaration public string ToJson() Returns Type Description System.String Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.ContentElement.html": {
    "href": "api/Elements.ContentElement.html",
    "title": "Class ContentElement | Hypar Docs",
    "keywords": "Class ContentElement An element representing user content. Inheritance System.Object Element GeometricElement ContentElement Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ContentElement : GeometricElement, INotifyPropertyChanged Constructors ContentElement(String, BBox3, Double, Vector3, Transform, Material, Representation, Boolean, Guid, String) Declaration public ContentElement(string gltfLocation, BBox3 boundingBox, double gltfScaleToMeters, Vector3 sourceDirection, Transform transform, Material material, Representation representation, bool isElementDefinition, Guid id, string name) Parameters Type Name Description System.String gltfLocation BBox3 boundingBox System.Double gltfScaleToMeters Vector3 sourceDirection Transform transform Material material Representation representation System.Boolean isElementDefinition System.Guid id System.String name ContentElement(String, BBox3, Double, Vector3, Transform, Material, Representation, Boolean, Guid, String, String) This constructor adds the ability to include additionalProperties. The additional properties should be a dictionary that has been serialized to a string, they are deserialized during construction. This is used in Revit Content workflows to store instance parameter data. Declaration public ContentElement(string gltfLocation, BBox3 boundingBox, double gltfScaleToMeters, Vector3 sourceDirection, Transform transform, Material material, Representation representation, bool isElementDefinition, Guid id, string name, string additionalProperties) Parameters Type Name Description System.String gltfLocation The path to the .glb file. BBox3 boundingBox The BBox3 of this Content Element. System.Double gltfScaleToMeters The number required to scale this contents dimensions to meters. Used during gltf merging. Vector3 sourceDirection The direction the element was facing when it was extracted from it's source. Transform transform The transform of this ContentElement. Material material The material, used for the BBox representation of this element. Representation representation The representation which will be updated when needed. System.Boolean isElementDefinition Should the element be used to create instances, or should it be inserted into a 3D scene. System.Guid id The guid of this element. System.String name The name of this element. System.String additionalProperties The string json serialization of a dictionary of additional parameters. Properties AdditionalProperties Declaration public IDictionary<string, object> AdditionalProperties { get; set; } Property Value Type Description System.Collections.Generic.IDictionary < System.String , System.Object > BoundingBox The bounding box of the content. Declaration public BBox3 BoundingBox { get; set; } Property Value Type Description BBox3 GltfLocation The URI of the gltf for this element. Declaration public string GltfLocation { get; set; } Property Value Type Description System.String GltfScaleToMeters The scale needed to convert the gltf to meters. Declaration public double GltfScaleToMeters { get; set; } Property Value Type Description System.Double SourceDirection A vector indicating the direction the source object was originally facing. Declaration public Vector3 SourceDirection { get; set; } Property Value Type Description Vector3 Methods UpdateRepresentations() Update the ContentElement representation with a solid of the Bounding Box. This is used in the absence of finding a the Gltf for import. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.DirectionalLight.html": {
    "href": "api/Elements.DirectionalLight.html",
    "title": "Class DirectionalLight | Hypar Docs",
    "keywords": "Class DirectionalLight A directional light. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_DirectionalLight.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a directional light. var origin = new Vector3(10, 10, 10); var light = new DirectionalLight(Colors.White, new Transform(origin, origin.Unitized()), 1.0); var sunMaterial = new Material(\"Sun\", Colors.Yellow, unlit: true); // Create a model curve to visualize the light direction. var dirCurve = new ModelCurve(new Line(light.Transform.Origin, light.Transform.Origin + light.Transform.ZAxis.Negate() * 10), sunMaterial); var floor = new Floor(Polygon.Rectangle(20, 20), 0.1); var column = new Column(new Vector3(5, 5), 5.0, Polygon.Rectangle(0.2, 0.2)); var mass = new Mass(Polygon.Rectangle(1, 1), 1.0, sunMaterial, new Transform(light.Transform.Origin)); Inheritance System.Object Element DirectionalLight Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class DirectionalLight : Element, INotifyPropertyChanged Constructors DirectionalLight(Color, Transform, Double, Guid, String) Create a directional light. Declaration public DirectionalLight(Color color, Transform transform, double intensity = 1, Guid id = default(Guid), string name = \"Sun\") Parameters Type Name Description Color color The color of the light. Transform transform The light's transform. System.Double intensity The intensity of the light measured in lux. System.Guid id The unique identifier of the light. System.String name The name of the light. Properties Color The color of the light. The color's alpha value will be ignored. Declaration public Color Color { get; set; } Property Value Type Description Color Intensity The intensity of the light measured in lux. Declaration public double Intensity { get; set; } Property Value Type Description System.Double Transform The light's transform. The light will be aimed along the transform's -Z axis. Declaration public Transform Transform { get; set; } Property Value Type Description Transform Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Domain1d.html": {
    "href": "api/Elements.Domain1d.html",
    "title": "Struct Domain1d | Hypar Docs",
    "keywords": "Struct Domain1d A 1 dimensional interval or domain. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements Assembly : Hypar.Elements.dll Syntax public struct Domain1d Constructors Domain1d(Double, Double) Construct a 1D Domain Declaration public Domain1d(double min = 0, double max = 1) Parameters Type Name Description System.Double min The lower bound of the domain. System.Double max The upper bound of the domain. Properties Length The length of the domain — Max-Min. Note that for non-increasing domains this value can be negative. Declaration public double Length { get; } Property Value Type Description System.Double Max The upper bound of the domain Declaration public double Max { get; } Property Value Type Description System.Double Min The lower bound of the domain Declaration public double Min { get; } Property Value Type Description System.Double Methods DivideByCount(Int32) Split a domain evenly into N subdomains. Declaration public Domain1d[] DivideByCount(int n) Parameters Type Name Description System.Int32 n The number of domains Returns Type Description Domain1d [] An array of N equally-sized subdomains. IsCloseToBoundary(Double) Test if a position is within global tolerance of the domain boundary. Declaration public bool IsCloseToBoundary(double position) Parameters Type Name Description System.Double position The position to test. Returns Type Description System.Boolean True if the position is within tolerance of the domain Min or Max. SplitAt(Double) Split domain into two at a position within its extents. Positions at the domain's ends will be rejected. Declaration public Domain1d[] SplitAt(double position) Parameters Type Name Description System.Double position The position value at which to split the domain. Returns Type Description Domain1d [] An array of 2 1d domains split at the designated position. ToString() Convert to string of the form \"From Min to Max\" Declaration public override string ToString() Returns Type Description System.String Overrides System.ValueType.ToString()"
  },
  "api/Elements.DomainExtensions.html": {
    "href": "api/Elements.DomainExtensions.html",
    "title": "Class DomainExtensions | Hypar Docs",
    "keywords": "Class DomainExtensions Extension and utility methods for mathematical operations. Inheritance System.Object DomainExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class DomainExtensions Methods ApproximatelyEquals(Double, Double, Double) Test if two values are approximately equal to each other with an optional tolerance value. Declaration public static bool ApproximatelyEquals(this double value, double other, double tolerance = 1E-05) Parameters Type Name Description System.Double value The first value to test. System.Double other The other value to test. System.Double tolerance The threshold for equality. If not supplied, the global tolerance will be used. Returns Type Description System.Boolean True if |other - value| < tolerance MapBetweenDomains(Double, Domain1d, Domain1d) Map/Scale a value from one domain to another. 3 mapped from (2,4) to (10, 20) would be 15. Declaration public static double MapBetweenDomains(this double value, Domain1d source, Domain1d target) Parameters Type Name Description System.Double value The value to map. Domain1d source The source domain to map from. Domain1d target The target domain to map to. Returns Type Description System.Double MapFromDomain(Double, Domain1d) Map/Normalize a value from a domain to the domain (0,1). Declaration public static double MapFromDomain(this double value, Domain1d domain) Parameters Type Name Description System.Double value The value to map Domain1d domain The domain to map from. Returns Type Description System.Double (value - domain.Min) / domain.Length MapToDomain(Double, Domain1d) Map/scale a value between 0-1 to a target domain. Will not reject values outside 0-1. Declaration public static double MapToDomain(this double value, Domain1d domain) Parameters Type Name Description System.Double value The value to map. Domain1d domain The domain to map to. Returns Type Description System.Double value * domain.Length + domain.Min"
  },
  "api/Elements.Element.html": {
    "href": "api/Elements.Element.html",
    "title": "Class Element | Hypar Docs",
    "keywords": "Class Element An object which is identified with a unique identifier and a name. Inheritance System.Object Element ContentCatalog DirectionalLight ElementInstance GeometricElement Profile Material Implements System.ComponentModel.INotifyPropertyChanged Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public abstract class Element : INotifyPropertyChanged Constructors Element(Guid, String) Declaration public Element(Guid id, string name) Parameters Type Name Description System.Guid id System.String name Properties Id A unique id. Declaration public Guid Id { get; set; } Property Value Type Description System.Guid Name A name. Declaration public string Name { get; set; } Property Value Type Description System.String Methods RaisePropertyChanged(String) Declaration protected virtual void RaisePropertyChanged(string propertyName = null) Parameters Type Name Description System.String propertyName Events PropertyChanged Declaration public event PropertyChangedEventHandler PropertyChanged Event Type Type Description System.ComponentModel.PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.ElementInstance.html": {
    "href": "api/Elements.ElementInstance.html",
    "title": "Class ElementInstance | Hypar Docs",
    "keywords": "Class ElementInstance An instance of an element in the model. Instances point to one instance of a type, but have individual ids and transforms. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ElementInstance.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a test user element. var profile = new Profile(Polygon.Rectangle(1.0, 1.0)); var material = new Material(\"yellow\", Colors.Yellow); var line = new Line(Vector3.Origin, new Vector3(5, 5, 5)); // Set the isElementDefinition parameter to true, // so the element is considered an instance definition. var testUserElement = new TestUserElement(line, profile, material, isElementDefinition: true); // Create instances of that element // with varied transforms. var attractor = new Vector3(30, 20); for (var x = 0.0; x < 50; x += 1.5) { for (var y = 0.0; y < 50; y += 1.5) { var loc = new Vector3(x, y); var d = loc.DistanceTo(attractor); var s = d == 0 ? 1 : 5 * Math.Sin(1 / d); var t = new Transform(); t.Scale(new Vector3(s, s, s)); t.Move(loc); var instance = testUserElement.CreateInstance(t, $\"Test User Element {x}:{y}\"); this.Model.AddElement(instance); } } Inheritance System.Object Element ElementInstance Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ElementInstance : Element, INotifyPropertyChanged Properties BaseDefinition The element from which this instance is derived. Declaration public GeometricElement BaseDefinition { get; } Property Value Type Description GeometricElement Transform The transform of the instance. Declaration public Transform Transform { get; } Property Value Type Description Transform Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Floor.html": {
    "href": "api/Elements.Floor.html",
    "title": "Class Floor | Hypar Docs",
    "keywords": "Class Floor A floor is a horizontal element defined by a profile. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Floor.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a floor with no elevation. var p = Polygon.L(10, 20, 5); var floor1 = new Floor(p, 0.1); // Create a floor with an elevation. var floor2 = new Floor(p, 0.1, new Transform(0, 0, 3)); // Create some openings. floor1.AddOpening(1, 1, 1, 1); floor1.AddOpening(3, 3, 1, 3); Inheritance System.Object Element GeometricElement Floor Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Floor : GeometricElement, INotifyPropertyChanged, IHasOpenings Constructors Floor(Profile, Double, Transform, Material, Representation, Boolean, Guid, String) Create a floor. Declaration public Floor(Profile profile, double thickness, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The perimeter of the floor. System.Double thickness The thickness of the floor. Transform transform The floor's transform. Create a transform with a Z coordinate for the origin, to define the elevation of the floor. Material material The floor's material. Representation representation The floor's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The floor's id. System.String name The floor's name. Properties Elevation The elevation from which the floor is extruded. Declaration public double Elevation { get; } Property Value Type Description System.Double Openings A collection of openings in the floor. Declaration public List<Opening> Openings { get; } Property Value Type Description System.Collections.Generic.List < Opening > Profile The untransformed profile of the floor. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Thickness The thickness of the floor. Declaration public double Thickness { get; set; } Property Value Type Description System.Double Methods AddOpening(Polygon, Double, Double, Double, Double) Add an opening in the wall. Declaration public Opening AddOpening(Polygon perimeter, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description Polygon perimeter The perimeter of the opening. System.Double x The distance to the origin of the perimeter along the host's x axis. System.Double y The height to the origin of the perimeter along the host's y axis. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening AddOpening(Double, Double, Double, Double, Double, Double) Add an opening. Declaration public Opening AddOpening(double width, double height, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description System.Double width The width of the opening. System.Double height The height of the opening. System.Double x The distance to the center of the opening along the host's x axis. System.Double y The distance to the center of the opening along the host's y axis. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening Area() The area of the floor. Declaration public double Area() Returns Type Description System.Double The area of the floor, not including the area of openings. ProfileTransformed() Get the profile of the floor transformed by the floor's transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() The area of the floor. Declaration public double Volume() Returns Type Description System.Double The area of the floor, not including the area of openings. Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings"
  },
  "api/Elements.Frame.html": {
    "href": "api/Elements.Frame.html",
    "title": "Class Frame | Hypar Docs",
    "keywords": "Class Frame An element defined by a perimeter and a cross section swept along that perimeter. Inheritance System.Object Element GeometricElement Frame Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Frame : GeometricElement, INotifyPropertyChanged Constructors Frame(Polygon, Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Create a frame. Declaration public Frame(Polygon curve, Profile profile, double offset = 0, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon curve The frame's perimeter. Profile profile The frame's profile. System.Double offset The amount which the perimeter will be offset internally. Material material The frame's material. Transform transform The frame's transform. Representation representation The frame's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the frame. System.String name The name of the frame. Properties Curve The perimeter of the frame. Declaration public Curve Curve { get; set; } Property Value Type Description Curve Profile The frame's profile. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Methods UpdateRepresentations() Update representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.GeoJSON.Feature.html": {
    "href": "api/Elements.GeoJSON.Feature.html",
    "title": "Class Feature | Hypar Docs",
    "keywords": "Class Feature A GeoJSON feature. Inheritance System.Object Feature Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Feature Constructors Feature(Geometry, Dictionary<String, Object>) Construct a feature. Declaration public Feature(Geometry geometry, Dictionary<string, object> properties) Parameters Type Name Description Geometry geometry System.Collections.Generic.Dictionary < System.String , System.Object > properties Properties BBox The bounding box of the feature. Declaration public IEnumerable<double> BBox { get; } Property Value Type Description System.Collections.Generic.IEnumerable < System.Double > Geometry The geometry of the feature. Declaration public Geometry Geometry { get; set; } Property Value Type Description Geometry Properties All properties of the feature. Declaration public Dictionary<string, object> Properties { get; set; } Property Value Type Description System.Collections.Generic.Dictionary < System.String , System.Object > Type The type of the feature. Declaration public string Type { get; } Property Value Type Description System.String"
  },
  "api/Elements.GeoJSON.FeatureCollection.html": {
    "href": "api/Elements.GeoJSON.FeatureCollection.html",
    "title": "Class FeatureCollection | Hypar Docs",
    "keywords": "Class FeatureCollection A GeoJSON feature collection. Inheritance System.Object FeatureCollection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class FeatureCollection Constructors FeatureCollection(IEnumerable<Feature>) Construct a feature collection. Declaration public FeatureCollection(IEnumerable<Feature> features) Parameters Type Name Description System.Collections.Generic.IEnumerable < Feature > features A collection of features. Properties Features A collection of features. Declaration public IEnumerable<Feature> Features { get; set; } Property Value Type Description System.Collections.Generic.IEnumerable < Feature > Type The type of the feature. Declaration public string Type { get; } Property Value Type Description System.String"
  },
  "api/Elements.GeoJSON.Geometry.html": {
    "href": "api/Elements.GeoJSON.Geometry.html",
    "title": "Class Geometry | Hypar Docs",
    "keywords": "Class Geometry The base class for all GeoJSON geometry types. Inheritance System.Object Geometry Line LineString MultiLineString MultiPoint MultiPolygon Point Polygon Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public abstract class Geometry Properties Type The type of the geometry. Declaration public virtual string Type { get; } Property Value Type Description System.String"
  },
  "api/Elements.GeoJSON.GeometryCollection.html": {
    "href": "api/Elements.GeoJSON.GeometryCollection.html",
    "title": "Class GeometryCollection | Hypar Docs",
    "keywords": "Class GeometryCollection A GeoJSON geometry collection. Inheritance System.Object GeometryCollection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class GeometryCollection Constructors GeometryCollection(Geometry[]) Construct a geometry collection. Declaration public GeometryCollection(Geometry[] geometries) Parameters Type Name Description Geometry [] geometries An array of geometries."
  },
  "api/Elements.GeoJSON.html": {
    "href": "api/Elements.GeoJSON.html",
    "title": "Namespace Elements.GeoJSON | Hypar Docs",
    "keywords": "Namespace Elements.GeoJSON Classes Feature A GeoJSON feature. FeatureCollection A GeoJSON feature collection. Geometry The base class for all GeoJSON geometry types. GeometryCollection A GeoJSON geometry collection. Line A GeoJSON line. LineString A GeoJSON linestring. MultiLineString A GeoJSON multi line string. MultiPoint A GeoJSON multipoint. MultiPolygon A GeoJSON multi polygon. Point A GeoJSON point. Polygon A GeoJSON polygon. Position A position."
  },
  "api/Elements.GeoJSON.Line.html": {
    "href": "api/Elements.GeoJSON.Line.html",
    "title": "Class Line | Hypar Docs",
    "keywords": "Class Line A GeoJSON line. Inheritance System.Object Geometry Line Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Line : Geometry Constructors Line(Position[]) Construct a Line. Declaration public Line(Position[] coordinates) Parameters Type Name Description Position [] coordinates Properties Coordinates The coordinates of the geometry. Declaration public Position[] Coordinates { get; } Property Value Type Description Position []"
  },
  "api/Elements.GeoJSON.LineString.html": {
    "href": "api/Elements.GeoJSON.LineString.html",
    "title": "Class LineString | Hypar Docs",
    "keywords": "Class LineString A GeoJSON linestring. Inheritance System.Object Geometry LineString Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class LineString : Geometry Constructors LineString(Position[]) Construct a LineString. Declaration public LineString(Position[] coordinates) Parameters Type Name Description Position [] coordinates Properties Coordinates The coordinates of the geometry. Declaration public Position[] Coordinates { get; } Property Value Type Description Position []"
  },
  "api/Elements.GeoJSON.MultiLineString.html": {
    "href": "api/Elements.GeoJSON.MultiLineString.html",
    "title": "Class MultiLineString | Hypar Docs",
    "keywords": "Class MultiLineString A GeoJSON multi line string. Inheritance System.Object Geometry MultiLineString Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class MultiLineString : Geometry Constructors MultiLineString(Position[][]) Construct a MultiLineString. Declaration public MultiLineString(Position[][] coordinates) Parameters Type Name Description Position [][] coordinates Properties Coordinates The coordinates of the geometry. Declaration public Position[][] Coordinates { get; } Property Value Type Description Position [][]"
  },
  "api/Elements.GeoJSON.MultiPoint.html": {
    "href": "api/Elements.GeoJSON.MultiPoint.html",
    "title": "Class MultiPoint | Hypar Docs",
    "keywords": "Class MultiPoint A GeoJSON multipoint. Inheritance System.Object Geometry MultiPoint Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class MultiPoint : Geometry Constructors MultiPoint(Position[]) Construct a MultiPoint. Declaration public MultiPoint(Position[] coordinates) Parameters Type Name Description Position [] coordinates Properties Coordinates The coordinates of the geometry. Declaration public Position[] Coordinates { get; } Property Value Type Description Position []"
  },
  "api/Elements.GeoJSON.MultiPolygon.html": {
    "href": "api/Elements.GeoJSON.MultiPolygon.html",
    "title": "Class MultiPolygon | Hypar Docs",
    "keywords": "Class MultiPolygon A GeoJSON multi polygon. Inheritance System.Object Geometry MultiPolygon Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class MultiPolygon : Geometry Constructors MultiPolygon(Position[][]) Construct a MultiPolygon. Declaration public MultiPolygon(Position[][] coordinates) Parameters Type Name Description Position [][] coordinates Properties Coordinates The coordinates of the geometry. Declaration public Position[][] Coordinates { get; } Property Value Type Description Position [][]"
  },
  "api/Elements.GeoJSON.Point.html": {
    "href": "api/Elements.GeoJSON.Point.html",
    "title": "Class Point | Hypar Docs",
    "keywords": "Class Point A GeoJSON point. Inheritance System.Object Geometry Point Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Point : Geometry Constructors Point(Position) Construct a Point. Declaration public Point(Position coordinates) Parameters Type Name Description Position coordinates Properties Coordinates The coordinates of the geometry. Declaration public Position Coordinates { get; } Property Value Type Description Position"
  },
  "api/Elements.GeoJSON.Polygon.html": {
    "href": "api/Elements.GeoJSON.Polygon.html",
    "title": "Class Polygon | Hypar Docs",
    "keywords": "Class Polygon A GeoJSON polygon. Inheritance System.Object Geometry Polygon Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Polygon : Geometry Constructors Polygon(Position[][]) Construct a Polygon. Declaration public Polygon(Position[][] coordinates) Parameters Type Name Description Position [][] coordinates Properties Coordinates The coordinates of the geometry. Declaration public Position[][] Coordinates { get; } Property Value Type Description Position [][] Methods ToPolygons() Convert the coordinate array to a collection of polygons. The last position of the polygon is dropped. Declaration public Polygon[] ToPolygons() Returns Type Description Polygon []"
  },
  "api/Elements.GeoJSON.Position.html": {
    "href": "api/Elements.GeoJSON.Position.html",
    "title": "Class Position | Hypar Docs",
    "keywords": "Class Position A position. Inheritance System.Object Position Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Position Constructors Position(Double, Double) Declaration public Position(double latitude, double longitude) Parameters Type Name Description System.Double latitude System.Double longitude Properties Latitude The latitude in decimal degrees. Declaration public double Latitude { get; set; } Property Value Type Description System.Double Longitude The longitude in decimal degrees. Declaration public double Longitude { get; set; } Property Value Type Description System.Double Methods Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() ToVectorMeters() Convert the position to a vector. Declaration public Vector3 ToVectorMeters() Returns Type Description Vector3"
  },
  "api/Elements.GeometricElement.html": {
    "href": "api/Elements.GeometricElement.html",
    "title": "Class GeometricElement | Hypar Docs",
    "keywords": "Class GeometricElement An element with a geometric representation. Inheritance System.Object Element GeometricElement AnalysisMesh ContentElement Floor Frame Mass MeshElement ModelCurve ModelPoints Opening Panel Space StructuralFraming Wall WallByProfile Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class GeometricElement : Element, INotifyPropertyChanged Constructors GeometricElement(Transform, Material, Representation, Boolean, Guid, String) Declaration public GeometricElement(Transform transform, Material material, Representation representation, bool isElementDefinition, Guid id, string name) Parameters Type Name Description Transform transform Material material Representation representation System.Boolean isElementDefinition System.Guid id System.String name Properties IsElementDefinition When true, this element will act as the base definition for element instances, and will not appear in visual output. Declaration public bool IsElementDefinition { get; set; } Property Value Type Description System.Boolean Material The element's material. Declaration public Material Material { get; set; } Property Value Type Description Material Representation The element's representation. Declaration public Representation Representation { get; set; } Property Value Type Description Representation Transform The element's transform. Declaration public Transform Transform { get; set; } Property Value Type Description Transform Methods CreateInstance(Transform, String) Create an instance of this element. Instances will point to the same instance of an element. Declaration public ElementInstance CreateInstance(Transform transform, string name) Parameters Type Name Description Transform transform The transform for this element instance. System.String name The name of this element instance. Returns Type Description ElementInstance UpdateRepresentations() This method provides an opportunity for geometric elements to adjust their solid operations before tesselation. As an example, a floor might want to clip its opening profiles out of the profile of the floor. Declaration public virtual void UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Geometry.Arc.html": {
    "href": "api/Elements.Geometry.Arc.html",
    "title": "Class Arc | Hypar Docs",
    "keywords": "Class Arc An arc defined by a CCW rotation around a center between a start angle and an end angle. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Arc.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var arc = new Arc(Vector3.Origin, 2.0, 0.0, 90.0); Assert.True(new Vector3(2, 0, 0).IsAlmostEqualTo(arc.Start)); Assert.True(new Vector3(0, 2, 0).IsAlmostEqualTo(arc.End)); var arc1 = new Arc(Vector3.Origin, 2.0, 0.0, -90.0); Assert.True(new Vector3(2, 0, 0).IsAlmostEqualTo(arc1.Start)); Assert.True(new Vector3(0, -2, 0).IsAlmostEqualTo(arc1.End)); Inheritance System.Object Curve Arc Circle Implements ITransformable < Curve > ICurve System.IEquatable < Arc > Inherited Members Curve.MinimumChordLength Curve.Frames(Double, Double) Curve.ToPolyline(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Arc : Curve, ITransformable<Curve>, ICurve, IEquatable<Arc> Constructors Arc(Vector3, Double, Double, Double) Declaration public Arc(Vector3 center, double radius, double startAngle, double endAngle) Parameters Type Name Description Vector3 center System.Double radius System.Double startAngle System.Double endAngle Arc(Double, Double, Double) Construct an arc. Declaration public Arc(double radius, double startAngle, double endAngle) Parameters Type Name Description System.Double radius The radius of the arc. System.Double startAngle The angle from 0.0, in degrees, at which the arc will start with respect to the positive X axis. System.Double endAngle The angle from 0.0, in degrees, at which the arc will end with respect to the positive X axis. Properties Center The center of the arc. Declaration public Vector3 Center { get; set; } Property Value Type Description Vector3 End The end point of the arc. Declaration public Vector3 End { get; } Property Value Type Description Vector3 EndAngle The angle from 0.0, in degrees, at which the arc will end with respect to the positive X axis. Declaration public double EndAngle { get; set; } Property Value Type Description System.Double Radius The radius of the arc. Declaration public double Radius { get; set; } Property Value Type Description System.Double Start The start point of the arc. Declaration public Vector3 Start { get; } Property Value Type Description Vector3 StartAngle The angle from 0.0, in degrees, at which the arc will start with respect to the positive X axis. Declaration public double StartAngle { get; set; } Property Value Type Description System.Double Methods Bounds() Get a bounding box for this arc. Declaration public override BBox3 Bounds() Returns Type Description BBox3 A bounding box for this arc. Overrides Curve.Bounds() Complement() Return the arc which is the complement of this arc. Declaration public Arc Complement() Returns Type Description Arc Equals(Arc) Is this arc equal to the provided arc? Declaration public bool Equals(Arc other) Parameters Type Name Description Arc other The arc to test. Returns Type Description System.Boolean Returns true if the two arcs are equal, otherwise false. Length() Calculate the length of the arc. Declaration public override double Length() Returns Type Description System.Double Overrides Curve.Length() Plane() Compute the plane of the arc. Declaration public Plane Plane() Returns Type Description Plane The plane in which the arc lies. PointAt(Double) Return the point at parameter u on the arc. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 A Vector3 representing the point along the arc. Overrides Curve.PointAt(Double) Reversed() Get an arc which is the reverse of this Arc. Declaration public Arc Reversed() Returns Type Description Arc TransformAt(Double) Return transform on the arc at parameter u. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0 on the arc. Returns Type Description Transform A transform with its origin at u along the curve and its Z axis tangent to the curve. Overrides Curve.TransformAt(Double) Transformed(Transform) Construct a transformed copy of this Curve. Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedArc(Transform) Construct a transformed copy of this Arc. Declaration public Arc TransformedArc(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Arc Implements ITransformable<T> ICurve System.IEquatable<T>"
  },
  "api/Elements.Geometry.BBox3.html": {
    "href": "api/Elements.Geometry.BBox3.html",
    "title": "Struct BBox3 | Hypar Docs",
    "keywords": "Struct BBox3 An axis-aligned bounding box. Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct BBox3 Constructors BBox3(Profile) Create the BBox3 for a Profile. Declaration public BBox3(Profile profile) Parameters Type Name Description Profile profile The Profile. BBox3(Vector3, Vector3) Declaration public BBox3(Vector3 min, Vector3 max) Parameters Type Name Description Vector3 min Vector3 max BBox3(IList<Polygon>) Create a bounding box for a collection of polygons. Declaration public BBox3(IList<Polygon> polygons) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons BBox3(IList<Vector3>) Construct a bounding box from an array of points. Declaration public BBox3(IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points which are contained within the bounding box. Properties Max The maximum extent of the bounding box. Declaration public Vector3 Max { get; set; } Property Value Type Description Vector3 Min The minimum extent of the bounding box. Declaration public Vector3 Min { get; set; } Property Value Type Description Vector3 Methods Center() Get the center of the bounding box. Declaration public Vector3 Center() Returns Type Description Vector3 The center of the bounding box. Equals(Object) Is the provided object a bounding box? If so, is it equal to this bounding box within Epsilon? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.ValueType.Equals(System.Object) GetHashCode() Get the hash code for the bounding box. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() ToString() The string representation of the bounding box. Declaration public override string ToString() Returns Type Description System.String Overrides System.ValueType.ToString() Translated(Vector3) Get a translated copy of the bounding box. Declaration public BBox3 Translated(Vector3 translation) Parameters Type Name Description Vector3 translation The translation to apply. Returns Type Description BBox3 Operators Equality(BBox3, BBox3) Are the two bounding boxes equal within Epsilon? Declaration public static bool operator ==(BBox3 a, BBox3 b) Parameters Type Name Description BBox3 a BBox3 b Returns Type Description System.Boolean Inequality(BBox3, BBox3) Are the two bounding boxes not equal within Epsilon? Declaration public static bool operator !=(BBox3 a, BBox3 b) Parameters Type Name Description BBox3 a BBox3 b Returns Type Description System.Boolean"
  },
  "api/Elements.Geometry.Bezier.html": {
    "href": "api/Elements.Geometry.Bezier.html",
    "title": "Class Bezier | Hypar Docs",
    "keywords": "Class Bezier A Bezier curve. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Bezier.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = Vector3.Origin; var b = new Vector3(5, 0, 1); var c = new Vector3(5, 5, 2); var d = new Vector3(0, 5, 3); var e = new Vector3(0, 0, 4); var f = new Vector3(5, 0, 5); var ctrlPts = new List<Vector3>{a,b,c,d,e,f}; var bezier = new Bezier(ctrlPts); Inheritance System.Object Curve Bezier Implements ICurve ITransformable < Curve > Inherited Members Curve.MinimumChordLength Curve.ToPolyline(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Bezier : Curve, ICurve, ITransformable<Curve> Constructors Bezier(List<Vector3>, FrameType) Construct a bezier. Declaration public Bezier(List<Vector3> controlPoints, FrameType frameType = FrameType.Frenet) Parameters Type Name Description System.Collections.Generic.List < Vector3 > controlPoints The control points of the curve. FrameType frameType The frame type to use when calculating frames. Properties ControlPoints A collection of points describing the bezier's frame. https://en.wikipedia.org/wiki/B%C3%A9zier_curve Declaration public List<Vector3> ControlPoints { get; set; } Property Value Type Description System.Collections.Generic.List < Vector3 > FrameType The frame type to use when calculating transforms along the curve. Declaration public FrameType FrameType { get; set; } Property Value Type Description FrameType Methods AccelerationAt(Double) Get the acceleration of the curve at parameter u. Declaration public Vector3 AccelerationAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 BinormalAt(Double) Get the binormal to the curve at parameter u. Declaration public Vector3 BinormalAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 Bounds() Get the bounding box of the curve's control points. Declaration public override BBox3 Bounds() Returns Type Description BBox3 Overrides Curve.Bounds() Frames(Double, Double) Get a collection of transforms along the curve. Declaration public override Transform[] Frames(double startSetback = 0, double endSetback = 0) Parameters Type Name Description System.Double startSetback System.Double endSetback Returns Type Description Transform [] Overrides Curve.Frames(Double, Double) Length() Get a piecewise linear approximation of the length of the curve. https://en.wikipedia.org/wiki/Arc_length Declaration public override double Length() Returns Type Description System.Double Overrides Curve.Length() NormalAt(Double) Get the normal of the curve at parameter u. Declaration public Vector3 NormalAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 PointAt(Double) Get the point on the curve at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u The parameter between 0.0 and 1.0. Returns Type Description Vector3 Overrides Curve.PointAt(Double) TangentAt(Double) Get the tangent to the curve at parameter u. Declaration public Vector3 TangentAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 TransformAt(Double) Get the transform on the curve at parameter u. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter along the curve between 0.0 and 1.0. Returns Type Description Transform Overrides Curve.TransformAt(Double) Transformed(Transform) Construct a transformed copy of this Curve. Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedBezier(Transform) Construct a transformed copy of this Bezier. Declaration public Bezier TransformedBezier(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Bezier VelocityAt(Double) Get the velocity to the curve at parameter u. Declaration public Vector3 VelocityAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 Implements ICurve ITransformable<T>"
  },
  "api/Elements.Geometry.BooleanMode.html": {
    "href": "api/Elements.Geometry.BooleanMode.html",
    "title": "Enum BooleanMode | Hypar Docs",
    "keywords": "Enum BooleanMode Mode to apply a boolean operation Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum BooleanMode Fields Name Description Difference A and not B Intersection A and B Union A or B XOr Exclusive or — either A or B but not both."
  },
  "api/Elements.Geometry.Circle.html": {
    "href": "api/Elements.Geometry.Circle.html",
    "title": "Class Circle | Hypar Docs",
    "keywords": "Class Circle An arc with a start angle of 0 (+X) and an end angle of 360.0. Inheritance System.Object Curve Arc Circle Implements ITransformable < Curve > ICurve System.IEquatable < Arc > Inherited Members Arc.Center Arc.Radius Arc.StartAngle Arc.EndAngle Arc.Length() Arc.Start Arc.End Arc.PointAt(Double) Arc.TransformAt(Double) Arc.Reversed() Arc.Bounds() Arc.Plane() Arc.Equals(Arc) Arc.Complement() Arc.Transformed(Transform) Arc.TransformedArc(Transform) Curve.MinimumChordLength Curve.Frames(Double, Double) Curve.ToPolyline(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Circle : Arc, ITransformable<Curve>, ICurve, IEquatable<Arc> Constructors Circle(Vector3, Double) Construct a circle. Declaration public Circle(Vector3 center, double radius = 1) Parameters Type Name Description Vector3 center The center of the circle. System.Double radius The radius of the circle. Circle(Double) Construct a circle. Declaration public Circle(double radius = 1) Parameters Type Name Description System.Double radius The radius of the circle. Methods ToPolygon(Int32) Create a polygon through a set of points along the arc. Declaration public Polygon ToPolygon(int divisions = 10) Parameters Type Name Description System.Int32 divisions The number of divisions of the arc. Returns Type Description Polygon A polygon. Implements ITransformable<T> ICurve System.IEquatable<T>"
  },
  "api/Elements.Geometry.Color.html": {
    "href": "api/Elements.Geometry.Color.html",
    "title": "Struct Color | Hypar Docs",
    "keywords": "Struct Color A color with red, green, blue, and alpha components. Implements System.IEquatable < Color > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct Color : IEquatable<Color> Constructors Color(Double, Double, Double, Double) Declaration public Color(double red, double green, double blue, double alpha) Parameters Type Name Description System.Double red System.Double green System.Double blue System.Double alpha Properties Alpha The alpha component of the color between 0.0 and 1.0. Declaration public double Alpha { get; set; } Property Value Type Description System.Double Blue The blue component of the color between 0.0 and 1.0. Declaration public double Blue { get; set; } Property Value Type Description System.Double Green The green component of the color between 0.0 and 1.0. Declaration public double Green { get; set; } Property Value Type Description System.Double Red The red component of the color between 0.0 and 1.0. Declaration public double Red { get; set; } Property Value Type Description System.Double Methods Equals(Color) Is this color equal to the provided color? Declaration public bool Equals(Color other) Parameters Type Name Description Color other The color to test. Returns Type Description System.Boolean Returns true if the two colors are equal, otherwise false. Equals(Object) Is this color equal to the provided color? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.ValueType.Equals(System.Object) GetHashCode() Get the hash code for this color. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() Lerp(Color, Double) Linearly interpolate between this color and the other color. Declaration public Color Lerp(Color other, double t) Parameters Type Name Description Color other The other color. System.Double t A value between 0.0 and 1.0. Returns Type Description Color ToArray() Get the color's components as an array. Declaration public float[] ToArray() Returns Type Description System.Single [] An array containing the color's components. ToString() Converts this color to a string. Declaration public override string ToString() Returns Type Description System.String Returns a string representation of the form \"R: r, G: g, B: b, A: a\". Overrides System.ValueType.ToString() Operators Addition(Color, Color) Add two colors. Resulting values will be clamped in the range of 0.0 to 1.0. Declaration public static Color operator +(Color a, Color b) Parameters Type Name Description Color a The first color. Color b The second color. Returns Type Description Color Equality(Color, Color) Are the two Colors equal? Declaration public static bool operator ==(Color a, Color b) Parameters Type Name Description Color a Color b Returns Type Description System.Boolean Inequality(Color, Color) Are the two Colors equal? Declaration public static bool operator !=(Color a, Color b) Parameters Type Name Description Color a Color b Returns Type Description System.Boolean Multiply(Color, Color) Multiply two colors. Resulting values will be clamped in the range of 0.0 to 1.0. Declaration public static Color operator *(Color a, Color b) Parameters Type Name Description Color a The first color. Color b The second color. Returns Type Description Color Multiply(Double, Color) Multiply a color and a scalar. Resulting values will be clamped in the range of 0.0 to 1.0. Declaration public static Color operator *(double t, Color a) Parameters Type Name Description System.Double t The scalar. Color a The color. Returns Type Description Color Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.Colors.html": {
    "href": "api/Elements.Geometry.Colors.html",
    "title": "Class Colors | Hypar Docs",
    "keywords": "Class Colors Commonly used colors. Inheritance System.Object Colors Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class Colors Properties Aqua Aqua Declaration public static Color Aqua { get; } Property Value Type Description Color Beige Beige Declaration public static Color Beige { get; } Property Value Type Description Color Black Black Declaration public static Color Black { get; } Property Value Type Description Color Blue Blue Declaration public static Color Blue { get; } Property Value Type Description Color Brown Brown Declaration public static Color Brown { get; } Property Value Type Description Color Cobalt Cobalt Declaration public static Color Cobalt { get; } Property Value Type Description Color Coral Coral Declaration public static Color Coral { get; } Property Value Type Description Color Crimson Crimson Declaration public static Color Crimson { get; } Property Value Type Description Color Cyan Cyan Declaration public static Color Cyan { get; } Property Value Type Description Color Darkgray Dark Gray Declaration public static Color Darkgray { get; } Property Value Type Description Color Emerald Emerald Declaration public static Color Emerald { get; } Property Value Type Description Color Granite Granite Declaration public static Color Granite { get; } Property Value Type Description Color Gray Gray Declaration public static Color Gray { get; } Property Value Type Description Color Green Green Declaration public static Color Green { get; } Property Value Type Description Color Lavender Lavender Declaration public static Color Lavender { get; } Property Value Type Description Color Lime Lime Declaration public static Color Lime { get; } Property Value Type Description Color Magenta Magenta Declaration public static Color Magenta { get; } Property Value Type Description Color Maroon Maroon Declaration public static Color Maroon { get; } Property Value Type Description Color Mint Mint Declaration public static Color Mint { get; } Property Value Type Description Color Navy Navy Declaration public static Color Navy { get; } Property Value Type Description Color Olive Olive Declaration public static Color Olive { get; } Property Value Type Description Color Orange Orange Declaration public static Color Orange { get; } Property Value Type Description Color Pink Pink Declaration public static Color Pink { get; } Property Value Type Description Color Purple Purple Declaration public static Color Purple { get; } Property Value Type Description Color Red Red Declaration public static Color Red { get; } Property Value Type Description Color Sand Sand Declaration public static Color Sand { get; } Property Value Type Description Color Stone Stone Declaration public static Color Stone { get; } Property Value Type Description Color Teal Teal Declaration public static Color Teal { get; } Property Value Type Description Color White White Declaration public static Color White { get; } Property Value Type Description Color Yellow Yellow Declaration public static Color Yellow { get; } Property Value Type Description Color"
  },
  "api/Elements.Geometry.Containment.html": {
    "href": "api/Elements.Geometry.Containment.html",
    "title": "Enum Containment | Hypar Docs",
    "keywords": "Enum Containment Represents the state of containment of a point relative to an enclosing polygon, profile, or solid. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum Containment Fields Name Description CoincidesAtEdge The point lies exactly or nearly at an edge. CoincidesAtFace The point lies exactly or nearly at a face. CoincidesAtVertex The point lies exactly or nearly at a vertex. Inside The point lies entirely inside. Outside The point lies entirely outside."
  },
  "api/Elements.Geometry.Contour.html": {
    "href": "api/Elements.Geometry.Contour.html",
    "title": "Class Contour | Hypar Docs",
    "keywords": "Class Contour A continguous set of curves. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Contour.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var r = 1.0; // The reflection plane. var t = new Transform(); t.Reflect(Vector3.YAxis); var ctrlPoints = new List<Vector3>{ new Vector3(0, -r), new Vector3(1.25, 1), new Vector3(3.75, -1), new Vector3(5, -r) }; var l1 = new Bezier(ctrlPoints); var a1 = new Arc(new Vector3(5, 0), r, -90.0, 90.0); var l2 = (Bezier)l1.Transformed(t); l2.ControlPoints.Reverse(); var a2 = new Arc(new Vector3(0, 0), r, 90.0, 270.0); var contour = new Contour(new List<Curve> { l1, a1, l2, a2 }); Inheritance System.Object Contour Implements System.Collections.Generic.IEnumerable < Curve > System.Collections.IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Contour : IEnumerable<Curve>, IEnumerable Constructors Contour(List<Curve>) Construct a contour. Declaration public Contour(List<Curve> curves) Parameters Type Name Description System.Collections.Generic.List < Curve > curves A list of curves to create the contour. Methods GetEnumerator() Get the enumerator for the collection of curves. Declaration public IEnumerator<Curve> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < Curve > ToPolygon() Convert the contour to a polygon. Declaration public Polygon ToPolygon() Returns Type Description Polygon Explicit Interface Implementations IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable"
  },
  "api/Elements.Geometry.Curve.html": {
    "href": "api/Elements.Geometry.Curve.html",
    "title": "Class Curve | Hypar Docs",
    "keywords": "Class Curve The abstract base class for all curves. Inheritance System.Object Curve Arc Bezier Line Polyline Implements ICurve ITransformable < Curve > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public abstract class Curve : ICurve, ITransformable<Curve> Constructors Curve() Declaration public Curve() Fields MinimumChordLength The minimum chord length allowed for subdivision of the curve. A lower MinimumChordLength results in smoother curves. Declaration public static double MinimumChordLength Field Value Type Description System.Double Methods Bounds() Get the bounding box for this curve. Declaration public abstract BBox3 Bounds() Returns Type Description BBox3 A bounding box for this curve. Frames(Double, Double) Get a collection of transforms which represent frames along this curve. Declaration public virtual Transform[] Frames(double startSetback = 0, double endSetback = 0) Parameters Type Name Description System.Double startSetback The offset parameter from the start of the curve. System.Double endSetback The offset parameter from the end of the curve. Returns Type Description Transform [] A collection of transforms. Length() Calculate the length of the curve. Declaration public abstract double Length() Returns Type Description System.Double PointAt(Double) Get a point along the curve at parameter u. Declaration public abstract Vector3 PointAt(double u) Parameters Type Name Description System.Double u Returns Type Description Vector3 A point on the curve at parameter u. ToPolyline(Int32) Create a polyline through a set of points along the curve. Declaration public virtual Polyline ToPolyline(int divisions = 10) Parameters Type Name Description System.Int32 divisions The number of divisions of the curve. Returns Type Description Polyline A polyline. TransformAt(Double) Get a transform whose XY plane is perpendicular to the curve, and whose positive Z axis points along the curve. Declaration public abstract Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter along the Line, between 0.0 and 1.0, at which to calculate the Transform. Returns Type Description Transform A transform. Transformed(Transform) Construct a transformed copy of this Curve. Declaration public abstract Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Operators Implicit(Curve to ModelCurve) Implicitly convert a curve to a ModelCurve Element. Declaration public static implicit operator ModelCurve(Curve c) Parameters Type Name Description Curve c The curve to convert. Returns Type Description ModelCurve Implements ICurve ITransformable<T>"
  },
  "api/Elements.Geometry.EndType.html": {
    "href": "api/Elements.Geometry.EndType.html",
    "title": "Enum EndType | Hypar Docs",
    "keywords": "Enum EndType Offset end types Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum EndType Fields Name Description Butt Ends are squared off with no extension ClosedPolygon If open, ends are joined and treated as a closed polygon Square Open ends are extended by the offset distance and squared off"
  },
  "api/Elements.Geometry.FrameType.html": {
    "href": "api/Elements.Geometry.FrameType.html",
    "title": "Enum FrameType | Hypar Docs",
    "keywords": "Enum FrameType The frame type to be used for operations requiring a moving frame around the curve. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum FrameType Fields Name Description Frenet A Frenet frame. RoadLike A frame with the up axis aligned with +Z."
  },
  "api/Elements.Geometry.html": {
    "href": "api/Elements.Geometry.html",
    "title": "Namespace Elements.Geometry | Hypar Docs",
    "keywords": "Namespace Elements.Geometry Classes Arc An arc defined by a CCW rotation around a center between a start angle and an end angle. Bezier A Bezier curve. Circle An arc with a start angle of 0 (+X) and an end angle of 360.0. Colors Commonly used colors. Contour A continguous set of curves. Curve The abstract base class for all curves. Line A line between two points. The line is parameterized from 0.0(start) to 1.0(end) Matrix A column-ordered 4x3 matrix. Mesh A triangulated mesh. Plane A plane. Polygon A closed planar polygon. Polyline A continuous set of lines. Profile A profile comprised of an external boundary and one or several holes. ProfileExtensions Profile extension methods. Representation The representation of an element. Transform A right-handed coordinate system with +Z up. Triangle A mesh triangle. Vector3Extensions Extension methods for Vector3. Vertex A mesh vertex. Structs BBox3 An axis-aligned bounding box. Color A color with red, green, blue, and alpha components. Ray An infinite ray starting at origin and pointing towards direction. UV A UV coordinate. Vector3 A 3D vector. Enums BooleanMode Mode to apply a boolean operation Containment Represents the state of containment of a point relative to an enclosing polygon, profile, or solid. EndType Offset end types FrameType The frame type to be used for operations requiring a moving frame around the curve. VoidTreatment Controls the handling of internal regions in a polygon boolean operation."
  },
  "api/Elements.Geometry.Interfaces.html": {
    "href": "api/Elements.Geometry.Interfaces.html",
    "title": "Namespace Elements.Geometry.Interfaces | Hypar Docs",
    "keywords": "Namespace Elements.Geometry.Interfaces Interfaces ICurve ICurve is implemented by all curve types. ITessellate ITransformable<T> An object that can return a transformed copy of itself"
  },
  "api/Elements.Geometry.Interfaces.ICurve.html": {
    "href": "api/Elements.Geometry.Interfaces.ICurve.html",
    "title": "Interface ICurve | Hypar Docs",
    "keywords": "Interface ICurve ICurve is implemented by all curve types. Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface ICurve Methods Bounds() Get the bounding box of this curve. Declaration BBox3 Bounds() Returns Type Description BBox3 Frames(Double, Double) Get a collection of Transforms which represent frames along this ICurve. Declaration Transform[] Frames(double startSetback = 0, double endSetback = 0) Parameters Type Name Description System.Double startSetback The offset from the start of the ICurve. System.Double endSetback The offset from the end of the ICurve. Returns Type Description Transform [] A collection of Transforms. Length() Calculate the length of the curve. Declaration double Length() Returns Type Description System.Double PointAt(Double) Get a point along the curve at parameter u. Declaration Vector3 PointAt(double u) Parameters Type Name Description System.Double u A parameter on the curve between 0.0 and 1.0. Returns Type Description Vector3 The point on the curve. TransformAt(Double) Get the frame from the curve at parameter u. Declaration Transform TransformAt(double u) Parameters Type Name Description System.Double u A parameter on the curve between 0.0 and 1.0. Returns Type Description Transform The transform of the curve at parameter u, with the transform's Z axis tangent to the curve."
  },
  "api/Elements.Geometry.Interfaces.ITessellate.html": {
    "href": "api/Elements.Geometry.Interfaces.ITessellate.html",
    "title": "Interface ITessellate | Hypar Docs",
    "keywords": "Interface ITessellate Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface ITessellate Methods Tessellate(ref Mesh, Transform, Color) Add the tessellated representation of this object to the provided Mesh. Declaration void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh The mesh to which this object's representation will be added. Transform transform An optional transform to apply to each vertex. Color color An optional color to apply to each vertex."
  },
  "api/Elements.Geometry.Interfaces.ITransformable-1.html": {
    "href": "api/Elements.Geometry.Interfaces.ITransformable-1.html",
    "title": "Interface ITransformable<T> | Hypar Docs",
    "keywords": "Interface ITransformable<T> An object that can return a transformed copy of itself Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface ITransformable<T> Type Parameters Name Description T The type of object to be transformed Methods Transformed(Transform) Create a transformed copy of this ITransformable Declaration T Transformed(Transform transform) Parameters Type Name Description Transform transform Returns Type Description T A transformed copy of the object"
  },
  "api/Elements.Geometry.Line.html": {
    "href": "api/Elements.Geometry.Line.html",
    "title": "Class Line | Hypar Docs",
    "keywords": "Class Line A line between two points. The line is parameterized from 0.0(start) to 1.0(end) var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Line.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(); var b = new Vector3(5, 5, 5); var l = new Line(a, b); Inheritance System.Object Curve Line Implements ICurve ITransformable < Curve > System.IEquatable < Line > Inherited Members Curve.MinimumChordLength Curve.Frames(Double, Double) Curve.ToPolyline(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Line : Curve, ICurve, ITransformable<Curve>, IEquatable<Line> Constructors Line() Create a line of one unit length along the X axis. Declaration public Line() Line(Vector3, Vector3) Declaration public Line(Vector3 start, Vector3 end) Parameters Type Name Description Vector3 start Vector3 end Line(Vector3, Vector3, Double) Construct a line of length from a start along direction. Declaration public Line(Vector3 start, Vector3 direction, double length) Parameters Type Name Description Vector3 start Vector3 direction System.Double length Properties End The end of the line. Declaration public Vector3 End { get; set; } Property Value Type Description Vector3 Start The start of the line. Declaration public Vector3 Start { get; set; } Property Value Type Description Vector3 Methods Bounds() Get the bounding box for this line. Declaration public override BBox3 Bounds() Returns Type Description BBox3 A bounding box for this line. Overrides Curve.Bounds() Direction() A normalized vector representing the direction of the line. Declaration public Vector3 Direction() Returns Type Description Vector3 DivideByLength(Double, Boolean) Divide the line into as many segments of the provided length as possible. Declaration public List<Line> DivideByLength(double l, bool removeShortSegments = false) Parameters Type Name Description System.Double l The length. System.Boolean removeShortSegments A flag indicating whether segments shorter than l should be removed. Returns Type Description System.Collections.Generic.List < Line > DivideByLengthFromCenter(Double) Divide the line into as many segments of the provided length as possible. Divisions will be centered along the line. Declaration public List<Line> DivideByLengthFromCenter(double l) Parameters Type Name Description System.Double l The length. Returns Type Description System.Collections.Generic.List < Line > DivideIntoEqualSegments(Int32) Divide the line into n equal segments. Declaration public List<Line> DivideIntoEqualSegments(int n) Parameters Type Name Description System.Int32 n The number of segments. Returns Type Description System.Collections.Generic.List < Line > Equals(Line) Is this line equal to the provided line? Declaration public bool Equals(Line other) Parameters Type Name Description Line other The target line. Returns Type Description System.Boolean True if the start and end points of the lines are equal, otherwise false. ExtendTo(Line) Extend this line to the trimming curve. Declaration public Line ExtendTo(Line line) Parameters Type Name Description Line line The curve to which to extend. Returns Type Description Line A new line, or null if these lines would never intersect if extended infinitely. Fillet(Line, Double) Create a fillet arc between this line and the target. Declaration public Arc Fillet(Line target, double radius) Parameters Type Name Description Line target The line with which to fillet. System.Double radius The radius of the fillet. Returns Type Description Arc An arc, or null if no fillet can be calculated. GetHashCode() Get the hash code for the line. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Intersects(Line, out Vector3, Boolean, Boolean) Does this line intersect the provided line in 3D? Declaration public bool Intersects(Line l, out Vector3 result, bool infinite = false, bool includeEnds = false) Parameters Type Name Description Line l Vector3 result System.Boolean infinite Treat the lines as infinite? System.Boolean includeEnds If the end of one line lies exactly on the other, count it as an intersection? Returns Type Description System.Boolean True if the lines intersect, false if they are fully collinear or do not intersect. Intersects(Plane, out Vector3, Boolean) Intersect this line with the specified plane Declaration public bool Intersects(Plane p, out Vector3 result, bool infinite = false) Parameters Type Name Description Plane p The plane. Vector3 result The location of intersection. System.Boolean infinite If true, line will be treated as infinite. (False by default) Returns Type Description System.Boolean True if the line intersects the plane, false if no intersection occurs. Intersects2D(Line) Does this line intersect the provided line in 2D? Declaration public bool Intersects2D(Line l) Parameters Type Name Description Line l Returns Type Description System.Boolean Return true if the lines intersect, false if the lines have coincident vertices or do not intersect. Length() Calculate the length of the line. Declaration public override double Length() Returns Type Description System.Double Overrides Curve.Length() Offset(Double, Boolean) Offset the line. The offset direction will be defined by Direction X Vector3.ZAxis. Declaration public Line Offset(double distance, bool flip) Parameters Type Name Description System.Double distance The distance to offset. System.Boolean flip Flip the offset direction. Returns Type Description Line PointAt(Double) Get a point along the line at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u Returns Type Description Vector3 A point on the curve at parameter u. Overrides Curve.PointAt(Double) PointOnLine(Vector3, Boolean) Test if a point lies within this line segment Declaration public bool PointOnLine(Vector3 point, bool includeEnds = false) Parameters Type Name Description Vector3 point The point to test. System.Boolean includeEnds Consider a point at the endpoint as on the line. Returns Type Description System.Boolean Reversed() Get a new line that is the reverse of the original line. Declaration public Line Reversed() Returns Type Description Line Thicken(Double) Thicken a line by the specified amount. Declaration public Polygon Thicken(double amount) Parameters Type Name Description System.Double amount The amount to thicken the line. Returns Type Description Polygon TransformAt(Double) Get a transform whose XY plane is perpendicular to the curve, and whose positive Z axis points along the curve. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter along the Line, between 0.0 and 1.0, at which to calculate the Transform. Returns Type Description Transform A transform. Overrides Curve.TransformAt(Double) Transformed(Transform) Construct a transformed copy of this Curve. Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedLine(Transform) Construct a transformed copy of this Line. Declaration public Line TransformedLine(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Line Trim(Polygon, out List<Line>) Trim a line with a polygon. Declaration public List<Line> Trim(Polygon polygon, out List<Line> outsideSegments) Parameters Type Name Description Polygon polygon The polygon to trim with. System.Collections.Generic.List < Line > outsideSegments A list of the segment(s) of the line outside of the supplied polygon. Returns Type Description System.Collections.Generic.List < Line > A list of the segment(s) of the line within the supplied polygon. TrimTo(Line, Boolean) Trim this line to the trimming curve. Declaration public Line TrimTo(Line line, bool flip = false) Parameters Type Name Description Line line The curve to which to trim. System.Boolean flip Should the trim direction be reversed? Returns Type Description Line A new line, or null if this line does not intersect the trimming line. Implements ICurve ITransformable<T> System.IEquatable<T>"
  },
  "api/Elements.Geometry.Matrix.html": {
    "href": "api/Elements.Geometry.Matrix.html",
    "title": "Class Matrix | Hypar Docs",
    "keywords": "Class Matrix A column-ordered 4x3 matrix. Inheritance System.Object Matrix Implements System.IEquatable < Matrix > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Matrix : IEquatable<Matrix> Constructors Matrix() Construct a 4X3 matrix. Declaration public Matrix() Matrix(Vector3, Vector3, Vector3, Vector3) Construct a matrix from axes. Declaration public Matrix(Vector3 xAxis, Vector3 yAxis, Vector3 zAxis, Vector3 translation) Parameters Type Name Description Vector3 xAxis The X axis. Vector3 yAxis The Y axis. Vector3 zAxis The Z axis. Vector3 translation The translation. Matrix(IList<Double>) Declaration public Matrix(IList<double> components) Parameters Type Name Description System.Collections.Generic.IList < System.Double > components Properties Components The components of the matrix. Declaration public IList<double> Components { get; set; } Property Value Type Description System.Collections.Generic.IList < System.Double > m11 m11 Declaration public double m11 { get; set; } Property Value Type Description System.Double m12 m12 Declaration public double m12 { get; set; } Property Value Type Description System.Double m13 m13 Declaration public double m13 { get; set; } Property Value Type Description System.Double m21 m21 Declaration public double m21 { get; set; } Property Value Type Description System.Double m22 m22 Declaration public double m22 { get; set; } Property Value Type Description System.Double m23 m23 Declaration public double m23 { get; set; } Property Value Type Description System.Double m31 m31 Declaration public double m31 { get; set; } Property Value Type Description System.Double m32 m32 Declaration public double m32 { get; set; } Property Value Type Description System.Double m33 m33 Declaration public double m33 { get; set; } Property Value Type Description System.Double Translation The translation component of the Matrix. Declaration public Vector3 Translation { get; } Property Value Type Description Vector3 tx tx Declaration public double tx { get; set; } Property Value Type Description System.Double ty ty Declaration public double ty { get; set; } Property Value Type Description System.Double tz tz Declaration public double tz { get; set; } Property Value Type Description System.Double XAxis The X axis of the Matrix. Declaration public Vector3 XAxis { get; } Property Value Type Description Vector3 YAxis The Y axis of the Matrix. Declaration public Vector3 YAxis { get; } Property Value Type Description Vector3 ZAxis The Z axis of the Matrix. Declaration public Vector3 ZAxis { get; } Property Value Type Description Vector3 Methods Determinant() Compute the determinant of the 3x3 portion of the matrix. Declaration public double Determinant() Returns Type Description System.Double Equals(Matrix) Is this matrix equal to other? Declaration public bool Equals(Matrix other) Parameters Type Name Description Matrix other The transform to test. Returns Type Description System.Boolean True if the two transforms are equal, otherwise false. Inverse() Compute the inverse of the matrix. Declaration public Matrix Inverse() Returns Type Description Matrix SetIdentity() Set the matrix to identity. Declaration public void SetIdentity() SetTranslation(Vector3) Set the translation of the matrix. Declaration public void SetTranslation(Vector3 v) Parameters Type Name Description Vector3 v The translation vector. SetupProject(Plane) Setup the matrix to project. Declaration public void SetupProject(Plane p) Parameters Type Name Description Plane p The plane on which to project. SetupReflect(Vector3) Setup the matrix to reflect about a plane with normal n. Declaration public void SetupReflect(Vector3 n) Parameters Type Name Description Vector3 n The normal of the reflection plane. SetupRotate(Vector3, Double) Setup the matrix to perform rotation. Declaration public void SetupRotate(Vector3 axis, double theta) Parameters Type Name Description Vector3 axis The axis of rotation. System.Double theta The angle of rotation in radians. SetupRotate(Int32, Double) Setup the matrix to rotate. Declaration public void SetupRotate(int axis, double theta) Parameters Type Name Description System.Int32 axis The axis of rotation. 1-x, 2-y, 3-z System.Double theta The angle of rotation in radians. SetupScale(Vector3) Setup the matrix to scale. Declaration public void SetupScale(Vector3 s) Parameters Type Name Description Vector3 s The scale value. SetupTranslation(Vector3) Setup the matrix to translate. Declaration public void SetupTranslation(Vector3 v) Parameters Type Name Description Vector3 v The translation. ToString() Return the string representation of the matrix. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Transpose() Transpose the matrix. Declaration public Matrix Transpose() Returns Type Description Matrix ZeroTranslation() Set the translation of the matrix to zero. Declaration public void ZeroTranslation() Operators Multiply(Matrix, Matrix) Multiply two matrices. Declaration public static Matrix operator *(Matrix a, Matrix b) Parameters Type Name Description Matrix a Matrix b Returns Type Description Matrix Multiply(Vector3, Matrix) Transform the specified vector. Declaration public static Vector3 operator *(Vector3 p, Matrix m) Parameters Type Name Description Vector3 p The vector to transform. Matrix m The transformation matrix. Returns Type Description Vector3 Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.Mesh.html": {
    "href": "api/Elements.Geometry.Mesh.html",
    "title": "Class Mesh | Hypar Docs",
    "keywords": "Class Mesh A triangulated mesh. Inheritance System.Object Mesh Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Mesh Constructors Mesh() Construct an empty mesh. Declaration public Mesh() Mesh(IList<Vertex>, IList<Triangle>) Declaration public Mesh(IList<Vertex> vertices, IList<Triangle> triangles) Parameters Type Name Description System.Collections.Generic.IList < Vertex > vertices System.Collections.Generic.IList < Triangle > triangles Properties Triangles The mesh' triangles. Declaration public IList<Triangle> Triangles { get; set; } Property Value Type Description System.Collections.Generic.IList < Triangle > Vertices The mesh' vertices. Declaration public IList<Vertex> Vertices { get; set; } Property Value Type Description System.Collections.Generic.IList < Vertex > Methods AddTriangle(Triangle) Add a triangle to the mesh. Declaration public Triangle AddTriangle(Triangle t) Parameters Type Name Description Triangle t The triangle to add. Returns Type Description Triangle AddTriangle(Vertex, Vertex, Vertex) Add a triangle to the mesh. Declaration public Triangle AddTriangle(Vertex a, Vertex b, Vertex c) Parameters Type Name Description Vertex a The first vertex. Vertex b The second vertex. Vertex c The third vertex. Returns Type Description Triangle AddVertex(Vector3, UV, Vector3, Color) Add a vertex to the mesh. Declaration public Vertex AddVertex(Vector3 position, UV uv = default(UV), Vector3 normal = default(Vector3), Color color = default(Color)) Parameters Type Name Description Vector3 position The position of the vertex. UV uv The texture coordinate of the vertex. Vector3 normal The vertex's normal. Color color The vertex's color. Returns Type Description Vertex The newly created vertex. AddVertex(Vertex) Add a vertex to the mesh. Declaration public Vertex AddVertex(Vertex v) Parameters Type Name Description Vertex v The vertex to add. Returns Type Description Vertex ComputeNormals() Compute the vertex normals by averaging the normals of the incident faces. Declaration public void ComputeNormals() FromSTL(String, Units.LengthUnit) Construct a mesh from an STL file. Declaration public static Mesh FromSTL(string stlPath, Units.LengthUnit unit = Units.LengthUnit.Millimeter) Parameters Type Name Description System.String stlPath The path to the STL file. Units.LengthUnit unit The length unit used in the file. Returns Type Description Mesh GetBuffers(out Byte[], out Byte[], out Byte[], out Byte[], out Byte[], out Double[], out Double[], out Double[], out Double[], out Single[], out Single[], out UInt16, out UInt16, out Double[], out Double[]) Get all buffers required for rendering. Declaration public void GetBuffers(out byte[] vertexBuffer, out byte[] indexBuffer, out byte[] normalBuffer, out byte[] colorBuffer, out byte[] uvBuffer, out double[] v_max, out double[] v_min, out double[] n_min, out double[] n_max, out float[] c_min, out float[] c_max, out ushort index_min, out ushort index_max, out double[] uv_min, out double[] uv_max) Parameters Type Name Description System.Byte [] vertexBuffer System.Byte [] indexBuffer System.Byte [] normalBuffer System.Byte [] colorBuffer System.Byte [] uvBuffer System.Double [] v_max System.Double [] v_min System.Double [] n_min System.Double [] n_max System.Single [] c_min System.Single [] c_max System.UInt16 index_min System.UInt16 index_max System.Double [] uv_min System.Double [] uv_max ToString() Get a string representation of the mesh. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Plane.html": {
    "href": "api/Elements.Geometry.Plane.html",
    "title": "Class Plane | Hypar Docs",
    "keywords": "Class Plane A plane. Inheritance System.Object Plane Implements System.IEquatable < Plane > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Plane : IEquatable<Plane> Constructors Plane(Vector3, Vector3) Declaration public Plane(Vector3 origin, Vector3 normal) Parameters Type Name Description Vector3 origin Vector3 normal Plane(Vector3, Vector3, Vector3) Construct a plane by three points. The plane is constructed as a->b * b->c. Declaration public Plane(Vector3 a, Vector3 b, Vector3 c) Parameters Type Name Description Vector3 a Vector3 b Vector3 c Plane(Vector3, IList<Vector3>) Construct a plane. Only the first three points of the points array will be used. Declaration public Plane(Vector3 origin, IList<Vector3> points) Parameters Type Name Description Vector3 origin The origin of the plane. System.Collections.Generic.IList < Vector3 > points An array of vectors to be used to determine the normal of the plane. Properties Normal The normal of the plane. Declaration public Vector3 Normal { get; set; } Property Value Type Description Vector3 Origin The origin of the plane. Declaration public Vector3 Origin { get; set; } Property Value Type Description Vector3 Methods ClosestPoint(Vector3) Find the closest point on this plane from a given sample point. Declaration public Vector3 ClosestPoint(Vector3 point) Parameters Type Name Description Vector3 point The sample point. Returns Type Description Vector3 The closest point to the sample point on this plane. Equals(Plane) Is this plane equal to the provided plane? Declaration public bool Equals(Plane other) Parameters Type Name Description Plane other The plane to test. Returns Type Description System.Boolean Returns true if the two planes are equal, otherwise false. SignedDistanceTo(Vector3) Find the signed distance from a sample point to a plane. If positive, the point is on the \"Normal\" side of the plane, otherwise it is on the opposite side. Declaration public double SignedDistanceTo(Vector3 point) Parameters Type Name Description Vector3 point The sample point. Returns Type Description System.Double The signed distance between this plane and the sample point. Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.Polygon.html": {
    "href": "api/Elements.Geometry.Polygon.html",
    "title": "Class Polygon | Hypar Docs",
    "keywords": "Class Polygon A closed planar polygon. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Polygon.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a polygon. var star = Polygon.Star(5, 3, 5); Inheritance System.Object Curve Polyline Polygon Implements ITransformable < Curve > ICurve System.IEquatable < Polyline > Inherited Members Polyline.Vertices Polyline.Start Polyline.End Polyline.PointAt(Double) Polyline.TransformAt(Double) Polyline.TransformedPolyline(Transform) Polyline.TransformSegment(Transform, Int32, Boolean, Boolean) Polyline.Bounds() Polyline.Plane() Polyline.CheckCoincidenceAndThrow(IList<Vector3>) Polyline.CreateMiterTransform(Int32, Vector3, Vector3) Polyline.OffsetOnSide(Double, Boolean) Polyline.Equals(Polyline) Polyline.SharedSegments(Polyline, Polyline, Boolean) Curve.MinimumChordLength Curve.ToPolyline(Int32) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Polygon : Polyline, ITransformable<Curve>, ICurve, IEquatable<Polyline> Constructors Polygon(IList<Vector3>) Declaration public Polygon(IList<Vector3> vertices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices Methods Area() Calculate the polygon's area. Declaration public double Area() Returns Type Description System.Double Centroid() Calculate the centroid of the polygon. Declaration public Vector3 Centroid() Returns Type Description Vector3 Circle(Double, Int32) Create a circle. Declaration [Obsolete(\"Please use Elements.Geometry.Circle.ToPolygon() instead.\")] public static Polygon Circle(double radius = 1, int divisions = 10) Parameters Type Name Description System.Double radius The radius of the circle. System.Int32 divisions The number of divisions of the circle. Returns Type Description Polygon A circle as a Polygon tessellated into the specified number of divisions. Contains(Polygon) Tests if the supplied Polygon is within this Polygon without coincident edges when compared on a shared plane. Declaration public bool Contains(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. Returns Type Description System.Boolean Returns true if every vertex of the supplied Polygon is within this Polygon when compared on a shared plane. Returns false if the supplied Polygon is not entirely within this Polygon, or if the supplied Polygon is null. Contains(Vector3) Tests if the supplied Vector3 is within this Polygon without coincidence with an edge when compared on a shared plane. Declaration public bool Contains(Vector3 vector) Parameters Type Name Description Vector3 vector The Vector3 to compare to this Polygon. Returns Type Description System.Boolean Returns true if the supplied Vector3 is within this Polygon when compared on a shared plane. Returns false if the Vector3 is outside this Polygon or if the supplied Vector3 is null. Contains(Vector3, out Containment) Tests if the supplied Vector3 is within this Polygon, using a 2D method. Declaration public bool Contains(Vector3 vector, out Containment containment) Parameters Type Name Description Vector3 vector The position to test. Containment containment Whether the point is inside, outside, at an edge, or at a vertex. Returns Type Description System.Boolean Returns true if the supplied Vector3 is within this polygon. Covers(Polygon) Tests if the supplied Polygon is within this Polygon with or without edge coincident vertices when compared on a shared plane. Declaration public bool Covers(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. Returns Type Description System.Boolean Returns true if every vertex of the supplied Polygon is within this Polygon or coincident with an edge when compared on a shared plane. Returns false if any vertex of the supplied Polygon is outside this Polygon, or if the supplied Polygon is null. Covers(Vector3) Tests if the supplied Vector3 is within this Polygon or coincident with an edge when compared on a shared plane. Declaration public bool Covers(Vector3 vector) Parameters Type Name Description Vector3 vector The Vector3 to compare to this Polygon. Returns Type Description System.Boolean Returns true if the supplied Vector3 is within this Polygon or coincident with an edge when compared on a shared plane. Returns false if the supplied Vector3 is outside this Polygon, or if the supplied Vector3 is null. Difference(Polygon, Double) Constructs the geometric difference between this Polygon and the supplied Polygon. Declaration public IList<Polygon> Difference(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The intersecting Polygon. System.Double tolerance An optional tolerance value. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the subtraction of the supplied Polygon from this Polygon. Returns null if the area of this Polygon is entirely subtracted. Returns a list containing a representation of the perimeter of this Polygon if the two Polygons do not intersect. Difference(IList<Polygon>, IList<Polygon>, Double) Constructs the geometric difference between two sets of polygons. Declaration public static IList<Polygon> Difference(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the subtraction of the second set of polygons from the first set. Difference(IList<Polygon>, Double) Constructs the geometric difference between this Polygon and the supplied Polygons. Declaration public IList<Polygon> Difference(IList<Polygon> difPolys, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > difPolys The list of intersecting Polygons. System.Double tolerance An optional tolerance value. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the subtraction of the supplied Polygons from this Polygon. Returns null if the area of this Polygon is entirely subtracted. Returns a list containing a representation of the perimeter of this Polygon if the two Polygons do not intersect. Disjoint(Polygon) Tests if the supplied Polygon and this Polygon are coincident in any way when compared on a shared plane. Declaration public bool Disjoint(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. Returns Type Description System.Boolean Returns true if the supplied Polygon do not intersect or touch this Polygon when compared on a shared plane or if the supplied Polygon is null. Disjoint(Vector3) Tests if the supplied Vector3 is outside this Polygon when compared on a shared plane. Declaration public bool Disjoint(Vector3 vector) Parameters Type Name Description Vector3 vector The Vector3 to compare to this Polygon. Returns Type Description System.Boolean Returns true if the supplied Vector3 is outside this Polygon when compared on a shared plane or if the supplied Vector3 is null. Equals(Object) Is this polygon equal to the provided polygon? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) Fillet(Double) Fillet all corners on this polygon. Declaration public Contour Fillet(double radius) Parameters Type Name Description System.Double radius The fillet radius. Returns Type Description Contour A contour containing trimmed edge segments and fillets. Frames(Double, Double) Get the transforms used to transform a Profile extruded along this Polyline. Declaration public override Transform[] Frames(double startSetback, double endSetback) Parameters Type Name Description System.Double startSetback System.Double endSetback Returns Type Description Transform [] Overrides Polyline.Frames(Double, Double) GetHashCode() Get the hash code for the polygon. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Intersection(Polygon, Double) Constructs the Polygon intersections between this Polygon and the supplied Polygon. Declaration public IList<Polygon> Intersection(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The intersecting Polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the intersection of this Polygon with the supplied Polygon. Returns null if the two Polygons do not intersect. Intersection(IList<Polygon>, IList<Polygon>, Double) Constructs the Polygon intersections between two sets of polygons. Declaration public static IList<Polygon> Intersection(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the intersection of the first set of Polygons with the second set. Returns null if the Polygons do not intersect. Intersects(Polygon) Tests if the supplied Polygon shares one or more areas with this Polygon when compared on a shared plane. Declaration public bool Intersects(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare with this Polygon. Returns Type Description System.Boolean Returns true if the supplied Polygon shares one or more areas with this Polygon when compared on a shared plane. Returns false if the supplied Polygon does not share an area with this Polygon or if the supplied Polygon is null. IsAlmostEqualTo(Polygon, Double, Boolean) Test if this polygon has the same vertex count and shape as another, within tolerance. Declaration public bool IsAlmostEqualTo(Polygon other, double tolerance = 1E-05, bool ignoreWinding = false) Parameters Type Name Description Polygon other The other polygon. System.Double tolerance The optional tolerance value to use. If not supplied, the global tolerance will be used. System.Boolean ignoreWinding If true, polygons with opposite winding will be considered as equal. Returns Type Description System.Boolean IsClockWise() Calculates whether this polygon is configured clockwise. Declaration public bool IsClockWise() Returns Type Description System.Boolean True if this polygon is oriented clockwise. L(Double, Double, Double) Create an L. Declaration public static Polygon L(double width, double length, double thickness) Parameters Type Name Description System.Double width The width of the L. System.Double length The length of the L. System.Double thickness The thickness of the L. Returns Type Description Polygon Length() Calculate the length of the polygon. Declaration public override double Length() Returns Type Description System.Double Overrides Polyline.Length() Ngon(Int32, Double) Create an ngon. Declaration public static Polygon Ngon(int sides, double radius = 0.5) Parameters Type Name Description System.Int32 sides The number of side of the Polygon. System.Double radius The radius of the circle in which the Ngon is inscribed. Returns Type Description Polygon A Polygon with the specified number of sides. Normal() The normal of this polygon, according to Newell's Method. Declaration public Vector3 Normal() Returns Type Description Vector3 The unitized sum of the cross products of each pair of edges. NormalsAtVertices() Get the normal of each vertex on the polygon. Declaration protected override Vector3[] NormalsAtVertices() Returns Type Description Vector3 [] A collection of unit vectors, each corresponding to a single vertex. Overrides Polyline.NormalsAtVertices() Remarks All normals will be the same since polygons are coplanar by definition. Offset(Double, EndType, Double) Offset this polygon by the specified amount. Declaration public override Polygon[] Offset(double offset, EndType endType = EndType.ClosedPolygon, double tolerance = 1E-05) Parameters Type Name Description System.Double offset The amount to offset. EndType endType The type of closure used for the offset polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon [] A new Polygon offset by offset. Overrides Polyline.Offset(Double, EndType, Double) PointAtInternal(Double, out Int32) Get a point on the polygon at parameter u. Declaration protected override Vector3 PointAtInternal(double u, out int segmentIndex) Parameters Type Name Description System.Double u A value between 0.0 and 1.0. System.Int32 segmentIndex The index of the segment containing parameter u. Returns Type Description Vector3 Returns a Vector3 indicating a point along the Polygon length from its start vertex. Overrides Polyline.PointAtInternal(Double, out Int32) Project(Plane) Project the specified vector onto the plane. Declaration public Polygon Project(Plane p) Parameters Type Name Description Plane p Returns Type Description Polygon ProjectAlong(Vector3, Plane) Project this Polygon onto a Plane along a vector. Declaration public Polygon ProjectAlong(Vector3 direction, Plane p) Parameters Type Name Description Vector3 direction The projection vector. Plane p The Plane onto which to project the Polygon. Returns Type Description Polygon A Polygon projected onto the Plane. Rectangle(Vector3, Vector3) Create a rectangle. Declaration public static Polygon Rectangle(Vector3 min, Vector3 max) Parameters Type Name Description Vector3 min The minimum coordinate. Vector3 max The maximum coordinate. Returns Type Description Polygon A rectangular Polygon with its lower left corner at min and its upper right corner at max. Rectangle(Double, Double) Create a rectangle. Declaration public static Polygon Rectangle(double width, double height) Parameters Type Name Description System.Double width The width of the rectangle. System.Double height The height of the rectangle. Returns Type Description Polygon A rectangular Polygon centered around origin. Reversed() Reverse the direction of a polygon. Declaration public Polygon Reversed() Returns Type Description Polygon Returns a new Polygon whose vertices are reversed. Segments() Get a collection a lines representing each segment of this polyline. Declaration public override Line[] Segments() Returns Type Description Line [] A collection of Lines. Overrides Polyline.Segments() Star(Double, Double, Int32) Create a star. Declaration public static Polygon Star(double outerRadius, double innerRadius, int points) Parameters Type Name Description System.Double outerRadius The outer radius. System.Double innerRadius The inner radius. System.Int32 points The number of points. Returns Type Description Polygon ToString() The string representation of the Polygon. Declaration public override string ToString() Returns Type Description System.String A string containing the string representations of this Polygon's vertices. Overrides Polyline.ToString() Touches(Polygon, Double) Tests if at least one point of an edge of the supplied Polygon is shared with an edge of this Polygon without the Polygons interesecting when compared on a shared plane. Declaration public bool Touches(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Boolean Returns true if the supplied Polygon shares at least one edge point with this Polygon without the Polygons intersecting when compared on a shared plane. Returns false if the Polygons intersect, are disjoint, or if the supplied Polygon is null. Touches(Vector3, Double) Tests if the supplied Vector3 is coincident with an edge of this Polygon when compared on a shared plane. Declaration public bool Touches(Vector3 vector, double tolerance = 1E-05) Parameters Type Name Description Vector3 vector The Vector3 to compare to this Polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Boolean Returns true if the supplied Vector3 coincides with an edge of this Polygon when compared on a shared plane. Returns false if the supplied Vector3 is not coincident with an edge of this Polygon, or if the supplied Vector3 is null. Transform(Transform) Transform this polygon in place. Declaration public void Transform(Transform t) Parameters Type Name Description Transform t The transform. Transformed(Transform) Construct a transformed copy of this Curve. Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Polyline.Transformed(Transform) TransformedPolygon(Transform) Construct a transformed copy of this Polygon. Declaration public Polygon TransformedPolygon(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Polygon TransformSegment(Transform, Int32) Transform a specified segment of this polygon in place. Declaration public void TransformSegment(Transform t, int i) Parameters Type Name Description Transform t The transform. If it is not within the polygon plane, then an exception will be thrown. System.Int32 i The segment to transform. If it does not exist, then no work will be done. Union(Polygon, Double) Constructs the geometric union between this Polygon and the supplied Polygon. Declaration public Polygon Union(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The Polygon to be combined with this Polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon Returns a single Polygon from a successful union. Returns null if a union cannot be performed on the two Polygons. Union(IList<Polygon>, IList<Polygon>, Double) Constructs the geometric union of two sets of polygons. Declaration [Obsolete(\"Please use UnionAll, which takes a single list of polygons.\")] public static IList<Polygon> Union(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the union of both sets of polygons. Union(IList<Polygon>, Double) Constructs the geometric union between this Polygon and the supplied list of Polygons. Declaration public Polygon Union(IList<Polygon> polygons, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The list of Polygons to be combined with this Polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon Returns a single Polygon from a successful union. Returns null if a union cannot be performed on the complete list of Polygons. UnionAll(IList<Polygon>, Double) Constructs the geometric union of a set of polygons. Declaration public static IList<Polygon> UnionAll(IList<Polygon> polygons, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The polygons to union System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the union of all polygons. XOR(Polygon, Double) Returns Polygons representing the symmetric difference between this Polygon and the supplied Polygon. Declaration public IList<Polygon> XOR(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The intersecting polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the symmetric difference of this Polygon and the supplied Polygon. Returns a representation of this Polygon and the supplied Polygon if the Polygons do not intersect. XOR(IList<Polygon>, IList<Polygon>, Double) Returns Polygons representing the symmetric difference between two sets of polygons. Declaration public static IList<Polygon> XOR(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the symmetric difference of these two sets of polygons. Returns a representation of all polygons if they do not intersect. Operators Implicit(Polygon to Element) Implicitly convert a Polygon to a ModelCurve Element. Declaration public static implicit operator Element(Polygon c) Parameters Type Name Description Polygon c The curve to convert. Returns Type Description Element Implicit(Polygon to Profile) Implicitly convert a polygon to a profile. Declaration public static implicit operator Profile(Polygon p) Parameters Type Name Description Polygon p The polygon to convert. Returns Type Description Profile Implements ITransformable<T> ICurve System.IEquatable<T>"
  },
  "api/Elements.Geometry.Polyline.html": {
    "href": "api/Elements.Geometry.Polyline.html",
    "title": "Class Polyline | Hypar Docs",
    "keywords": "Class Polyline A continuous set of lines. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Polyline.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(); var b = new Vector3(10, 10); var c = new Vector3(20, 5); var d = new Vector3(25, 10); var pline = new Polyline(new[] { a, b, c, d }); var offset = pline.Offset(1, EndType.Square); Inheritance System.Object Curve Polyline Polygon Implements ITransformable < Curve > ICurve System.IEquatable < Polyline > Inherited Members Curve.MinimumChordLength Curve.ToPolyline(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Polyline : Curve, ITransformable<Curve>, ICurve, IEquatable<Polyline> Constructors Polyline(IList<Vector3>) Declaration public Polyline(IList<Vector3> vertices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices Properties End The end of the polyline. Declaration public Vector3 End { get; } Property Value Type Description Vector3 Start The start of the polyline. Declaration public Vector3 Start { get; } Property Value Type Description Vector3 Vertices The vertices of the polygon. Declaration public IList<Vector3> Vertices { get; set; } Property Value Type Description System.Collections.Generic.IList < Vector3 > Methods Bounds() Get the bounding box for this curve. Declaration public override BBox3 Bounds() Returns Type Description BBox3 Overrides Curve.Bounds() CheckCoincidenceAndThrow(IList<Vector3>) Check for coincident vertices in the supplied vertex collection. Declaration protected void CheckCoincidenceAndThrow(IList<Vector3> vertices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices CreateMiterTransform(Int32, Vector3, Vector3) Generates a transform that expresses the plane of a miter join at a point on the curve. Declaration protected Transform CreateMiterTransform(int i, Vector3 a, Vector3 up) Parameters Type Name Description System.Int32 i Vector3 a Vector3 up Returns Type Description Transform Equals(Polyline) Does this polyline equal the provided polyline? Declaration public bool Equals(Polyline other) Parameters Type Name Description Polyline other Returns Type Description System.Boolean Frames(Double, Double) Get the transforms used to transform a Profile extruded along this Polyline. Declaration public override Transform[] Frames(double startSetback, double endSetback) Parameters Type Name Description System.Double startSetback System.Double endSetback Returns Type Description Transform [] Overrides Curve.Frames(Double, Double) Length() Calculate the length of the polygon. Declaration public override double Length() Returns Type Description System.Double Overrides Curve.Length() NormalsAtVertices() Get the normal of each vertex on the polyline. Declaration protected virtual Vector3[] NormalsAtVertices() Returns Type Description Vector3 [] A collection of unit vectors, each corresponding to a single vertex. Offset(Double, EndType, Double) Offset this polyline by the specified amount. Declaration public virtual Polygon[] Offset(double offset, EndType endType, double tolerance = 1E-05) Parameters Type Name Description System.Double offset The amount to offset. EndType endType The closure type to use on the offset polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon [] A new closed Polygon offset in all directions by offset from the polyline. OffsetOnSide(Double, Boolean) Offset this polyline by the specified amount, only on one side. Declaration public Polygon[] OffsetOnSide(double offset, bool flip) Parameters Type Name Description System.Double offset The amount to offset. System.Boolean flip Offset on the opposite of the default side. The default is to draw on the +X side of a polyline that goes up the +Y axis. Returns Type Description Polygon [] An array of polygons that are extruded from each segment of the polyline. Remarks This blunts sharp corners to keep widths close to the target. Plane() Compute the Plane defined by the first three non-collinear vertices of the Polygon. Declaration public Plane Plane() Returns Type Description Plane A Plane. PointAt(Double) Get a point on the polygon at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u A value between 0.0 and 1.0. Returns Type Description Vector3 Returns a Vector3 indicating a point along the Polygon length from its start vertex. Overrides Curve.PointAt(Double) PointAtInternal(Double, out Int32) Get a point on the polygon at parameter u. Declaration protected virtual Vector3 PointAtInternal(double u, out int segmentIndex) Parameters Type Name Description System.Double u A value between 0.0 and 1.0. System.Int32 segmentIndex The index of the segment containing parameter u. Returns Type Description Vector3 Returns a Vector3 indicating a point along the Polygon length from its start vertex. Reversed() Reverse the direction of a polyline. Declaration public Polyline Reversed() Returns Type Description Polyline Returns a new polyline with opposite winding. Segments() Get a collection a lines representing each segment of this polyline. Declaration public virtual Line[] Segments() Returns Type Description Line [] A collection of Lines. SharedSegments(Polyline, Polyline, Boolean) Identify any shared segments between two polylines. Declaration public static List<(int indexOnA, int indexOnB)> SharedSegments(Polyline a, Polyline b, bool isClosed = false) Parameters Type Name Description Polyline a The first polyline to compare. Polyline b The second polyline to compare. System.Boolean isClosed Flag as closed to include segment between first and last vertex. Returns Type Description System.Collections.Generic.List < System.ValueTuple < System.Int32 , System.Int32 >> Returns a list of tuples of indices for the segments that match in each polyline. ToString() Get a string representation of this polyline. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() TransformAt(Double) Get the Transform at the specified parameter along the Polygon. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter on the Polygon between 0.0 and 1.0. Returns Type Description Transform A Transform with its Z axis aligned trangent to the Polygon. Overrides Curve.TransformAt(Double) Transformed(Transform) Construct a transformed copy of this Curve. Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedPolyline(Transform) Construct a transformed copy of this Polyline. Declaration public Polyline TransformedPolyline(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Polyline TransformSegment(Transform, Int32, Boolean, Boolean) Transform a specified segment of this polyline in place. Declaration public void TransformSegment(Transform t, int i, bool isClosed = false, bool isPlanar = false) Parameters Type Name Description Transform t The transform. If it is not within the polygon plane, then an exception will be thrown. System.Int32 i The segment to transform. If it does not exist, then no work will be done. System.Boolean isClosed If set to true, the segment between the start end end point will be considered a valid target. System.Boolean isPlanar If set to true, an exception will be thrown if the resultant shape is no longer planar. Implements ITransformable<T> ICurve System.IEquatable<T>"
  },
  "api/Elements.Geometry.Profile.html": {
    "href": "api/Elements.Geometry.Profile.html",
    "title": "Class Profile | Hypar Docs",
    "keywords": "Class Profile A profile comprised of an external boundary and one or several holes. Inheritance System.Object Element Profile HSSPipeProfile WideFlangeProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Profile : Element, INotifyPropertyChanged, IEquatable<Profile> Constructors Profile(Polygon) Construct a profile. Declaration public Profile(Polygon perimeter) Parameters Type Name Description Polygon perimeter The perimeter of the profile. Profile(Polygon, Polygon) Construct a profile. Declaration public Profile(Polygon perimeter, Polygon void) Parameters Type Name Description Polygon perimeter The perimeter of the profile. Polygon void A void in the profile. Profile(Polygon, IList<Polygon>, Guid, String) Declaration public Profile(Polygon perimeter, IList<Polygon> voids, Guid id, string name) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Profile(IList<Polygon>) Construct a profile from a collection of polygons. If the collection contains more than one polygon, the first polygon will be used as the perimeter and any remaining polygons will be used as voids. Declaration public Profile(IList<Polygon> polygons) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The polygons bounding this profile. Profile(String) Default constructor for profile. Declaration protected Profile(string name) Parameters Type Name Description System.String name Properties Perimeter The perimeter of the profile. Declaration public Polygon Perimeter { get; set; } Property Value Type Description Polygon Voids A collection of Polygons representing voids in the profile. Declaration public IList<Polygon> Voids { get; set; } Property Value Type Description System.Collections.Generic.IList < Polygon > Methods Area() The area of the profile. Declaration public double Area() Returns Type Description System.Double Contains(Vector3) Tests if a point is contained within this profile. Returns false for points that are outside of the profile, within voids, or coincident at edges or vertices. Declaration public bool Contains(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Boolean Contains(Vector3, out Containment) Tests if a point is contained within this profile. Returns false for points that are outside of the profile (or within voids). Declaration public bool Contains(Vector3 point, out Containment containment) Parameters Type Name Description Vector3 point The position to test. Containment containment Whether the point is inside, outside, at an edge, or at a vertex. Returns Type Description System.Boolean True if the point is within the profile. Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Perform a difference operation on two sets of profiles. Declaration public static List<Profile> Difference(IEnumerable<Profile> firstSet, IEnumerable<Profile> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > firstSet The profiles to subtract from. System.Collections.Generic.IEnumerable < Profile > secondSet The profiles to subtract with. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > A new list of profiles comprising the first set minus the second set. Equals(Profile) Is this profile equal to the provided profile? Declaration public bool Equals(Profile other) Parameters Type Name Description Profile other The other profile. Returns Type Description System.Boolean Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Constructs the intersections between two sets of profiles. Declaration public static List<Profile> Intersection(IEnumerable<Profile> firstSet, IEnumerable<Profile> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > firstSet The first set of profiles to intersect with. System.Collections.Generic.IEnumerable < Profile > secondSet The second set of profiles to intersect with. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > A new list of profiles comprising the overlap between the first set and the second set. OrientVoids() Ensure that voids run in an opposite winding direction to the perimeter of the profile. Be sure to call this if you modify the Profile's Voids array directly. Declaration public void OrientVoids() Reversed() Get a new profile which is the reverse of this profile. Declaration public Profile Reversed() Returns Type Description Profile Scale(Double) Return a new profile that is this profile scaled about the origin by the desired amount. Declaration public Profile Scale(double amount) Parameters Type Name Description System.Double amount Returns Type Description Profile Transform(Transform) Transform this profile in place. Declaration public void Transform(Transform t) Parameters Type Name Description Transform t The transform. Union(Profile, Double) Perform a union operation, returning a new profile that is the union of the current profile with the other profile The profile with which to create a union. An optional tolerance. Declaration public Profile Union(Profile profile, double tolerance = 1E-05) Parameters Type Name Description Profile profile System.Double tolerance Returns Type Description Profile UnionAll(IEnumerable<Profile>, Double) Perform a union operation on a set of multiple profiles. Declaration public static List<Profile> UnionAll(IEnumerable<Profile> profiles, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > profiles The profiles with which to create a union. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > A new list of profiles comprising the union of all input profiles. Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T>"
  },
  "api/Elements.Geometry.ProfileExtensions.html": {
    "href": "api/Elements.Geometry.ProfileExtensions.html",
    "title": "Class ProfileExtensions | Hypar Docs",
    "keywords": "Class ProfileExtensions Profile extension methods. Inheritance System.Object ProfileExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class ProfileExtensions"
  },
  "api/Elements.Geometry.Profiles.HorizontalAlignment.html": {
    "href": "api/Elements.Geometry.Profiles.HorizontalAlignment.html",
    "title": "Enum HorizontalAlignment | Hypar Docs",
    "keywords": "Enum HorizontalAlignment The horizontal alignment of a profile. Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum HorizontalAlignment Fields Name Description Center Align the profile along its center. Left Align the profile along its left edge. Right Align the profile along its right edge."
  },
  "api/Elements.Geometry.Profiles.HSSPipeProfile.html": {
    "href": "api/Elements.Geometry.Profiles.HSSPipeProfile.html",
    "title": "Class HSSPipeProfile | Hypar Docs",
    "keywords": "Class HSSPipeProfile Inheritance System.Object Element Profile HSSPipeProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Profile.Perimeter Profile.Voids Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class HSSPipeProfile : Profile, INotifyPropertyChanged, IEquatable<Profile> Constructors HSSPipeProfile(String, Guid, Double, Double, Double) Declaration public HSSPipeProfile(string name, Guid id, double outerDiam, double innerDiam, double t) Parameters Type Name Description System.String name System.Guid id System.Double outerDiam System.Double innerDiam System.Double t Properties A Declaration public double A { get; } Property Value Type Description System.Double I Declaration public double I { get; } Property Value Type Description System.Double InnerDiam Declaration public double InnerDiam { get; } Property Value Type Description System.Double J Declaration public double J { get; } Property Value Type Description System.Double OuterDiam Declaration public double OuterDiam { get; } Property Value Type Description System.Double r Declaration public double r { get; } Property Value Type Description System.Double S Declaration public double S { get; } Property Value Type Description System.Double t Declaration public double t { get; } Property Value Type Description System.Double wt Declaration public double wt { get; } Property Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T>"
  },
  "api/Elements.Geometry.Profiles.HSSPipeProfileServer.html": {
    "href": "api/Elements.Geometry.Profiles.HSSPipeProfileServer.html",
    "title": "Class HSSPipeProfileServer | Hypar Docs",
    "keywords": "Class HSSPipeProfileServer A singleton class which serves every HSS pipe section as defined by AISC. Inheritance System.Object ProfileServer < HSSPipeProfileType > HSSPipeProfileServer Inherited Members ProfileServer<HSSPipeProfileType>.InchesToMeters ProfileServer<HSSPipeProfileType>._profiles ProfileServer<HSSPipeProfileType>.GetProfileByName(String) ProfileServer<HSSPipeProfileType>.GetProfileByType(HSSPipeProfileType) ProfileServer<HSSPipeProfileType>.AllProfiles() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public sealed class HSSPipeProfileServer : ProfileServer<HSSPipeProfileType> Properties Instance The HSSPipeProfileServer singleton. Declaration public static HSSPipeProfileServer Instance { get; } Property Value Type Description HSSPipeProfileServer"
  },
  "api/Elements.Geometry.Profiles.HSSPipeProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.HSSPipeProfileType.html",
    "title": "Enum HSSPipeProfileType | Hypar Docs",
    "keywords": "Enum HSSPipeProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum HSSPipeProfileType Fields Name Description HSS1_660x0_140 HSS1_900x0_145 HSS10_000x0_188 HSS10_000x0_250 HSS10_000x0_312 HSS10_000x0_375 HSS10_000x0_500 HSS10_000x0_625 HSS10_750x0_250 HSS10_750x0_500 HSS11_250x0_188 HSS11_250x0_250 HSS11_250x0_312 HSS11_250x0_375 HSS11_250x0_500 HSS11_250x0_625 HSS12_500x0_188 HSS12_500x0_250 HSS12_500x0_312 HSS12_500x0_375 HSS12_500x0_500 HSS12_500x0_625 HSS12_750x0_250 HSS12_750x0_375 HSS12_750x0_500 HSS14_000x0_312 HSS14_000x0_375 HSS14_000x0_500 HSS16_000x0_312 HSS16_000x0_375 HSS16_000x0_438 HSS16_000x0_500 HSS18_000x0_375 HSS18_000x0_500 HSS2_375x0_125 HSS2_375x0_154 HSS2_375x0_188 HSS2_375x0_218 HSS2_375x0_250 HSS2_500x0_125 HSS2_500x0_188 HSS2_500x0_250 HSS2_875x0_125 HSS2_875x0_188 HSS2_875x0_203 HSS2_875x0_250 HSS20_000x0_375 HSS20_000x0_500 HSS3_000x0_120 HSS3_000x0_134 HSS3_000x0_152 HSS3_000x0_188 HSS3_000x0_203 HSS3_000x0_216 HSS3_000x0_250 HSS3_000x0_300 HSS3_500x0_125 HSS3_500x0_188 HSS3_500x0_203 HSS3_500x0_216 HSS3_500x0_250 HSS3_500x0_300 HSS3_500x0_313 HSS4_000x0_125 HSS4_000x0_188 HSS4_000x0_220 HSS4_000x0_226 HSS4_000x0_237 HSS4_000x0_250 HSS4_000x0_313 HSS4_000x0_337 HSS4_500x0_125 HSS4_500x0_188 HSS4_500x0_237 HSS4_500x0_337 HSS5_000x0_125 HSS5_000x0_188 HSS5_000x0_250 HSS5_000x0_258 HSS5_000x0_312 HSS5_000x0_375 HSS5_000x0_500 HSS5_500x0_258 HSS5_500x0_375 HSS5_500x0_500 HSS5_563x0_134 HSS5_563x0_188 HSS5_563x0_258 HSS5_563x0_375 HSS6_000x0_125 HSS6_000x0_188 HSS6_000x0_250 HSS6_000x0_280 HSS6_000x0_312 HSS6_000x0_375 HSS6_000x0_500 HSS6_125x0_188 HSS6_125x0_250 HSS6_125x0_312 HSS6_125x0_375 HSS6_125x0_500 HSS6_625x0_125 HSS6_625x0_188 HSS6_625x0_250 HSS6_625x0_280 HSS6_625x0_312 HSS6_625x0_375 HSS6_625x0_432 HSS6_625x0_500 HSS6_875x0_188 HSS6_875x0_250 HSS6_875x0_312 HSS6_875x0_375 HSS6_875x0_500 HSS7_000x0_125 HSS7_000x0_188 HSS7_000x0_250 HSS7_000x0_312 HSS7_000x0_375 HSS7_000x0_500 HSS7_500x0_188 HSS7_500x0_250 HSS7_500x0_312 HSS7_500x0_375 HSS7_500x0_500 HSS7_625x0_125 HSS8_625x0_188 HSS8_625x0_250 HSS8_625x0_322 HSS8_625x0_375 HSS8_625x0_500 HSS8_750x0_188 HSS8_750x0_250 HSS8_750x0_312 HSS8_750x0_375 HSS8_750x0_500 HSS9_625x0_188 HSS9_625x0_250 HSS9_625x0_312 HSS9_625x0_375 HSS9_625x0_500"
  },
  "api/Elements.Geometry.Profiles.html": {
    "href": "api/Elements.Geometry.Profiles.html",
    "title": "Namespace Elements.Geometry.Profiles | Hypar Docs",
    "keywords": "Namespace Elements.Geometry.Profiles Classes HSSPipeProfile HSSPipeProfileServer A singleton class which serves every HSS pipe section as defined by AISC. ProfileServer<T> Base class for all types which serve profiles. WideFlangeProfile WideFlangeProfileServer A singleton class which serves every Wide Flange section as defined by AISC. Enums HorizontalAlignment The horizontal alignment of a profile. HSSPipeProfileType VerticalAlignment The vertical alignment of a profile. WideFlangeProfileType"
  },
  "api/Elements.Geometry.Profiles.ProfileServer-1.html": {
    "href": "api/Elements.Geometry.Profiles.ProfileServer-1.html",
    "title": "Class ProfileServer<T> | Hypar Docs",
    "keywords": "Class ProfileServer<T> Base class for all types which serve profiles. Inheritance System.Object ProfileServer<T> HSSPipeProfileServer WideFlangeProfileServer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public abstract class ProfileServer<T> where T : struct Type Parameters Name Description T Fields _profiles The map of Profiles. Declaration protected Dictionary<T, Profile> _profiles Field Value Type Description System.Collections.Generic.Dictionary <T, Profile > InchesToMeters A conversion factor from inches to meters. Declaration protected const double InchesToMeters = 0.0254 Field Value Type Description System.Double Methods AllProfiles() Get all Profiles available in the WideFlangeProfileServer. Declaration public IEnumerable<Profile> AllProfiles() Returns Type Description System.Collections.Generic.IEnumerable < Profile > GetProfileByName(String) Get a profile by name from the server. Declaration [Obsolete(\"GetProfileByName will no longer be supported. Use GetProfileByType instead.\")] public Profile GetProfileByName(string name) Parameters Type Name Description System.String name Returns Type Description Profile A profile. Throws an exception if a profile with the specified name cannot be found. GetProfileByType(T) Get a profile by type enumeration from the server. Declaration public Profile GetProfileByType(T type) Parameters Type Name Description T type The enumerated type of the profile. Returns Type Description Profile A profile. Throws an exception if a profile with the specified name cannot be found."
  },
  "api/Elements.Geometry.Profiles.VerticalAlignment.html": {
    "href": "api/Elements.Geometry.Profiles.VerticalAlignment.html",
    "title": "Enum VerticalAlignment | Hypar Docs",
    "keywords": "Enum VerticalAlignment The vertical alignment of a profile. Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum VerticalAlignment Fields Name Description Bottom Align the profile along its bottom. Center Align the profile along its center. Top Align the profile along its top."
  },
  "api/Elements.Geometry.Profiles.WideFlangeProfile.html": {
    "href": "api/Elements.Geometry.Profiles.WideFlangeProfile.html",
    "title": "Class WideFlangeProfile | Hypar Docs",
    "keywords": "Class WideFlangeProfile Inheritance System.Object Element Profile WideFlangeProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Profile.Perimeter Profile.Voids Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class WideFlangeProfile : Profile, INotifyPropertyChanged, IEquatable<Profile> Constructors WideFlangeProfile(String) Declaration public WideFlangeProfile(string name) Parameters Type Name Description System.String name WideFlangeProfile(String, Guid, Double, Double, Double, Double, VerticalAlignment, HorizontalAlignment, Double, Double) Declaration public WideFlangeProfile(string name, Guid id, double bf = 0.1, double d = 0.05, double tf = 0.005, double tw = 0.005, VerticalAlignment verticalAlignment = VerticalAlignment.Center, HorizontalAlignment horizontalAlignment = HorizontalAlignment.Center, double verticalOffset = 0, double horizontalOffset = 0) Parameters Type Name Description System.String name System.Guid id System.Double bf System.Double d System.Double tf System.Double tw VerticalAlignment verticalAlignment HorizontalAlignment horizontalAlignment System.Double verticalOffset System.Double horizontalOffset Properties A Declaration public double A { get; } Property Value Type Description System.Double bf Declaration public double bf { get; } Property Value Type Description System.Double Cw Declaration public double Cw { get; } Property Value Type Description System.Double d Declaration public double d { get; } Property Value Type Description System.Double dAf Declaration public double dAf { get; } Property Value Type Description System.Double gage Declaration public string gage { get; } Property Value Type Description System.String Ix Declaration public double Ix { get; } Property Value Type Description System.Double Iy Declaration public double Iy { get; } Property Value Type Description System.Double J Declaration public double J { get; } Property Value Type Description System.Double k Declaration public double k { get; } Property Value Type Description System.Double k1 Declaration public double k1 { get; } Property Value Type Description System.Double Qf Declaration public double Qf { get; } Property Value Type Description System.Double Qw Declaration public double Qw { get; } Property Value Type Description System.Double rt Declaration public double rt { get; } Property Value Type Description System.Double rx Declaration public double rx { get; } Property Value Type Description System.Double ry Declaration public double ry { get; } Property Value Type Description System.Double Sw Declaration public double Sw { get; } Property Value Type Description System.Double Sx Declaration public double Sx { get; } Property Value Type Description System.Double Sy Declaration public double Sy { get; } Property Value Type Description System.Double T Declaration public string T { get; } Property Value Type Description System.String tf Declaration public double tf { get; } Property Value Type Description System.Double tw Declaration public double tw { get; } Property Value Type Description System.Double Wno Declaration public double Wno { get; } Property Value Type Description System.Double Zx Declaration public double Zx { get; } Property Value Type Description System.Double Zy Declaration public double Zy { get; } Property Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T>"
  },
  "api/Elements.Geometry.Profiles.WideFlangeProfileServer.html": {
    "href": "api/Elements.Geometry.Profiles.WideFlangeProfileServer.html",
    "title": "Class WideFlangeProfileServer | Hypar Docs",
    "keywords": "Class WideFlangeProfileServer A singleton class which serves every Wide Flange section as defined by AISC. Inheritance System.Object ProfileServer < WideFlangeProfileType > WideFlangeProfileServer Inherited Members ProfileServer<WideFlangeProfileType>.InchesToMeters ProfileServer<WideFlangeProfileType>._profiles ProfileServer<WideFlangeProfileType>.GetProfileByName(String) ProfileServer<WideFlangeProfileType>.GetProfileByType(WideFlangeProfileType) ProfileServer<WideFlangeProfileType>.AllProfiles() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public sealed class WideFlangeProfileServer : ProfileServer<WideFlangeProfileType> Properties Instance The WideFlangeProfileServer singleton. Declaration public static WideFlangeProfileServer Instance { get; } Property Value Type Description WideFlangeProfileServer"
  },
  "api/Elements.Geometry.Profiles.WideFlangeProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.WideFlangeProfileType.html",
    "title": "Enum WideFlangeProfileType | Hypar Docs",
    "keywords": "Enum WideFlangeProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum WideFlangeProfileType Fields Name Description W10x100 W10x112 W10x12 W10x15 W10x17 W10x19 W10x22 W10x26 W10x30 W10x33 W10x39 W10x45 W10x49 W10x54 W10x60 W10x68 W10x77 W10x88 W12x106 W12x120 W12x136 W12x14 W12x152 W12x16 W12x170 W12x19 W12x190 W12x210 W12x22 W12x230 W12x252 W12x26 W12x279 W12x30 W12x305 W12x336 W12x35 W12x40 W12x45 W12x50 W12x53 W12x58 W12x65 W12x72 W12x79 W12x87 W12x96 W14x109 W14x120 W14x132 W14x145 W14x159 W14x176 W14x193 W14x211 W14x22 W14x233 W14x257 W14x26 W14x283 W14x30 W14x311 W14x34 W14x342 W14x370 W14x38 W14x398 W14x426 W14x43 W14x455 W14x48 W14x500 W14x53 W14x550 W14x605 W14x61 W14x665 W14x68 W14x730 W14x74 W14x808 W14x82 W14x90 W14x99 W16x100 W16x26 W16x31 W16x36 W16x40 W16x45 W16x50 W16x57 W16x67 W16x77 W16x89 W18x106 W18x119 W18x130 W18x143 W18x158 W18x175 W18x192 W18x211 W18x234 W18x258 W18x283 W18x311 W18x35 W18x40 W18x46 W18x50 W18x55 W18x60 W18x65 W18x71 W18x76 W18x86 W18x97 W21x101 W21x111 W21x122 W21x132 W21x147 W21x166 W21x182 W21x201 W21x223 W21x248 W21x275 W21x300 W21x333 W21x364 W21x402 W21x44 W21x48 W21x50 W21x55 W21x57 W21x62 W21x68 W21x73 W21x83 W21x93 W24x103 W24x104 W24x117 W24x131 W24x146 W24x162 W24x176 W24x192 W24x207 W24x229 W24x250 W24x279 W24x306 W24x335 W24x370 W24x408 W24x450 W24x492 W24x55 W24x62 W24x68 W24x76 W24x84 W24x94 W27x102 W27x114 W27x129 W27x146 W27x161 W27x178 W27x194 W27x217 W27x235 W27x258 W27x281 W27x307 W27x336 W27x368 W27x407 W27x448 W27x494 W27x539 W27x84 W27x94 W30x108 W30x116 W30x124 W30x132 W30x148 W30x173 W30x191 W30x211 W30x235 W30x261 W30x292 W30x326 W30x357 W30x391 W30x433 W30x477 W30x526 W30x581 W30x90 W30x99 W33x118 W33x130 W33x141 W33x152 W33x169 W33x201 W33x221 W33x241 W33x263 W33x291 W33x318 W33x354 W33x387 W33x424 W33x468 W33x515 W33x567 W33x619 W36x135 W36x150 W36x160 W36x170 W36x182 W36x194 W36x210 W36x230 W36x232 W36x245 W36x256 W36x260 W36x280 W36x300 W36x328 W36x359 W36x393 W36x439 W36x485 W36x527 W36x588 W36x650 W36x720 W36x798 W36x848 W40x149 W40x167 W40x174 W40x183 W40x192 W40x199 W40x211 W40x215 W40x221 W40x235 W40x244 W40x249 W40x264 W40x268 W40x277 W40x278 W40x297 W40x298 W40x321 W40x324 W40x327 W40x328 W40x331 W40x362 W40x372 W40x392 W40x397 W40x431 W40x436 W40x466 W40x480 W40x503 W40x531 W40x593 W40x655 W44x198 W44X224 W44x230 W44x248 W44x262 W44x285 W44x290 W44x335 W4x13 W5x16 W5x19 W6x12 W6x15 W6x16 W6x20 W6x25 W6x8_5 W6x9 W8x10 W8x13 W8x15 W8x18 W8x21 W8x24 W8x28 W8x31 W8x35 W8x40 W8x48 W8x58 W8x67"
  },
  "api/Elements.Geometry.Ray.html": {
    "href": "api/Elements.Geometry.Ray.html",
    "title": "Struct Ray | Hypar Docs",
    "keywords": "Struct Ray An infinite ray starting at origin and pointing towards direction. Implements System.IEquatable < Ray > Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct Ray : IEquatable<Ray> Constructors Ray(Vector3, Vector3) Construct a ray. Declaration public Ray(Vector3 origin, Vector3 direction) Parameters Type Name Description Vector3 origin The origin of the ray. Vector3 direction The direction of the ray. Properties Direction The direction of the ray. Declaration public Vector3 Direction { get; set; } Property Value Type Description Vector3 Origin The origin of the ray. Declaration public Vector3 Origin { get; set; } Property Value Type Description Vector3 Methods Equals(Ray) Is this ray equal to the provided ray? Declaration public bool Equals(Ray other) Parameters Type Name Description Ray other The ray to test. Returns Type Description System.Boolean Returns true if the two rays are equal, otherwise false. Intersects(GeometricElement, out List<Vector3>) Does this ray intersect with the provided GeometricElement? Only GeometricElements with Solid Representations are currently supported, and voids will be ignored. Declaration public bool Intersects(GeometricElement element, out List<Vector3> result) Parameters Type Name Description GeometricElement element The element to intersect with. System.Collections.Generic.List < Vector3 > result The list of intersection results. Returns Type Description System.Boolean Intersects(Line, out Vector3) Does this ray intersect the provided line? Declaration public bool Intersects(Line line, out Vector3 result) Parameters Type Name Description Line line The line to intersect. Vector3 result The location of intersection. Returns Type Description System.Boolean True if the rays intersect, otherwise false. Intersects(Plane, out Vector3) Does this ray intersect the provided plane? Declaration public bool Intersects(Plane plane, out Vector3 result) Parameters Type Name Description Plane plane The Plane to intersect with. Vector3 result The intersection result. Returns Type Description System.Boolean True if an intersection occurs, otherwise false — this can occur if the ray is very close to parallel to the plane. If true, check the intersection result for the location of the intersection. Intersects(Plane, out Vector3, out Double) Does this ray intersect the provided plane? Declaration public bool Intersects(Plane plane, out Vector3 result, out double t) Parameters Type Name Description Plane plane The Plane to intersect with. Vector3 result The intersection result. System.Double t Returns Type Description System.Boolean True if an intersection occurs, otherwise false — this can occur if the ray is very close to parallel to the plane. If true, check the intersection result for the location of the intersection. Intersects(Ray, out Vector3, Boolean) Does this ray intersect the provided ray? Declaration public bool Intersects(Ray ray, out Vector3 result, bool ignoreRayDirection = false) Parameters Type Name Description Ray ray The ray to intersect. Vector3 result The location of intersection. System.Boolean ignoreRayDirection If true, the direction of the rays will be ignored Returns Type Description System.Boolean True if the rays intersect, otherwise false. Intersects(SolidOperation, out List<Vector3>) Does this ray intersect with the provided SolidOperation? Declaration public bool Intersects(SolidOperation solidOp, out List<Vector3> result) Parameters Type Name Description SolidOperation solidOp The SolidOperation to intersect with. System.Collections.Generic.List < Vector3 > result The list of intersection results, ordered by distance from the ray origin. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. If true, check the intersection result for the location of the intersection. Intersects(Triangle, out Vector3) https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm Declaration public bool Intersects(Triangle tri, out Vector3 result) Parameters Type Name Description Triangle tri The triangle to intersect. Vector3 result The intersection result. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. If true, check the intersection result for the type and location of intersection. Intersects(Topography, out Vector3) Does this ray intersect the provided topography? Declaration public bool Intersects(Topography topo, out Vector3 result) Parameters Type Name Description Topography topo The topography. Vector3 result The location of intersection. Returns Type Description System.Boolean True if an intersection result occurs. The type of intersection should be checked in the intersection result. False if no intersection occurs. Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.Representation.html": {
    "href": "api/Elements.Geometry.Representation.html",
    "title": "Class Representation | Hypar Docs",
    "keywords": "Class Representation The representation of an element. Inheritance System.Object Representation Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Representation Constructors Representation(IList<SolidOperation>) Declaration public Representation(IList<SolidOperation> solidOperations) Parameters Type Name Description System.Collections.Generic.IList < SolidOperation > solidOperations Properties SolidOperations A collection of solid operations. Declaration public IList<SolidOperation> SolidOperations { get; set; } Property Value Type Description System.Collections.Generic.IList < SolidOperation >"
  },
  "api/Elements.Geometry.Solids.Edge.html": {
    "href": "api/Elements.Geometry.Solids.Edge.html",
    "title": "Class Edge | Hypar Docs",
    "keywords": "Class Edge A Solid Edge. Inheritance System.Object Edge Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Edge Properties Id The Id of the Edge. Declaration public long Id { get; } Property Value Type Description System.Int64 Left The Left edge. Declaration public HalfEdge Left { get; } Property Value Type Description HalfEdge Right The Right edge. Declaration public HalfEdge Right { get; } Property Value Type Description HalfEdge Methods ToString() Get the string representation of the Edge. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Solids.Extrude.html": {
    "href": "api/Elements.Geometry.Solids.Extrude.html",
    "title": "Class Extrude | Hypar Docs",
    "keywords": "Class Extrude An extrusion of a profile, in a direction, to a height. Inheritance System.Object SolidOperation Extrude Implements System.ComponentModel.INotifyPropertyChanged Inherited Members SolidOperation.IsVoid SolidOperation.LocalTransform SolidOperation.Solid System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Extrude : SolidOperation, INotifyPropertyChanged Constructors Extrude(Profile, Double, Vector3, Boolean) Declaration public Extrude(Profile profile, double height, Vector3 direction, bool isVoid) Parameters Type Name Description Profile profile System.Double height Vector3 direction System.Boolean isVoid Properties Direction The direction in which to extrude. Declaration public Vector3 Direction { get; set; } Property Value Type Description Vector3 Height The height of the extrusion. Declaration public double Height { get; set; } Property Value Type Description System.Double Profile The id of the profile to extrude. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Methods RaisePropertyChanged(String) Declaration protected virtual void RaisePropertyChanged(string propertyName = null) Parameters Type Name Description System.String propertyName Events PropertyChanged Declaration public event PropertyChangedEventHandler PropertyChanged Event Type Type Description System.ComponentModel.PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Geometry.Solids.Face.html": {
    "href": "api/Elements.Geometry.Solids.Face.html",
    "title": "Class Face | Hypar Docs",
    "keywords": "Class Face A Solid Face. Inheritance System.Object Face Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Face Properties Id The Id of the Face. Declaration public long Id { get; } Property Value Type Description System.Int64 Inner A collection of CW wound Edges. Declaration public Loop[] Inner { get; } Property Value Type Description Loop [] Outer A CCW wound list of Edges. Declaration public Loop Outer { get; } Property Value Type Description Loop Methods ToString() The string representation of the Face. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Solids.HalfEdge.html": {
    "href": "api/Elements.Geometry.Solids.HalfEdge.html",
    "title": "Class HalfEdge | Hypar Docs",
    "keywords": "Class HalfEdge One half of the directional components of an Edge. Inheritance System.Object HalfEdge Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class HalfEdge Constructors HalfEdge(Edge, Vertex) Construct a HalfEdge. Declaration public HalfEdge(Edge edge, Vertex vertex) Parameters Type Name Description Edge edge The Edge associated with this HalfEdge. Vertex vertex The Vertex at the start of the edge. HalfEdge(Vertex) Create a half edge. Declaration public HalfEdge(Vertex v) Parameters Type Name Description Vertex v Properties Edge The Edge of which this is one half. Declaration public Edge Edge { get; } Property Value Type Description Edge Loop The Loop to which this HalfEdge belongs. Declaration public Loop Loop { get; } Property Value Type Description Loop Vertex The Vertex at the start of the edge. Declaration public Vertex Vertex { get; set; } Property Value Type Description Vertex Methods ToString() Get the string representation of this half edge. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Solids.html": {
    "href": "api/Elements.Geometry.Solids.html",
    "title": "Namespace Elements.Geometry.Solids | Hypar Docs",
    "keywords": "Namespace Elements.Geometry.Solids Classes Edge A Solid Edge. Extrude An extrusion of a profile, in a direction, to a height. Face A Solid Face. HalfEdge One half of the directional components of an Edge. Lamina A zero-thickness solid defined by a profile. Loop A Loop of HalfEdges which bound a Face. Solid A boundary representation of a solid. SolidOperation A solid operation. Sweep A sweep of a profile along a curve. Vertex A Solid Vertex."
  },
  "api/Elements.Geometry.Solids.Lamina.html": {
    "href": "api/Elements.Geometry.Solids.Lamina.html",
    "title": "Class Lamina | Hypar Docs",
    "keywords": "Class Lamina A zero-thickness solid defined by a profile. Inheritance System.Object SolidOperation Lamina Implements System.ComponentModel.INotifyPropertyChanged Inherited Members SolidOperation.IsVoid SolidOperation.LocalTransform SolidOperation.Solid System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Lamina : SolidOperation, INotifyPropertyChanged Constructors Lamina(Polygon, Boolean) Declaration public Lamina(Polygon perimeter, bool isVoid) Parameters Type Name Description Polygon perimeter System.Boolean isVoid Properties Perimeter The perimeter. Declaration public Polygon Perimeter { get; set; } Property Value Type Description Polygon Methods RaisePropertyChanged(String) Declaration protected virtual void RaisePropertyChanged(string propertyName = null) Parameters Type Name Description System.String propertyName Events PropertyChanged Declaration public event PropertyChangedEventHandler PropertyChanged Event Type Type Description System.ComponentModel.PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Geometry.Solids.Loop.html": {
    "href": "api/Elements.Geometry.Solids.Loop.html",
    "title": "Class Loop | Hypar Docs",
    "keywords": "Class Loop A Loop of HalfEdges which bound a Face. Inheritance System.Object Loop Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Loop Constructors Loop() Construct a Loop. Declaration public Loop() Loop(HalfEdge[]) Construct a Loop from an array of HalfEdges. Declaration public Loop(HalfEdge[] edges) Parameters Type Name Description HalfEdge [] edges Properties Edges A collection of HalfEdges which comprise the Loop. Declaration public List<HalfEdge> Edges { get; } Property Value Type Description System.Collections.Generic.List < HalfEdge > Face The Face to which this Loop corresponds. Declaration public Face Face { get; set; } Property Value Type Description Face Methods AddEdgeToEnd(HalfEdge) Add a HalfEdge to the end of the Loop. Declaration public void AddEdgeToEnd(HalfEdge he) Parameters Type Name Description HalfEdge he AddEdgeToStart(HalfEdge) Add a HalfEdge ot the start of the Loop. Declaration public void AddEdgeToStart(HalfEdge he) Parameters Type Name Description HalfEdge he InsertEdgeAfter(HalfEdge, HalfEdge) Insert the provided half edge after the target half edge. Declaration public void InsertEdgeAfter(HalfEdge target, HalfEdge newEdge) Parameters Type Name Description HalfEdge target The half after which the new edge will be inserted. HalfEdge newEdge The half edge to be inserted. InsertEdgeBefore(HalfEdge, HalfEdge) Insert the provided half edge before the target half edge. Declaration public void InsertEdgeBefore(HalfEdge target, HalfEdge newEdge) Parameters Type Name Description HalfEdge target The half before which the new edge will be inserted. HalfEdge newEdge The half edge to be inserted. ToPolygon() Convert this loop to a polygon. Declaration public Polygon ToPolygon() Returns Type Description Polygon"
  },
  "api/Elements.Geometry.Solids.Solid.html": {
    "href": "api/Elements.Geometry.Solids.Solid.html",
    "title": "Class Solid | Hypar Docs",
    "keywords": "Class Solid A boundary representation of a solid. Inheritance System.Object Solid Implements ITessellate Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Solid : ITessellate Constructors Solid() Construct a solid. Declaration public Solid() Properties Edges The edges of the solid. Declaration public Dictionary<long, Edge> Edges { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Int64 , Edge > Faces The Faces of the Solid. Declaration public Dictionary<long, Face> Faces { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Int64 , Face > Vertices The vertices of the solid. Declaration public Dictionary<long, Vertex> Vertices { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Int64 , Vertex > Methods AddEdge(Vertex, Vertex) Add an edge to the solid. Declaration public Edge AddEdge(Vertex from, Vertex to) Parameters Type Name Description Vertex from The start vertex. Vertex to The end vertex. Returns Type Description Edge The newly added edge. AddEdges(Polygon) Creates a series of edges from a polygon. Declaration public Edge[] AddEdges(Polygon p) Parameters Type Name Description Polygon p Returns Type Description Edge [] AddFace(Polygon, IList<Polygon>) Add a Face to the Solid. Declaration public Face AddFace(Polygon outer, IList<Polygon> inner = null) Parameters Type Name Description Polygon outer A polygon representing the perimeter of the face. System.Collections.Generic.IList < Polygon > inner An array of polygons representing the holes in the face. Returns Type Description Face The newly added face. AddFace(Loop, Loop[]) Add a face to the solid. Provided edges are expected to be wound CCW for outer, and CW for inner. The face will be linked to the edges. Declaration public Face AddFace(Loop outer, Loop[] inner = null) Parameters Type Name Description Loop outer The outer Loop of the Face. Loop [] inner The inner Loops of the Face. Returns Type Description Face The newly added Face. AddVertex(Vector3) Add a Vertex to the Solid. Declaration public Vertex AddVertex(Vector3 position) Parameters Type Name Description Vector3 position Returns Type Description Vertex The newly added vertex. Cap(Edge[][], Boolean) Create a face from edges. The first edge array is treated as the outer edge. Additional edge arrays are treated as holes. Declaration protected void Cap(Edge[][] edges, bool reverse = true) Parameters Type Name Description Edge [][] edges System.Boolean reverse CreateLamina(IList<Vector3>) Construct a lamina solid. Declaration public static Solid CreateLamina(IList<Vector3> perimeter) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > perimeter The perimeter of the lamina's faces. Returns Type Description Solid LoopFromPolygon(Polygon) Declaration protected Loop LoopFromPolygon(Polygon p) Parameters Type Name Description Polygon p Returns Type Description Loop SweepFace(Polygon, IList<Polygon>, Vector3, Double, Boolean, Double) Construct a solid by sweeping a face in a direction. Declaration public static Solid SweepFace(Polygon perimeter, IList<Polygon> holes, Vector3 direction, double distance, bool bothSides = false, double rotation = 0) Parameters Type Name Description Polygon perimeter The perimeter of the face to sweep. System.Collections.Generic.IList < Polygon > holes The holes of the face to sweep. Vector3 direction The direction in which to sweep. System.Double distance The distance to sweep. System.Boolean bothSides Should the sweep start offset by direction distance/2? System.Double rotation An optional rotation in degrees of the perimeter around the direction vector. Returns Type Description Solid A solid. SweepFace(Polygon, IList<Polygon>, Double, Boolean, Double) Construct a solid by sweeping a face. Declaration public static Solid SweepFace(Polygon perimeter, IList<Polygon> holes, double distance, bool bothSides = false, double rotation = 0) Parameters Type Name Description Polygon perimeter The perimeter of the face to sweep. System.Collections.Generic.IList < Polygon > holes The holes of the face to sweep. System.Double distance The distance to sweep. System.Boolean bothSides Should the sweep start offset by direction distance/2? System.Double rotation An optional rotation in degrees of the perimeter around the z axis. Returns Type Description Solid A solid. SweepFaceAlongCurve(Polygon, IList<Polygon>, ICurve, Double, Double) Construct a solid by sweeping a face along a curve. Declaration public static Solid SweepFaceAlongCurve(Polygon perimeter, IList<Polygon> holes, ICurve curve, double startSetback = 0, double endSetback = 0) Parameters Type Name Description Polygon perimeter The perimeter of the face to sweep. System.Collections.Generic.IList < Polygon > holes The holes of the face to sweep. ICurve curve The curve along which to sweep. System.Double startSetback The setback distance of the sweep from the start of the curve. System.Double endSetback The setback distance of the sweep from the end of the curve. Returns Type Description Solid A solid. Tessellate(ref Mesh, Transform, Color) Triangulate this solid. Declaration public void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh The mesh to which the solid's tessellated data will be added. Transform transform An optional transform used to transform the generated vertex coordinates. Color color An optional color to apply to the vertex. Tessellate(out Byte[], out Byte[], out Byte[], out Byte[], out Byte[], out Double[], out Double[], out Double[], out Double[], out Single[], out Single[], out UInt16, out UInt16, out Double[], out Double[]) Triangulate this solid and pack the triangulated data into buffers appropriate for use with gltf. Declaration public void Tessellate(out byte[] vertexBuffer, out byte[] indexBuffer, out byte[] normalBuffer, out byte[] colorBuffer, out byte[] uvBuffer, out double[] vmax, out double[] vmin, out double[] nmin, out double[] nmax, out float[] cmin, out float[] cmax, out ushort imin, out ushort imax, out double[] uvmin, out double[] uvmax) Parameters Type Name Description System.Byte [] vertexBuffer System.Byte [] indexBuffer System.Byte [] normalBuffer System.Byte [] colorBuffer System.Byte [] uvBuffer System.Double [] vmax System.Double [] vmin System.Double [] nmin System.Double [] nmax System.Single [] cmin System.Single [] cmax System.UInt16 imin System.UInt16 imax System.Double [] uvmin System.Double [] uvmax ToString() Get the string representation of the solid. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Implements ITessellate"
  },
  "api/Elements.Geometry.Solids.SolidOperation.html": {
    "href": "api/Elements.Geometry.Solids.SolidOperation.html",
    "title": "Class SolidOperation | Hypar Docs",
    "keywords": "Class SolidOperation A solid operation. Inheritance System.Object SolidOperation Extrude Lamina Sweep Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public abstract class SolidOperation Constructors SolidOperation(Boolean) Declaration public SolidOperation(bool isVoid) Parameters Type Name Description System.Boolean isVoid Properties IsVoid Is the solid operation a void operation? Declaration public bool IsVoid { get; set; } Property Value Type Description System.Boolean LocalTransform The local transform of the operation. Declaration public Transform LocalTransform { get; set; } Property Value Type Description Transform Solid The solid operation's solid. Declaration public Solid Solid { get; } Property Value Type Description Solid"
  },
  "api/Elements.Geometry.Solids.Sweep.html": {
    "href": "api/Elements.Geometry.Solids.Sweep.html",
    "title": "Class Sweep | Hypar Docs",
    "keywords": "Class Sweep A sweep of a profile along a curve. Inheritance System.Object SolidOperation Sweep Implements System.ComponentModel.INotifyPropertyChanged Inherited Members SolidOperation.IsVoid SolidOperation.LocalTransform SolidOperation.Solid System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Sweep : SolidOperation, INotifyPropertyChanged Constructors Sweep(Profile, Curve, Double, Double, Double, Boolean) Declaration public Sweep(Profile profile, Curve curve, double startSetback, double endSetback, double profileRotation, bool isVoid) Parameters Type Name Description Profile profile Curve curve System.Double startSetback System.Double endSetback System.Double profileRotation System.Boolean isVoid Properties Curve The curve along which the profile will be swept. Declaration public Curve Curve { get; set; } Property Value Type Description Curve EndSetback The amount to set back the resulting solid from the end of the curve. Declaration public double EndSetback { get; set; } Property Value Type Description System.Double Profile The id of the profile to be swept along the curve. Declaration public Profile Profile { get; set; } Property Value Type Description Profile ProfileRotation The rotation of the profile around the sweep's curve. Declaration public double ProfileRotation { get; set; } Property Value Type Description System.Double StartSetback The amount to set back the resulting solid from the start of the curve. Declaration public double StartSetback { get; set; } Property Value Type Description System.Double Methods RaisePropertyChanged(String) Declaration protected virtual void RaisePropertyChanged(string propertyName = null) Parameters Type Name Description System.String propertyName Events PropertyChanged Declaration public event PropertyChangedEventHandler PropertyChanged Event Type Type Description System.ComponentModel.PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Geometry.Solids.Vertex.html": {
    "href": "api/Elements.Geometry.Solids.Vertex.html",
    "title": "Class Vertex | Hypar Docs",
    "keywords": "Class Vertex A Solid Vertex. Inheritance System.Object Vertex Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Vertex Properties HalfEdge The HalfEdge which has this Vertex as its start. Declaration public HalfEdge HalfEdge { get; set; } Property Value Type Description HalfEdge Id The Id of the Vertex. Declaration public long Id { get; } Property Value Type Description System.Int64 Point The location of the Vertex. Declaration public Vector3 Point { get; } Property Value Type Description Vector3 Methods ToString() Get the string representation of the Vertex. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Transform.html": {
    "href": "api/Elements.Geometry.Transform.html",
    "title": "Class Transform | Hypar Docs",
    "keywords": "Class Transform A right-handed coordinate system with +Z up. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Transform.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var m1 = new Mass(Polygon.Rectangle(1.0, 1.0), 1.0, new Material(\"yellow\", Colors.Yellow)); this.Model.AddElement(m1); Profile prof = Polygon.Rectangle(1.0, 1.0); var j = 1.0; var count = 10; for (var i = 0.0; i < 360.0; i += 360.0 / (double)count) { var m2 = new Mass(prof, 1.0, new Material($\"color_{j}\", new Color((float)j - 1.0f, 0.0f, 0.0f, 1.0f)), new Transform()); // Scale the mass. m2.Transform.Scale(new Vector3(j, j, j)); // Move the mass. m2.Transform.Move(new Vector3(3, 0, 0)); // Rotate the mass. m2.Transform.Rotate(Vector3.ZAxis, i); this.Model.AddElement(m2); j += 1.0 / (double)count; } Inheritance System.Object Transform Implements System.IEquatable < Transform > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Transform : IEquatable<Transform> Constructors Transform() Create the identity transform. Declaration public Transform() Transform(Matrix) Declaration public Transform(Matrix matrix) Parameters Type Name Description Matrix matrix Transform(Transform) Create a transform by copying another transform. Declaration public Transform(Transform t) Parameters Type Name Description Transform t The transform to copy. Transform(Vector3, Vector3, Vector3, Vector3) Create a transform by origin, X, Y, and Z axes. Declaration public Transform(Vector3 origin, Vector3 xAxis, Vector3 yAxis, Vector3 zAxis) Parameters Type Name Description Vector3 origin The origin of the transform. Vector3 xAxis The X axis of the transform. Vector3 yAxis The Y axis of the transform. Vector3 zAxis The Z axis of the transform. Transform(Vector3, Vector3, Vector3, Double) Create a transform by origin and X and Z axes. Declaration public Transform(Vector3 origin, Vector3 xAxis, Vector3 zAxis, double rotation = 0) Parameters Type Name Description Vector3 origin The origin of the transform. Vector3 xAxis The X axis of the transform. Vector3 zAxis The Z axis of the transform. System.Double rotation An optional rotation in degrees around the transform's z axis. Transform(Vector3, Vector3, Double) Create a transform centered at origin with its Z axis pointing along up. Declaration public Transform(Vector3 origin, Vector3 z, double rotation = 0) Parameters Type Name Description Vector3 origin The origin of the transform. Vector3 z The vector which will define the Z axis of the transform. System.Double rotation An optional rotation around the z axis. Transform(Vector3, Double) Create a transform with a translation. Declaration public Transform(Vector3 origin, double rotation = 0) Parameters Type Name Description Vector3 origin The origin of the transform. System.Double rotation An optional rotation in degrees around the transform's z axis. Transform(Double, Double, Double, Double) Create a transform with a translation. Declaration public Transform(double x, double y, double z, double rotation = 0) Parameters Type Name Description System.Double x The X component of translation. System.Double y The Y component of translation. System.Double z The Z component of translation. System.Double rotation An optional rotation in degrees around the transform's z axis. Properties Matrix The transform's matrix. Declaration public Matrix Matrix { get; set; } Property Value Type Description Matrix Origin The origin of the transform. Declaration public Vector3 Origin { get; } Property Value Type Description Vector3 XAxis The x axis of the transform. Declaration public Vector3 XAxis { get; } Property Value Type Description Vector3 YAxis The y axis of the transform. Declaration public Vector3 YAxis { get; } Property Value Type Description Vector3 ZAxis The z axis of the transform. Declaration public Vector3 ZAxis { get; } Property Value Type Description Vector3 Methods Concatenate(Transform) Concatenate the transform. Declaration public void Concatenate(Transform transform) Parameters Type Name Description Transform transform Concatenated(Transform) Return a new transform which is the supplied transform concatenated to this transform. Declaration public Transform Concatenated(Transform transform) Parameters Type Name Description Transform transform The transform to concatenate. Returns Type Description Transform CreateOrientedAlongCurve(Curve, Double, Vector3) Create a transform that is oriented along a curve at parameter t. The transform's +z axis will align with the +z world axis, and the +x axis will align with the tangent of the curve. Declaration public static Transform CreateOrientedAlongCurve(Curve curve, double t, Vector3 up = default(Vector3)) Parameters Type Name Description Curve curve The curve along which to orient the transform. System.Double t A parameter value between 0.0 and 1.0. Vector3 up Returns Type Description Transform Equals(Transform) Is this transform equal to the provided transform? Declaration public bool Equals(Transform other) Parameters Type Name Description Transform other The transform to test. Returns Type Description System.Boolean True if the two transforms are equal, otherwise false. Invert() Invert this transform. Declaration public void Invert() Move(Vector3) Apply a translation to the transform. Declaration public void Move(Vector3 translation) Parameters Type Name Description Vector3 translation The translation to apply. Move(Double, Double, Double) Apply a translation to the transform. Declaration public void Move(double x = 0, double y = 0, double z = 0) Parameters Type Name Description System.Double x System.Double y System.Double z Moved(Vector3) Return a new transform which is this transform moved by the specified amount. Declaration public Transform Moved(Vector3 translation) Parameters Type Name Description Vector3 translation The translation to apply. Returns Type Description Transform Moved(Double, Double, Double) Return a new transform which is this transform moved by the specified amount. Declaration public Transform Moved(double x = 0, double y = 0, double z = 0) Parameters Type Name Description System.Double x System.Double y System.Double z Returns Type Description Transform OfBezier(Bezier) Transform the specifed bezier. Declaration [Obsolete(\"Use Bezier.Transformed(Transform) instead.\")] public Bezier OfBezier(Bezier bezier) Parameters Type Name Description Bezier bezier The bezier to transform. Returns Type Description Bezier A new bezier transformed by this transform. OfCurve(Curve) A transformed copy of the supplied curve. Declaration [Obsolete(\"Use Curve.Transformed(Transform) instead.\")] public Curve OfCurve(Curve curve) Parameters Type Name Description Curve curve The curve to transform. Returns Type Description Curve OfLine(Line) Transform the specified line. Declaration [Obsolete(\"Use Line.Transformed(Transform) instead.\")] public Line OfLine(Line line) Parameters Type Name Description Line line The line to transform. Returns Type Description Line A new line transformed by this transform. OfPlane(Plane) Transform the specified plane. Declaration public Plane OfPlane(Plane plane) Parameters Type Name Description Plane plane The plane to transform. Returns Type Description Plane A new plane transformed by this transform. OfPoint(Vector3) Transform a vector into the coordinate space defined by this transform ignoring the translation. Declaration public Vector3 OfPoint(Vector3 vector) Parameters Type Name Description Vector3 vector The vector to transform. Returns Type Description Vector3 A new vector transformed by this transform. OfPolygon(Polygon) Transform the specified polygon. Declaration [Obsolete(\"Use Polygon.Transformed(Transform) instead.\")] public Polygon OfPolygon(Polygon polygon) Parameters Type Name Description Polygon polygon The polygon to transform. Returns Type Description Polygon A new polygon transformed by this transform. OfPolygons(IList<Polygon>) Transform the specified polygons. Declaration public Polygon[] OfPolygons(IList<Polygon> polygons) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The polygons to transform. Returns Type Description Polygon [] An array of polygons transformed by this transform. OfProfile(Profile) Transform the specified profile. Declaration public Profile OfProfile(Profile profile) Parameters Type Name Description Profile profile The profile to transform. Returns Type Description Profile A new profile transformed by this transform. OfVector(Vector3) Transform a vector into the coordinate space defined by this transform. Declaration public Vector3 OfVector(Vector3 vector) Parameters Type Name Description Vector3 vector The vector to transform. Returns Type Description Vector3 A new vector transformed by this transform. Reflect(Vector3) Reflect about the plane with normal n. Declaration public void Reflect(Vector3 n) Parameters Type Name Description Vector3 n The normal of the reflection plane. Rotate(Vector3, Double) Apply a rotation to the transform. Declaration public void Rotate(Vector3 axis, double angle) Parameters Type Name Description Vector3 axis The axis of rotation. System.Double angle The angle of rotation in degrees. Rotate(Double) Apply a rotation to the transform around the Z axis. Declaration public void Rotate(double angle) Parameters Type Name Description System.Double angle The angle of rotation in degrees. Scale(Vector3) Apply a scale to the transform. Declaration public void Scale(Vector3 amount) Parameters Type Name Description Vector3 amount The amount to scale. Scale(Double) Scale uniformly about the origin. Declaration public void Scale(double factor) Parameters Type Name Description System.Double factor The amount to scale uniformly Scale(Double, Vector3) Scale uniformly about a point Declaration public void Scale(double factor, Vector3 origin) Parameters Type Name Description System.Double factor The scale factor Vector3 origin The origin of scaling Scaled(Vector3) Return a copy of this transform scaled by the given value. Declaration public Transform Scaled(Vector3 amount) Parameters Type Name Description Vector3 amount The amount to scale. Returns Type Description Transform Scaled(Double) Return a copy of this transform scaled uniformly. Declaration public Transform Scaled(double factor) Parameters Type Name Description System.Double factor The amount to scale uniformly Returns Type Description Transform ToString() Get a string representation of the transform. Declaration public override string ToString() Returns Type Description System.String A string representation of the transform. Overrides System.Object.ToString() XY() Calculate XY plane of the transform. Declaration public Plane XY() Returns Type Description Plane XZ() Calculate the XZ plane of the transform. Declaration public Plane XZ() Returns Type Description Plane YZ() Calculate the YZ plane of the transform. Declaration public Plane YZ() Returns Type Description Plane Implements System.IEquatable<T> Extension Methods ModelCurveExtensions.ToModelCurves(Transform, Transform)"
  },
  "api/Elements.Geometry.Triangle.html": {
    "href": "api/Elements.Geometry.Triangle.html",
    "title": "Class Triangle | Hypar Docs",
    "keywords": "Class Triangle A mesh triangle. Inheritance System.Object Triangle Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Triangle Constructors Triangle(Vertex, Vertex, Vertex) Create a triangle. Declaration public Triangle(Vertex a, Vertex b, Vertex c) Parameters Type Name Description Vertex a The index of the first vertex of the triangle. Vertex b The index of the second vertex of the triangle. Vertex c The index of the third vertex of the triangle. Triangle(IList<Vertex>, Vector3) Declaration public Triangle(IList<Vertex> vertices, Vector3 normal) Parameters Type Name Description System.Collections.Generic.IList < Vertex > vertices Vector3 normal Properties Normal The triangle's normal. Declaration public Vector3 Normal { get; set; } Property Value Type Description Vector3 Vertices The triangle's vertices. Declaration public IList<Vertex> Vertices { get; set; } Property Value Type Description System.Collections.Generic.IList < Vertex > Methods Area() The area of the triangle. Declaration public double Area() Returns Type Description System.Double"
  },
  "api/Elements.Geometry.UV.html": {
    "href": "api/Elements.Geometry.UV.html",
    "title": "Struct UV | Hypar Docs",
    "keywords": "Struct UV A UV coordinate. Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct UV Constructors UV(Double, Double) Declaration public UV(double u, double v) Parameters Type Name Description System.Double u System.Double v Properties U The U coordinate. Declaration public double U { get; set; } Property Value Type Description System.Double V The V coordinate. Declaration public double V { get; set; } Property Value Type Description System.Double Methods Equals(Object) Are the two uvs equal? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.ValueType.Equals(System.Object) GetHashCode() Get the hash code for the uv. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() ToString() A string representation of the uv. Declaration public override string ToString() Returns Type Description System.String Overrides System.ValueType.ToString() Operators Equality(UV, UV) Are the two UVs equal? Declaration public static bool operator ==(UV a, UV b) Parameters Type Name Description UV a UV b Returns Type Description System.Boolean Inequality(UV, UV) Are the two UVs equal? Declaration public static bool operator !=(UV a, UV b) Parameters Type Name Description UV a UV b Returns Type Description System.Boolean"
  },
  "api/Elements.Geometry.Vector3.html": {
    "href": "api/Elements.Geometry.Vector3.html",
    "title": "Struct Vector3 | Hypar Docs",
    "keywords": "Struct Vector3 A 3D vector. Implements System.IComparable < Vector3 > System.IEquatable < Vector3 > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct Vector3 : IComparable<Vector3>, IEquatable<Vector3> Constructors Vector3(Vector3) Create a Vector3 by copying the components of another Vector3. Declaration public Vector3(Vector3 v) Parameters Type Name Description Vector3 v The Vector3 to copy. Vector3(Double, Double) Create a vector from x, and y coordinates. Declaration public Vector3(double x, double y) Parameters Type Name Description System.Double x The x coordinate of the vector. System.Double y Thy y coordinate of the vector. Vector3(Double, Double, Double) Declaration public Vector3(double x, double y, double z) Parameters Type Name Description System.Double x System.Double y System.Double z Fields EPSILON A tolerance for comparison operations of 1e-5. Declaration public const double EPSILON = 1E-05 Field Value Type Description System.Double Properties Origin Create a vector at the origin. Declaration public static Vector3 Origin { get; } Property Value Type Description Vector3 X The X component of the vector. Declaration public double X { get; set; } Property Value Type Description System.Double XAxis Create a vector along the X axis. Declaration public static Vector3 XAxis { get; } Property Value Type Description Vector3 Y The Y component of the vector. Declaration public double Y { get; set; } Property Value Type Description System.Double YAxis Create a vector along the Y axis. Declaration public static Vector3 YAxis { get; } Property Value Type Description Vector3 Z The Z component of the vector. Declaration public double Z { get; set; } Property Value Type Description System.Double ZAxis Create a vector along the Z axis. Declaration public static Vector3 ZAxis { get; } Property Value Type Description Vector3 Methods AngleTo(Vector3) The angle in degrees from this vector to the provided vector. Note that for angles in the plane that can be greater than 180 degrees, you should use Vector3.PlaneAngleTo. Declaration public double AngleTo(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to measure the angle. Returns Type Description System.Double The angle in degrees between 0 and 180. AtNEqualSpacesAlongLine(Line, Int32, Boolean) Create vectors at n equal spaces along the provided line. Declaration public static IList<Vector3> AtNEqualSpacesAlongLine(Line line, int n, bool includeEnds = false) Parameters Type Name Description Line line The line. System.Int32 n The number of samples along the line. System.Boolean includeEnds A flag indicating whether or not to include points for the start and end of the line. Returns Type Description System.Collections.Generic.IList < Vector3 > Average(Vector3) Compute the average of this Vector3 and v. Declaration public Vector3 Average(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to compute the average. Returns Type Description Vector3 A vector which is the average of this and v. CCW(Vector3, Vector3, Vector3) Check whether three points are wound CCW in two dimensions. Declaration public static double CCW(Vector3 a, Vector3 b, Vector3 c) Parameters Type Name Description Vector3 a The first point. Vector3 b The second point. Vector3 c The third point. Returns Type Description System.Double Greater than 0 if the points are CCW, less than 0 if they are CW, and 0 if they are colinear. ClosestPointOn(Line) Get the closest point on the line from this point. Declaration public Vector3 ClosestPointOn(Line line) Parameters Type Name Description Line line The line on which to find the closest point. Returns Type Description Vector3 The closest point on the line from this point. CompareTo(Vector3) Implement IComparable interface. Declaration public int CompareTo(Vector3 v) Parameters Type Name Description Vector3 v Returns Type Description System.Int32 Cross(Vector3) Compute the cross product of this vector and v. Declaration public Vector3 Cross(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to compute the cross product. Returns Type Description Vector3 DistanceTo(Line) Find the distance from this point to the line. Declaration public double DistanceTo(Line line) Parameters Type Name Description Line line Returns Type Description System.Double DistanceTo(Line, out Vector3) Find the distance from this point to the line, and output the location of the closest point on that line. Using formula from https://diego.assencio.com/?index=ec3d5dfdfc0b6a0d147a656f0af332bd Declaration public double DistanceTo(Line line, out Vector3 closestPoint) Parameters Type Name Description Line line The line to find the distance to. Vector3 closestPoint The point on the line that is closest to this point. Returns Type Description System.Double DistanceTo(Plane) The distance from this point to the plane. The distance will be negative when this point lies \"behind\" the plane. Declaration public double DistanceTo(Plane p) Parameters Type Name Description Plane p The plane. Returns Type Description System.Double DistanceTo(Polyline) Find the shortest distance from this point to any point on the polyline, and output the location of the closest point on that polyline. Declaration public double DistanceTo(Polyline polyline) Parameters Type Name Description Polyline polyline The polyline for computing the distance. Returns Type Description System.Double DistanceTo(Polyline, out Vector3) Find the shortest distance from this point to any point on the polyline, and output the location of the closest point on that polyline. Declaration public double DistanceTo(Polyline polyline, out Vector3 closestPoint) Parameters Type Name Description Polyline polyline The polyline for computing the distance. Vector3 closestPoint The point on the polyline that is closest to this point. Returns Type Description System.Double DistanceTo(Vector3) The distance from this point to b. Declaration public double DistanceTo(Vector3 v) Parameters Type Name Description Vector3 v The target vector. Returns Type Description System.Double The distance between this vector and the provided vector. Dot(Vector3) Compute the dot product of this vector and v. Declaration public double Dot(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to compute the dot product. Returns Type Description System.Double The dot product. Equals(Vector3) Is this vector equal to the provided vector? Declaration public bool Equals(Vector3 other) Parameters Type Name Description Vector3 other The vector to test. Returns Type Description System.Boolean Returns true if all components of the two vectors are within Epsilon, otherwise false. Equals(Object) Is this vector equal to the provided vector? Declaration public override bool Equals(object other) Parameters Type Name Description System.Object other The vector to test. Returns Type Description System.Boolean Returns true if all components of the two vectors are within Epsilon, otherwise false. Overrides System.ValueType.Equals(System.Object) GetHashCode() Get the hash code for the vector. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() IsAlmostEqualTo(Vector3) Determine whether this vector's components are equal to those of v, within Epsilon. Declaration public bool IsAlmostEqualTo(Vector3 v) Parameters Type Name Description Vector3 v The vector to compare. Returns Type Description System.Boolean True if the difference of this vector and the supplied vector's components are all within Tolerance, otherwise false. IsAlmostEqualTo(Double, Double, Double) Determine whether this vector's components are equal to the provided components, within tolerance. Declaration public bool IsAlmostEqualTo(double x, double y, double z = 0) Parameters Type Name Description System.Double x The x component to compare. System.Double y The y component to compare. System.Double z The z component to compare. Returns Type Description System.Boolean True if the difference of this vector and the supplied vector's components are all within Tolerance, otherwise false. IsNaN() Are any components of this vector NaN? Declaration public bool IsNaN() Returns Type Description System.Boolean True if any components are NaN otherwise false. IsParallelTo(Vector3) Determine whether this vector is parallel to v. Declaration public bool IsParallelTo(Vector3 v) Parameters Type Name Description Vector3 v The vector to compare to this vector. Returns Type Description System.Boolean True if the vectors are parallel, otherwise false. IsZero() Is this vector zero length? Declaration public bool IsZero() Returns Type Description System.Boolean True if this vector's components are all less than Epsilon. Length() Get the length of this vector. Declaration public double Length() Returns Type Description System.Double Negate() Construct a new vector which is the inverse of this vector. Declaration public Vector3 Negate() Returns Type Description Vector3 A new vector which is the inverse of this vector. PlaneAngleTo(Vector3) Calculate a counter-clockwise plane angle between this vector and the provided vector in the XY plane. Declaration public double PlaneAngleTo(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to measure the angle. Returns Type Description System.Double Angle in degrees between 0 and 360, or NaN if the projected input vectors are invalid. PlaneAngleTo(Vector3, Vector3) Calculate a counter-clockwise plane angle between this vector and the provided vector, projected to the plane perpendicular to the provided normal. Declaration public double PlaneAngleTo(Vector3 v, Vector3 normal) Parameters Type Name Description Vector3 v The vector with which to measure the angle. Vector3 normal The normal of the plane in which you wish to calculate the angle. Returns Type Description System.Double Angle in degrees between 0 and 360, or NaN if the projected input vectors are invalid. Project(Plane) Project this vector onto the plane. Declaration public Vector3 Project(Plane p) Parameters Type Name Description Plane p The plane on which to project the point. Returns Type Description Vector3 ProjectAlong(Vector3, Plane) Project this vector onto the plane along a vector. Declaration public Vector3 ProjectAlong(Vector3 v, Plane p) Parameters Type Name Description Vector3 v The vector along which t project. Plane p The plane on which to project. Returns Type Description Vector3 A point on the plane. ProjectOnto(Vector3) Project vector a onto this vector. Declaration public Vector3 ProjectOnto(Vector3 a) Parameters Type Name Description Vector3 a The vector to project onto this vector. Returns Type Description Vector3 A new vector which is the projection of a onto this vector. ToArray() Convert a vector's components to an array. Declaration public double[] ToArray() Returns Type Description System.Double [] An array of comprised of the x, y, and z components of this vector. ToString() A string representation of the vector. Declaration public override string ToString() Returns Type Description System.String The string representation of this vector. Overrides System.ValueType.ToString() TripleProduct(Vector3, Vector3) Check if two vectors are coplanar. Declaration public double TripleProduct(Vector3 b, Vector3 c) Parameters Type Name Description Vector3 b The second vector. Vector3 c The third vector. Returns Type Description System.Double True is the vectors are coplanar, otherwise false. Unitized() Return a new vector which is the unitized version of this vector. Declaration public Vector3 Unitized() Returns Type Description Vector3 Operators Addition(Vector3, Vector3) Add two vectors. Declaration public static Vector3 operator +(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description Vector3 A vector which is the sum of a and b. Division(Vector3, Double) Divide a vector by a scalar. Declaration public static Vector3 operator /(Vector3 v, double a) Parameters Type Name Description Vector3 v The vector to divide. System.Double a The scalar divisor. Returns Type Description Vector3 A vector whose magnitude is multiplied by a. Equality(Vector3, Vector3) Are the two vectors the same within Epsilon? Declaration public static bool operator ==(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a Vector3 b Returns Type Description System.Boolean GreaterThan(Vector3, Vector3) Compute whether all components of vector a are greater than those of vector b. Declaration public static bool operator>(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description System.Boolean True if all of a's components are greater than those of b, otherwise false. Inequality(Vector3, Vector3) Are the two vectors not the same within Epsilon? Declaration public static bool operator !=(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a Vector3 b Returns Type Description System.Boolean LessThan(Vector3, Vector3) Compute whether all components of vector a are less than those of vector b. Declaration public static bool operator <(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description System.Boolean True if all of a's components are less than those of b, otherwise false. Multiply(Vector3, Double) Multiply a vector and a scalar. Declaration public static Vector3 operator *(Vector3 v, double a) Parameters Type Name Description Vector3 v The vector to multiply. System.Double a The scalar value to multiply. Returns Type Description Vector3 A vector whose magnitude is multiplied by a. Multiply(Double, Vector3) Multiply a scalar and a vector. Declaration public static Vector3 operator *(double a, Vector3 v) Parameters Type Name Description System.Double a The scalar value to multiply. Vector3 v The vector to multiply. Returns Type Description Vector3 A vector whose magnitude is multiplied by a. Subtraction(Vector3, Vector3) Subtract two vectors. Declaration public static Vector3 operator -(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description Vector3 A vector which is the difference between a and b. Implements System.IComparable<T> System.IEquatable<T>"
  },
  "api/Elements.Geometry.Vector3Extensions.html": {
    "href": "api/Elements.Geometry.Vector3Extensions.html",
    "title": "Class Vector3Extensions | Hypar Docs",
    "keywords": "Class Vector3Extensions Extension methods for Vector3. Inheritance System.Object Vector3Extensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class Vector3Extensions Methods AreCollinear(IList<Vector3>) Are the provided points along the same line? Declaration public static bool AreCollinear(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points Returns Type Description System.Boolean AreCoplanar(IList<Vector3>) Are the provided points on the same plane? Declaration public static bool AreCoplanar(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points Returns Type Description System.Boolean Average(IList<Vector3>) Find the average of a collection of Vector3. Declaration public static Vector3 Average(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The Vector3 collection to average. Returns Type Description Vector3 A Vector3 representing the average. Shrink(Vector3[], Double) Shrink a collection of Vector3 towards their average. Declaration public static Vector3[] Shrink(this Vector3[] points, double distance) Parameters Type Name Description Vector3 [] points The collection of Vector3 to shrink. System.Double distance The distance to shrink along the vector to average. Returns Type Description Vector3 [] ToArray(IList<Vector3>) Convert a collection of Vector3 to a flat array of double. Declaration public static double[] ToArray(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The collection of Vector3 to convert. Returns Type Description System.Double [] An array containing x,y,z,x1,y1,z1,x2,y2,z2,... ToTransform(IList<Vector3>) Compute a transform with the origin at points[0], with an X axis along points[1]->points[0], and a normal computed using the vectors points[2]->points[1] and points[1]->points[0]. Declaration public static Transform ToTransform(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points Returns Type Description Transform"
  },
  "api/Elements.Geometry.Vertex.html": {
    "href": "api/Elements.Geometry.Vertex.html",
    "title": "Class Vertex | Hypar Docs",
    "keywords": "Class Vertex A mesh vertex. Inheritance System.Object Vertex Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Vertex Constructors Vertex(Vector3, Vector3, Color, Int32, UV) Declaration public Vertex(Vector3 position, Vector3 normal, Color color, int index, UV uV) Parameters Type Name Description Vector3 position Vector3 normal Color color System.Int32 index UV uV Vertex(Vector3, Nullable<Vector3>, Color) Create a vertex. Declaration public Vertex(Vector3 position, Vector3? normal = default(Vector3? ), Color color = default(Color)) Parameters Type Name Description Vector3 position The position of the vertex. System.Nullable < Vector3 > normal The vertex's normal. Color color The vertex's color. Properties Color The vertex's color. Declaration public Color Color { get; set; } Property Value Type Description Color Index The index of the vertex within a mesh. Declaration public int Index { get; set; } Property Value Type Description System.Int32 Normal The vertex's normal. Declaration public Vector3 Normal { get; set; } Property Value Type Description Vector3 Position The vertex's position. Declaration public Vector3 Position { get; set; } Property Value Type Description Vector3 Triangles The triangles associated with this vertex. Declaration public IList<Triangle> Triangles { get; set; } Property Value Type Description System.Collections.Generic.IList < Triangle > UV The vertex's texture coordinate. Declaration public UV UV { get; set; } Property Value Type Description UV"
  },
  "api/Elements.Geometry.VoidTreatment.html": {
    "href": "api/Elements.Geometry.VoidTreatment.html",
    "title": "Enum VoidTreatment | Hypar Docs",
    "keywords": "Enum VoidTreatment Controls the handling of internal regions in a polygon boolean operation. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum VoidTreatment Fields Name Description IgnoreInternalVoids Treat all contained or overlapping polygons as solid. This corresponds to Clipper's \"Positive\" PolyFillType. PreserveInternalVoids Use an Even/Odd fill pattern to decide whether internal polygons are solid or void. This corresponds to Clipper's \"EvenOdd\" PolyFillType."
  },
  "api/Elements.html": {
    "href": "api/Elements.html",
    "title": "Namespace Elements | Hypar Docs",
    "keywords": "Namespace Elements Classes Beam A structural framing element defined by a center line curve and a profile. Brace A Brace is a structural framing element which is often diagonal. BuiltInMaterials Built in materials. Column A vertical structural framing element. ContentCatalog A collection of ContentElements ContentElement An element representing user content. DirectionalLight A directional light. DomainExtensions Extension and utility methods for mathematical operations. Element An object which is identified with a unique identifier and a name. ElementInstance An instance of an element in the model. Instances point to one instance of a type, but have individual ids and transforms. Floor A floor is a horizontal element defined by a profile. Frame An element defined by a perimeter and a cross section swept along that perimeter. GeometricElement An element with a geometric representation. ImportMeshElement An element definition whose representation is provided by an imported mesh like an STL. Mass An extruded volume. Material A material. MeshElement An element whose representation is provided by a mesh. Model A container of elements. ModelCurve A curve which is visible in 3D. ModelCurveExtensions Extension methods for model curves. ModelPoints A collection of points which are visible in 3D. Opening A polygonal opening. An opening's placement is defined by the x and y coordinates. The direction of the opening corresponds to the +Z axis of the transform. Panel A zero-thickness planar element defined by a perimeter. Space An extruded region of occupiable space. StandardWall A wall defined by a planar curve, a height, and a thickness. StringExtensions String utilities and extension methods. StructuralFraming A structural element with a profile swept along a curve. Topography A topographic mesh defined by an array of elevation values. Units Unit conversions and utilities. Wall A wall defined by a planar profile extruded to a height. WallByProfile A wall drawn using the elevation profile Structs Domain1d A 1 dimensional interval or domain. Enums Units.CardinalDirection Cardinal directions. Units.LengthUnit Units of length. Units.UnitType Unit types."
  },
  "api/Elements.ImportMeshElement.html": {
    "href": "api/Elements.ImportMeshElement.html",
    "title": "Class ImportMeshElement | Hypar Docs",
    "keywords": "Class ImportMeshElement An element definition whose representation is provided by an imported mesh like an STL. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ImportMeshElement.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var path = \"../../../models/STL/Hilti_2008782_Speed lock clevis hanger MH-SLC 2_ EG_2.stl\"; var shiny = new Material(\"shiny\", Colors.Red, 1.0, 0.9); var bracket = new ImportMeshElement(path, Units.LengthUnit.Millimeter, shiny); model.AddElement(bracket); var brackets = new List<ElementInstance>(); for (var u = 0; u < 360.0; u += 20) { var t = new Transform(new Vector3(1, 0, 0)); t.Rotate(Vector3.ZAxis, u); var instance = bracket.CreateInstance(t, $\"Component_{u}\"); model.AddElement(instance); } Inheritance System.Object Element GeometricElement MeshElement ImportMeshElement Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members MeshElement._mesh MeshElement.Mesh MeshElement.Tessellate(Mesh, Transform, Color) GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.UpdateRepresentations() GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public sealed class ImportMeshElement : MeshElement, INotifyPropertyChanged, ITessellate Constructors ImportMeshElement(String, Units.LengthUnit, Material, Guid, String) Construct an import mesh element. Declaration public ImportMeshElement(string path, Units.LengthUnit lengthUnit, Material material = null, Guid id = default(Guid), string name = null) Parameters Type Name Description System.String path The path to the element's mesh on disk. Units.LengthUnit lengthUnit The length unit used in the provided mesh. Material material The element's material. System.Guid id The element's id. System.String name The element's name. Properties Path The path to the element's mesh on disk. Declaration public string Path { get; } Property Value Type Description System.String Implements System.ComponentModel.INotifyPropertyChanged ITessellate"
  },
  "api/Elements.Interfaces.html": {
    "href": "api/Elements.Interfaces.html",
    "title": "Namespace Elements.Interfaces | Hypar Docs",
    "keywords": "Namespace Elements.Interfaces Interfaces IHasOpenings"
  },
  "api/Elements.Interfaces.IHasOpenings.html": {
    "href": "api/Elements.Interfaces.IHasOpenings.html",
    "title": "Interface IHasOpenings | Hypar Docs",
    "keywords": "Interface IHasOpenings Namespace : Elements.Interfaces Assembly : Hypar.Elements.dll Syntax public interface IHasOpenings Properties Openings A collection of openings. Declaration List<Opening> Openings { get; } Property Value Type Description System.Collections.Generic.List < Opening >"
  },
  "api/Elements.Mass.html": {
    "href": "api/Elements.Mass.html",
    "title": "Class Mass | Hypar Docs",
    "keywords": "Class Mass An extruded volume. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Mass.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(); var b = new Vector3(30, 10); var c = new Vector3(20, 50); var d = new Vector3(-10, 5); var poly = new Polygon(new[] { a, b, c, d }); // Create a mass. var mass = new Mass(poly, 5.0); Inheritance System.Object Element GeometricElement Mass Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Mass : GeometricElement, INotifyPropertyChanged Constructors Mass(Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a Mass. Declaration public Mass(Profile profile, double height = 1, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The profile of the mass. System.Double height The height of the mass from the bottom elevation. Material material The mass' material. The default is the built in mass material. Transform transform The mass' transform. Representation representation The mass' representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the mass. System.String name The name of the mass. Properties Height The height of the mass. Declaration public double Height { get; set; } Property Value Type Description System.Double Profile The profile of the mass. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Thickness The thickness of the mass' extrusion. Declaration public double Thickness { get; } Property Value Type Description System.Double Methods ProfileTransformed() Get the profile of the mass transformed by the mass' transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() The volume of the mass. Declaration public double Volume() Returns Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Material.html": {
    "href": "api/Elements.Material.html",
    "title": "Class Material | Hypar Docs",
    "keywords": "Class Material A material. Inheritance System.Object Element Material Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Material : Element, INotifyPropertyChanged Constructors Material(Color, Double, Double, Boolean, String, Boolean, Guid, String) Declaration public Material(Color color, double specularFactor, double glossinessFactor, bool unlit, string texture, bool doubleSided, Guid id, string name) Parameters Type Name Description Color color System.Double specularFactor System.Double glossinessFactor System.Boolean unlit System.String texture System.Boolean doubleSided System.Guid id System.String name Material(String, Color, Double, Double, String, Boolean, Boolean, Guid) Construct a material. Declaration public Material(string name, Color color, double specularFactor = 0.1, double glossinessFactor = 0.1, string texture = null, bool unlit = false, bool doubleSided = false, Guid id = default(Guid)) Parameters Type Name Description System.String name The identifier of the material. Identifiers should be unique within a model. Color color The RGBA color of the material. System.Double specularFactor The specular component of the color. Between 0.0 and 1.0. System.Double glossinessFactor The glossiness component of the color. Between 0.0 and 1.0. System.String texture A relative path to a jpg or png image file to be used as a texture. System.Boolean unlit Is this material affected by lights? System.Boolean doubleSided Is this material to be rendered from both sides? System.Guid id The id of the material. Material(String, Guid) Construct a material. Declaration public Material(string name, Guid id = default(Guid)) Parameters Type Name Description System.String name The name of the material. System.Guid id The id of the material. Properties Color The material's color. Declaration public Color Color { get; set; } Property Value Type Description Color DoubleSided Is this material to be rendered from both sides? Declaration public bool DoubleSided { get; set; } Property Value Type Description System.Boolean GlossinessFactor The glossiness factor between 0.0 and 1.0. Declaration public double GlossinessFactor { get; set; } Property Value Type Description System.Double SpecularFactor The specular factor between 0.0 and 1.0. Declaration public double SpecularFactor { get; set; } Property Value Type Description System.Double Texture A relative file path to an image file to be used as a texture. Declaration public string Texture { get; set; } Property Value Type Description System.String Unlit Is this material affected by lights? Declaration public bool Unlit { get; set; } Property Value Type Description System.Boolean Methods Equals(Object) Is this material equal to the provided material? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) GetHashCode() Get the hash code for the material. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.MeshElement.html": {
    "href": "api/Elements.MeshElement.html",
    "title": "Class MeshElement | Hypar Docs",
    "keywords": "Class MeshElement An element whose representation is provided by a mesh. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_MeshElement.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var mesh = new Mesh(); var gridSize = 10; for (var u = 0; u < gridSize; u += 1) { for (var v = 0; v < gridSize; v += 1) { var sinu = Math.Sin(-Math.PI + 2 * ((double)u / (double)gridSize * Math.PI)); var sinv = Math.Sin(-Math.PI + 2 * ((double)v / (double)gridSize * Math.PI)); var z = sinu + sinv; var vertex = new Vertex(new Vector3(u, v, z), color: Colors.Mint); mesh.AddVertex(vertex); if (u > 0 && v > 0) { var index = u * gridSize + v; var a = mesh.Vertices[index]; var b = mesh.Vertices[index - gridSize]; var c = mesh.Vertices[index - 1]; var d = mesh.Vertices[index - gridSize - 1]; var tri1 = new Triangle(a, b, c); var tri2 = new Triangle(c, b, d); mesh.AddTriangle(tri1); mesh.AddTriangle(tri2); } } } mesh.ComputeNormals(); var meshElement = new MeshElement(mesh, new Material(\"Lime\", Colors.Lime)); Inheritance System.Object Element GeometricElement MeshElement ImportMeshElement Topography Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.UpdateRepresentations() GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class MeshElement : GeometricElement, INotifyPropertyChanged, ITessellate Constructors MeshElement(Mesh, Material, Transform, Boolean, Guid, String) Construct an import mesh element. Declaration public MeshElement(Mesh mesh, Material material = null, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Mesh mesh The element's mesh. Material material The element's material. Transform transform The element's transform. System.Boolean isElementDefinition Is this element a definition? System.Guid id The element's id. System.String name The element's name. Fields _mesh The mesh. Declaration protected Mesh _mesh Field Value Type Description Mesh Properties Mesh The element's mesh. Declaration public Mesh Mesh { get; } Property Value Type Description Mesh Methods Tessellate(ref Mesh, Transform, Color) Tessellate the element. Declaration public void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh Transform transform Color color Implements System.ComponentModel.INotifyPropertyChanged ITessellate"
  },
  "api/Elements.Model.html": {
    "href": "api/Elements.Model.html",
    "title": "Class Model | Hypar Docs",
    "keywords": "Class Model A container of elements. Inheritance System.Object Model Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Model Constructors Model() Construct an empty model. Declaration public Model() Model(Position, Transform, IDictionary<Guid, Element>) Declaration public Model(Position origin, Transform transform, IDictionary<Guid, Element> elements) Parameters Type Name Description Position origin Transform transform System.Collections.Generic.IDictionary < System.Guid , Element > elements Model(Transform, IDictionary<Guid, Element>) Construct a model. Declaration public Model(Transform transform, IDictionary<Guid, Element> elements) Parameters Type Name Description Transform transform The model's transform. System.Collections.Generic.IDictionary < System.Guid , Element > elements The model's elements. Properties Elements A collection of Elements keyed by their identifiers. Declaration public IDictionary<Guid, Element> Elements { get; set; } Property Value Type Description System.Collections.Generic.IDictionary < System.Guid , Element > Origin The origin of the model. Declaration [Obsolete(\"Use Transform instead.\")] public Position Origin { get; set; } Property Value Type Description Position Transform The transform of the model. Declaration public Transform Transform { get; set; } Property Value Type Description Transform Methods AddElement(Element, Boolean) Add an element to the model. This operation recursively searches the element's properties for element sub-properties and adds those elements to the elements dictionary before adding the element itself. Declaration public void AddElement(Element element, bool gatherSubElements = true) Parameters Type Name Description Element element The element to add to the model. System.Boolean gatherSubElements Should sub-elements in properties be added to the model's elements collection? AddElements(Element[]) Add elements to the model. Declaration public void AddElements(params Element[] elements) Parameters Type Name Description Element [] elements The elements to add to the model. AddElements(IEnumerable<Element>, Boolean) Add a collection of elements to the model. Declaration public void AddElements(IEnumerable<Element> elements, bool gatherSubElements = true) Parameters Type Name Description System.Collections.Generic.IEnumerable < Element > elements The elements to add to the model. System.Boolean gatherSubElements Should sub-elements in properties be added to the model's elements collection? AllElementsOfType<T>() Get all entities of the specified Type. Declaration public IEnumerable<T> AllElementsOfType<T>() Returns Type Description System.Collections.Generic.IEnumerable <T> A collection of elements of the specified type. Type Parameters Name Description T The Type of element to return. FromJson(String, Boolean) Declaration public static Model FromJson(string json, bool forceTypeReload = false) Parameters Type Name Description System.String json System.Boolean forceTypeReload Returns Type Description Model FromJson(String, out List<String>, Boolean) Deserialize a model from JSON. Declaration public static Model FromJson(string json, out List<string> errors, bool forceTypeReload = false) Parameters Type Name Description System.String json The JSON representing the model. System.Collections.Generic.List < System.String > errors A collection of deserialization errors. System.Boolean forceTypeReload Option to force reloading the inernal type cache. Use if you add types dynamically in your code. Returns Type Description Model GetElementByName<T>(String) Get the first entity with the specified name. Declaration public T GetElementByName<T>(string name) where T : Element Parameters Type Name Description System.String name Returns Type Description T An entity or null if no entity can be found with the provided name. Type Parameters Name Description T GetElementOfType<T>(Guid) Get an entity by id from the Model. Declaration public T GetElementOfType<T>(Guid id) where T : Element Parameters Type Name Description System.Guid id The identifier of the element. Returns Type Description T An entity or null if no entity can be found with the provided id. Type Parameters Name Description T ToJson(Boolean) Serialize the model to JSON. Declaration public string ToJson(bool indent = false) Parameters Type Name Description System.Boolean indent Returns Type Description System.String Extension Methods GltfExtensions.ToGlTF(Model, String, Boolean, Boolean) GltfExtensions.ToGlTF(Model) GltfExtensions.ToBase64String(Model, Boolean)"
  },
  "api/Elements.ModelCurve.html": {
    "href": "api/Elements.ModelCurve.html",
    "title": "Class ModelCurve | Hypar Docs",
    "keywords": "Class ModelCurve A curve which is visible in 3D. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ModelCurve.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // A line var line = new Line(Vector3.Origin, new Vector3(5, 5, 5)); // An arc var arc = new Arc(Vector3.Origin, 2.0, 45.0, 135.0); // A polygon var pline = Polygon.L(2, 2, 0.5); // A Bezier var a = Vector3.Origin; var b = new Vector3(5, 0, 1); var c = new Vector3(5, 5, 2); var d = new Vector3(0, 5, 3); var e = new Vector3(0, 0, 4); var f = new Vector3(5, 0, 5); var ctrlPts = new List<Vector3> { a, b, c, d, e, f }; var bezier = new Bezier(ctrlPts); var lineModelCurve = new ModelCurve(line, new Material(\"Red\", Colors.Red)); var arcModelCurve = new ModelCurve(arc, new Material(\"Orange\", Colors.Orange), new Transform(5, 0, 0)); var plineModelCurve = new ModelCurve(pline, new Material(\"Purple\", Colors.Purple), new Transform(10, 0, 0)); var bezierModelCurve = new ModelCurve(bezier, new Material(\"Green\", Colors.Green), new Transform(15, 0, 0)); Inheritance System.Object Element GeometricElement ModelCurve Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.UpdateRepresentations() GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ModelCurve : GeometricElement, INotifyPropertyChanged Constructors ModelCurve(Curve, Material, Transform, Representation, Boolean, Guid, String) Create a model curve. Declaration public ModelCurve(Curve curve, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Curve curve The curve. Material material The material. Specular and glossiness components will be ignored. Transform transform The model curve's transform. Representation representation The curve's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the model curve. System.String name The name of the model curve. Properties Curve The curve. Declaration public Curve Curve { get; set; } Property Value Type Description Curve Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.ModelCurveExtensions.html": {
    "href": "api/Elements.ModelCurveExtensions.html",
    "title": "Class ModelCurveExtensions | Hypar Docs",
    "keywords": "Class ModelCurveExtensions Extension methods for model curves. Inheritance System.Object ModelCurveExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class ModelCurveExtensions Methods ToModelCurves(Transform, Transform) Convert a transform to a set of model curves. Declaration public static IList<ModelCurve> ToModelCurves(this Transform t, Transform context = null) Parameters Type Name Description Transform t The transform to convert. Transform context An optional transform in which these curves should be drawn. Returns Type Description System.Collections.Generic.IList < ModelCurve >"
  },
  "api/Elements.ModelPoints.html": {
    "href": "api/Elements.ModelPoints.html",
    "title": "Class ModelPoints | Hypar Docs",
    "keywords": "Class ModelPoints A collection of points which are visible in 3D. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ModelPoints.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create some point locations. var pts = new List<Vector3>(); for (var x = 0; x < 25; x++) { for (var y = 0; y < 25; y++) { for (var z = 0; z < 25; z++) { // Add points to the object. pts.Add(new Vector3(x, y, z)); } } } // Create a model points object. var pink = new Material(\"pink\", Colors.Pink); var modelPoints = new ModelPoints(pts, pink); Inheritance System.Object Element GeometricElement ModelPoints Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.UpdateRepresentations() GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ModelPoints : GeometricElement, INotifyPropertyChanged Constructors ModelPoints(IList<Vector3>, Material, Transform, Boolean, Guid, String) Create a collection of points. Declaration public ModelPoints(IList<Vector3> locations = null, Material material = null, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > locations The locations of the points. Material material The material. Specular and glossiness components will be ignored. Transform transform The model curve's transform. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the model curve. System.String name The name of the model curve. Properties Locations The locations of the points. Declaration public IList<Vector3> Locations { get; set; } Property Value Type Description System.Collections.Generic.IList < Vector3 > Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Opening.html": {
    "href": "api/Elements.Opening.html",
    "title": "Class Opening | Hypar Docs",
    "keywords": "Class Opening A polygonal opening. An opening's placement is defined by the x and y coordinates. The direction of the opening corresponds to the +Z axis of the transform. Inheritance System.Object Element GeometricElement Opening Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Opening : GeometricElement, INotifyPropertyChanged Constructors Opening(Polygon, Double, Double, Transform, Representation, Boolean, Guid, String) Create an opening. Declaration public Opening(Polygon perimeter, double depthFront = 1, double depthBack = 1, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Double depthFront System.Double depthBack Transform transform Representation representation System.Boolean isElementDefinition System.Guid id System.String name Properties DepthBack The depth of the opening along the opening's -Z axis. Declaration public double DepthBack { get; set; } Property Value Type Description System.Double DepthFront The depth of the opening along the opening's +Z axis. Declaration public double DepthFront { get; set; } Property Value Type Description System.Double Perimeter The perimeter of the opening. Declaration public Polygon Perimeter { get; set; } Property Value Type Description Polygon Profile The profile of the opening. Declaration [Obsolete(\"Use perimeter instead.\")] public Profile Profile { get; set; } Property Value Type Description Profile Methods UpdateRepresentations() Update representations Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Panel.html": {
    "href": "api/Elements.Panel.html",
    "title": "Class Panel | Hypar Docs",
    "keywords": "Class Panel A zero-thickness planar element defined by a perimeter. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Panel.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(0,0,0); var b = new Vector3(1,0,0); var c = new Vector3(1,0,1); var d = new Vector3(0,0,1); // Create a panel. var panel = new Panel(new Polygon(new []{a,b,c,d}), BuiltInMaterials.Glass); Inheritance System.Object Element GeometricElement Panel Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Panel : GeometricElement, INotifyPropertyChanged Constructors Panel(Polygon, Material, Transform, Representation, Boolean, Guid, String) Create a panel. Declaration public Panel(Polygon perimeter, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The perimeter of the panel. Material material The panel's material Transform transform The panel's transform. Representation representation The panel's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the panel. System.String name The name of the panel. Properties Perimeter The perimeter of the panel. Declaration public Polygon Perimeter { get; } Property Value Type Description Polygon Methods Area() The panel's area. Declaration public double Area() Returns Type Description System.Double Normal() The normal of the panel, defined using the first 3 vertices in the location. Declaration public Vector3 Normal() Returns Type Description Vector3 The normal vector of the panel. UpdateRepresentations() Update representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Serialization.glTF.GltfBufferExtensions.html": {
    "href": "api/Elements.Serialization.glTF.GltfBufferExtensions.html",
    "title": "Class GltfBufferExtensions | Hypar Docs",
    "keywords": "Class GltfBufferExtensions Extensions for glTF serialization. Inheritance System.Object GltfBufferExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization.glTF Assembly : Hypar.Elements.dll Syntax public static class GltfBufferExtensions"
  },
  "api/Elements.Serialization.glTF.GltfExtensions.html": {
    "href": "api/Elements.Serialization.glTF.GltfExtensions.html",
    "title": "Class GltfExtensions | Hypar Docs",
    "keywords": "Class GltfExtensions Extensions for glTF serialization. Inheritance System.Object GltfExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization.glTF Assembly : Hypar.Elements.dll Syntax public static class GltfExtensions Methods ToBase64String(Model, Boolean) Serialize the model to a base64 encoded string. Declaration public static string ToBase64String(this Model model, bool drawEdges = false) Parameters Type Name Description Model model System.Boolean drawEdges Returns Type Description System.String A Base64 string representing the model. ToGlTF(Model) Serialize the model to a byte array. Declaration public static byte[] ToGlTF(this Model model) Parameters Type Name Description Model model The model to serialize. Returns Type Description System.Byte [] A byte array representing the model. ToGlTF(Model, String, Boolean, Boolean) Serialize the model to a gltf file on disk. If there is no geometry, an empty GLTF will still be produced. Declaration public static void ToGlTF(this Model model, string path, bool useBinarySerialization = true, bool drawEdges = false) Parameters Type Name Description Model model The model to serialize. System.String path The output path. System.Boolean useBinarySerialization Should binary serialization be used? System.Boolean drawEdges Should the solid edges be written to the gltf?"
  },
  "api/Elements.Serialization.glTF.html": {
    "href": "api/Elements.Serialization.glTF.html",
    "title": "Namespace Elements.Serialization.glTF | Hypar Docs",
    "keywords": "Namespace Elements.Serialization.glTF Classes GltfBufferExtensions Extensions for glTF serialization. GltfExtensions Extensions for glTF serialization."
  },
  "api/Elements.Serialization.JSON.html": {
    "href": "api/Elements.Serialization.JSON.html",
    "title": "Namespace Elements.Serialization.JSON | Hypar Docs",
    "keywords": "Namespace Elements.Serialization.JSON Classes JsonInheritanceConverter MeshConverter Triangle converter."
  },
  "api/Elements.Serialization.JSON.JsonInheritanceConverter.html": {
    "href": "api/Elements.Serialization.JSON.JsonInheritanceConverter.html",
    "title": "Class JsonInheritanceConverter | Hypar Docs",
    "keywords": "Class JsonInheritanceConverter Inheritance System.Object JsonInheritanceConverter Namespace : Elements.Serialization.JSON Assembly : Hypar.Elements.dll Syntax public class JsonInheritanceConverter : Newtonsoft.Json.JsonConverter Constructors JsonInheritanceConverter() Declaration public JsonInheritanceConverter() JsonInheritanceConverter(String) Declaration public JsonInheritanceConverter(string discriminator) Parameters Type Name Description System.String discriminator Properties CanRead Declaration public override bool CanRead { get; } Property Value Type Description System.Boolean CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean Elements Declaration public static Dictionary<Guid, Element> Elements { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Guid , Element > ElementwiseSerialization Declaration public static bool ElementwiseSerialization { get; set; } Property Value Type Description System.Boolean Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description System.Type objectType Returns Type Description System.Boolean ReadJson(Newtonsoft.Json.JsonReader, Type, Object, Newtonsoft.Json.JsonSerializer) Declaration public override object ReadJson(Newtonsoft.Json.JsonReader reader, Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonReader reader System.Type objectType System.Object existingValue Newtonsoft.Json.JsonSerializer serializer Returns Type Description System.Object WriteJson(Newtonsoft.Json.JsonWriter, Object, Newtonsoft.Json.JsonSerializer) Declaration public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonWriter writer System.Object value Newtonsoft.Json.JsonSerializer serializer"
  },
  "api/Elements.Serialization.JSON.MeshConverter.html": {
    "href": "api/Elements.Serialization.JSON.MeshConverter.html",
    "title": "Class MeshConverter | Hypar Docs",
    "keywords": "Class MeshConverter Triangle converter. Inheritance System.Object MeshConverter Namespace : Elements.Serialization.JSON Assembly : Hypar.Elements.dll Syntax public class MeshConverter : JsonConverter Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description System.Type objectType Returns Type Description System.Boolean ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description JsonReader reader System.Type objectType System.Object existingValue JsonSerializer serializer Returns Type Description System.Object WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description JsonWriter writer System.Object value JsonSerializer serializer"
  },
  "api/Elements.Space.html": {
    "href": "api/Elements.Space.html",
    "title": "Class Space | Hypar Docs",
    "keywords": "Class Space An extruded region of occupiable space. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Space.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a space. var a = new Vector3(); var b = new Vector3(30, 10); var c = new Vector3(20, 50); var d = new Vector3(-10, 5); var profile = new Profile(new Polygon(new[]{a,b,c,d})); var space = new Space(profile, 10); Inheritance System.Object Element GeometricElement Space Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Space : GeometricElement, INotifyPropertyChanged Constructors Space(Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a space. Declaration public Space(Profile profile, double height, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The profile of the space. System.Double height The height of the space. Material material The space's material. Transform transform The space's transform. Representation representation The space's represenation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the space. System.String name The name of the space. Space(Solid, Transform, Material, Boolean, Guid, String) Construct a space from a solid. Declaration public Space(Solid geometry, Transform transform = null, Material material = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Solid geometry The solid which will be used to define the space. Transform transform The transform of the space. Material material The space's material. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the space. System.String name The name of the space. Properties Height The space's height. Declaration public double Height { get; set; } Property Value Type Description System.Double Profile The profile of the space. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Methods Area() The spaces's area. Declaration public double Area() Returns Type Description System.Double ProfileTransformed() Get the profile of the space transformed by the space's transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() The spaces's volume. Declaration public double Volume() Returns Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Spatial.EvenDivisionMode.html": {
    "href": "api/Elements.Spatial.EvenDivisionMode.html",
    "title": "Enum EvenDivisionMode | Hypar Docs",
    "keywords": "Enum EvenDivisionMode Describe how a target length should be treated Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum EvenDivisionMode Fields Name Description Nearest Closest match for a target length, can be greater or smaller in practice. RoundDown Round down the count — Only divide into segments longer than the target length RoundUp Round up the count — Only divide into segments shorter than the target length"
  },
  "api/Elements.Spatial.FixedDivisionMode.html": {
    "href": "api/Elements.Spatial.FixedDivisionMode.html",
    "title": "Enum FixedDivisionMode | Hypar Docs",
    "keywords": "Enum FixedDivisionMode Different ways to handle the \"remainder\" when dividing an arbitrary length by a fixed size Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum FixedDivisionMode Fields Name Description RemainderAtBothEnds Take the remainder and split it across both ends of the grid RemainderAtEnd Locate the remainder at the end of the grid RemainderAtStart Locate the remainder at the start of the grid RemainderNearMiddle Locate the remainder at or near the middle of the grid."
  },
  "api/Elements.Spatial.Grid1d.html": {
    "href": "api/Elements.Spatial.Grid1d.html",
    "title": "Class Grid1d | Hypar Docs",
    "keywords": "Class Grid1d Represents a \"1-dimensional grid\", akin to a number line that can be subdivided. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Spatial_Grid1d.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a 1d Grid from a line var line = new Line(new Vector3(5, 0, 0), new Vector3(60, 0, 0)); var grid = new Grid1d(line); // Divide the grid into sections of length 10, and leave remainders // at both ends grid.DivideByFixedLength(10, FixedDivisionMode.RemainderAtBothEnds); // Take the second grid segment and subdivide it // into 5 equal length segments grid[1].DivideByCount(5); // Take the third grid segment and subdivide it into // segments of approximate length 3 grid[2].DivideByApproximateLength(3); // Take the fourth grid segment and subdivide it by a repeating pattern var pattern = new[] { 1.0, 1.5 }; grid[3].DivideByPattern(pattern); // Retrieve all bottom-level cells. // Note that grid.Cells gets the top-level cells only, and // grid.GetCells() recursively gets the bottom-level individual cells. var cells = grid.GetCells(); // Get lines representing each cell var lines = cells.Select(c => c.GetCellGeometry()).OfType<Line>(); // Create walls from lines, and assign a random color material List<Wall> walls = new List<Wall>(); var rand = new Random(); foreach (var wallLine in lines) { var color = new Color(rand.NextDouble(), rand.NextDouble(), rand.NextDouble(), 1.0); walls.Add(new StandardWall(wallLine, 0.1, 3.0, new Material(color, 0, 0, false, null, false, Guid.NewGuid(), color.ToString()))); } // Create rectangles from top-level grid cells var topLevelCells = grid.Cells.Select(c => c.GetCellGeometry()).OfType<Line>(); var cellRects = new List<ModelCurve>(); foreach (var topLevelCell in topLevelCells) { var rect = Polygon.Rectangle(topLevelCell.Start - new Vector3(0, 2, 0), topLevelCell.End + new Vector3(0, 2, 0)); cellRects.Add(new ModelCurve(rect)); } Inheritance System.Object Grid1d Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public class Grid1d Constructors Grid1d(Domain1d) Construct a 1D grid from a numerical domain. The geometry will be assumed to lie along the X axis. Declaration public Grid1d(Domain1d domain) Parameters Type Name Description Domain1d domain The 1-dimensional domain for the grid extents. Grid1d(Curve) Construct a 1D grid from a curve. Declaration public Grid1d(Curve curve) Parameters Type Name Description Curve curve The curve from which to generate the grid. Grid1d(Grid1d) Construct a 1D Grid from another 1D Grid Declaration public Grid1d(Grid1d other) Parameters Type Name Description Grid1d other Grid1d(Double) Default constructor with optional length parameter Declaration public Grid1d(double length = 1) Parameters Type Name Description System.Double length Length of the grid domain Properties Cells Child cells of this Grid. If null, this Grid is a complete cell with no subdivisions. Declaration public List<Grid1d> Cells { get; } Property Value Type Description System.Collections.Generic.List < Grid1d > Domain Numerical domain of this Grid Declaration public Domain1d Domain { get; } Property Value Type Description Domain1d IsSingleCell Returns true if this 1D Grid has no subdivisions / sub-grids. Declaration public bool IsSingleCell { get; } Property Value Type Description System.Boolean Item[Int32] Retrieve a cell by index Declaration public Grid1d this[int i] { get; } Parameters Type Name Description System.Int32 i The index Property Value Type Description Grid1d A Grid1d representing the selected cell/segment. Type An optional type designation for this cell. Declaration public string Type { get; set; } Property Value Type Description System.String Methods ClosestPosition(Vector3) Get the position along the grid's domain closest to a supplied point. Declaration public double ClosestPosition(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double DivideByApproximateLength(Double, EvenDivisionMode) Divide a grid by an approximate length. The length will be adjusted to generate whole-number subdivisions, governed by an optional DivisionMode. Declaration public void DivideByApproximateLength(double targetLength, EvenDivisionMode divisionMode = EvenDivisionMode.Nearest) Parameters Type Name Description System.Double targetLength The approximate length by which to divide the grid. EvenDivisionMode divisionMode Whether to permit any size cell, or only larger or smaller cells by rounding up or down. DivideByCount(Int32) Divide the grid into N even subdivisions. Grids that are already subdivided will fail. Declaration public void DivideByCount(int n) Parameters Type Name Description System.Int32 n Number of subdivisions DivideByFixedLength(Double, FixedDivisionMode, Int32) Divide a grid by constant length subdivisions, with a variable division mode to control how leftover space is handled. Declaration public void DivideByFixedLength(double length, FixedDivisionMode divisionMode = FixedDivisionMode.RemainderAtEnd, int sacrificialPanels = 0) Parameters Type Name Description System.Double length The division length FixedDivisionMode divisionMode How to handle leftover / partial remainder panels System.Int32 sacrificialPanels How many full length panels to sacrifice to make remainder panels longer. DivideByFixedLengthFromPoint(Double, Vector3) Divide a grid by constant length subdivisions, starting from a point location. Declaration public void DivideByFixedLengthFromPoint(double length, Vector3 point) Parameters Type Name Description System.Double length The length of subdivisions Vector3 point The point at which to begin subdividing. DivideByFixedLengthFromPosition(Double, Double) Divide a grid by constant length subdivisions, starting from a position. Declaration public void DivideByFixedLengthFromPosition(double length, double position) Parameters Type Name Description System.Double length The length of subdivisions System.Double position The position along the domain at which to begin subdividing. DivideByPattern(IList<Double>, PatternMode, FixedDivisionMode) Divide a grid by a pattern of lengths. Type names will be automatically generated, repetition will be governed by PatternMode, and remainder handling will be governed by DivisionMode. Declaration public void DivideByPattern(IList<double> lengthPattern, PatternMode patternMode = PatternMode.Cycle, FixedDivisionMode divisionMode = FixedDivisionMode.RemainderAtEnd) Parameters Type Name Description System.Collections.Generic.IList < System.Double > lengthPattern A pattern of lengths to apply to the grid PatternMode patternMode How to apply/repeat the pattern FixedDivisionMode divisionMode How to handle leftover/remainder length DivideByPattern(IList<(String typeName, Double length)>, PatternMode, FixedDivisionMode) Divide a grid by a pattern of named lengths. Repetition will be governed by PatternMode, and remainder handling will be governed by DivisionMode. Declaration public void DivideByPattern(IList<(string typeName, double length)> lengthPattern, PatternMode patternMode = PatternMode.Cycle, FixedDivisionMode divisionMode = FixedDivisionMode.RemainderAtEnd) Parameters Type Name Description System.Collections.Generic.IList < System.ValueTuple < System.String , System.Double >> lengthPattern A pattern of lengths to apply to the grid PatternMode patternMode How to apply/repeat the pattern FixedDivisionMode divisionMode How to handle leftover/remainder length FindCellAtPosition(Double) Retrieve the grid cell (as a Grid1d) at a length along the domain. Declaration public Grid1d FindCellAtPosition(double pos) Parameters Type Name Description System.Double pos The position in the grid's domain to find Returns Type Description Grid1d The cell at this position, if found, or this grid if it is a single cell. GetCellGeometry() Retrieve geometric representation of a cell (currently just a line) Declaration public Curve GetCellGeometry() Returns Type Description Curve A curve representing the extents of this grid / cell. GetCells() Retrieve all grid segment cells recursively. For just top-level cells, get the Cells property. Declaration public List<Grid1d> GetCells() Returns Type Description System.Collections.Generic.List < Grid1d > A list of all the bottom-level cells / child cells of this grid. GetCellSeparators(Boolean) Get the points at the ends and in-between all cells. Declaration public List<Vector3> GetCellSeparators(bool recursive = false) Parameters Type Name Description System.Boolean recursive If true, separators will be retrieved from child cells as well. Returns Type Description System.Collections.Generic.List < Vector3 > A list of Vector3d points representing the boundaries between cells. SplitAtOffset(Double, Boolean, Boolean) Split a cell at a relative position measured from its domain start or end. Declaration public void SplitAtOffset(double position, bool fromEnd = false, bool ignoreOutsideDomain = false) Parameters Type Name Description System.Double position The relative position at which to split. System.Boolean fromEnd If true, measure the position from the end rather than the start System.Boolean ignoreOutsideDomain If true, splits at offsets outside the domain will be silently ignored. SplitAtOffsets(IEnumerable<Double>, Boolean) Split a cell at a list of relative positions measured from its domain start or end. Declaration public void SplitAtOffsets(IEnumerable<double> positions, bool fromEnd = false) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > positions The relative positions at which to split. System.Boolean fromEnd If true, measure the position from the end rather than the start SplitAtParameter(Double) Split the grid at a normalized parameter from 0 to 1 along its domain. Declaration public void SplitAtParameter(double t) Parameters Type Name Description System.Double t The parameter at which to split. SplitAtParameters(IEnumerable<Double>) Split the grid at a list of normalized parameters from 0 to 1 along its domain. Declaration public void SplitAtParameters(IEnumerable<double> parameters) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > parameters A list of parameters at which to split the grid. SplitAtPoint(Vector3) Split the grid at a point in world space. Note that for curved grids an approximate point will be used. Declaration public void SplitAtPoint(Vector3 point) Parameters Type Name Description Vector3 point SplitAtPoints(IEnumerable<Vector3>) Split the grid at points in world space. Note that for curved grids an approximate point will be used. Declaration public void SplitAtPoints(IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The points at which to split. SplitAtPosition(Double) Split the grid at a fixed position from the start or end Declaration public void SplitAtPosition(double position) Parameters Type Name Description System.Double position The length along the grid at which to split. SplitAtPositions(IEnumerable<Double>) Split the grid at a list of fixed positions from the start or end Declaration public void SplitAtPositions(IEnumerable<double> positions) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > positions The lengths along the grid at which to split."
  },
  "api/Elements.Spatial.Grid2d.html": {
    "href": "api/Elements.Spatial.Grid2d.html",
    "title": "Class Grid2d | Hypar Docs",
    "keywords": "Class Grid2d Represents a 2-dimensional grid which can be subdivided var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Spatial_Grid2d.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a 2d grid that's 40 x 30 in size var grid = new Grid2d(40, 30); // Access the U and V axes directly and use 1d subdivision methods on them grid.U.DivideByFixedLength(7, FixedDivisionMode.RemainderAtBothEnds); grid.V.DivideByPattern(new[] { 2.0, 5.0 }); // Get a row by index var fifthRow = grid.GetRowAtIndex(4); // Divide U axis of all cells in row into panels of approximate width 1 fifthRow.ForEach(c => c.U.DivideByApproximateLength(1)); // Get a cell by u, v indices var cell = grid[1, 1]; // Divide the cell in the V direction cell.V.DivideByCount(4); // Create a floor from the entire grid's boundary var floor = new Floor(new Profile((Polygon)grid.GetCellGeometry()), 0.5, new Transform(0, 0, -0.51)); // Create model curves from all subdivided cells of the grid var modelCurves = grid.GetCells().Select(c => new ModelCurve(c.GetCellGeometry())); Inheritance System.Object Grid2d Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public class Grid2d Constructors Grid2d() Construct a Grid2d with default domain (0,0) to (1,1) Declaration public Grid2d() Grid2d(Polygon, Transform) Create a Grid2d from a polygon and optional Transform. If the plane is null or not supplied, the identity transform will be used for the grid origin and orientation. Currently only transforms parallel to the supplied polygons are supported. The polygon's bounding box parallel to the supplied transform will be used as the grid extents. Declaration public Grid2d(Polygon boundary, Transform transform = null) Parameters Type Name Description Polygon boundary The external boundary of this grid system. Transform transform A transform representing the alignment of the grid. Grid2d(Grid1d, Grid1d) Construct a Grid2d from two Grid1ds in the U and V directions Declaration public Grid2d(Grid1d u, Grid1d v) Parameters Type Name Description Grid1d u Grid1d v Grid2d(Grid2d) Construct a Grid2d from another Grid2d Declaration public Grid2d(Grid2d other) Parameters Type Name Description Grid2d other Grid2d(Grid2d, Grid1d, Grid1d) Construct a Grid2d using another Grid2d as the base, but with different Grid1ds as its axes. Declaration public Grid2d(Grid2d other, Grid1d u, Grid1d v) Parameters Type Name Description Grid2d other The Grid2d to base this one on. Grid1d u The Grid1d representing the U Axis. Grid1d v The Grid1d representing the V Axis. Grid2d(IList<Polygon>, Transform) Create a Grid2d from a list of boundary polygons and an optional transform. If the transform is null or not supplied, a transform will be generated automatically from the boundaries' normal. Currently only transforms parallel to the supplied polygons are supported. The polygons' bounding box parallel to the supplied transform will be used as the grid extents. Declaration public Grid2d(IList<Polygon> boundaries, Transform transform = null) Parameters Type Name Description System.Collections.Generic.IList < Polygon > boundaries The external boundaries of this grid system. Transform transform A transform representing the alignment of the grid. Grid2d(Double, Double) Construct a Grid2d with specified dimensions for the U and V direction. Declaration public Grid2d(double uDimension, double vDimension) Parameters Type Name Description System.Double uDimension The size along the U axis System.Double vDimension The size along the V axis Properties Cells Child cells of this Grid. If null, this Grid is a complete cell with no subdivisions. Declaration public List<List<Grid2d>> Cells { get; } Property Value Type Description System.Collections.Generic.List < System.Collections.Generic.List < Grid2d >> CellsFlat A flat list of all the top-level cells in this grid. To get child cells as well, use Grid2d.GetCells() instead. Declaration public List<Grid2d> CellsFlat { get; } Property Value Type Description System.Collections.Generic.List < Grid2d > IsSingleCell Returns true if this 2D Grid has no subdivisions / sub-grids. Declaration public bool IsSingleCell { get; } Property Value Type Description System.Boolean Item[Int32, Int32] Retrieve a single top-level cell at the specified [u,v] indices. Declaration public Grid2d this[int u, int v] { get; } Parameters Type Name Description System.Int32 u The U index System.Int32 v The V index Property Value Type Description Grid2d The cell at these indices Type An optional type designation for this cell. Declaration public string Type { get; set; } Property Value Type Description System.String U The 1d Grid along the U dimension Declaration public Grid1d U { get; } Property Value Type Description Grid1d V The 1d grid along the V dimension Declaration public Grid1d V { get; } Property Value Type Description Grid1d Methods FindCellAtPosition(Double, Double) Retrieve the grid cell (as a Grid1d) at a length along the U and V domains. Declaration public Grid2d FindCellAtPosition(double uPosition, double vPosition) Parameters Type Name Description System.Double uPosition U Position System.Double vPosition V Position Returns Type Description Grid2d GetCellAtIndices(Int32, Int32) Retrieve a single top-level cell at the specified [u,v] indices. Declaration public Grid2d GetCellAtIndices(int u, int v) Parameters Type Name Description System.Int32 u The U index System.Int32 v The V index Returns Type Description Grid2d The cell at these indices GetCellGeometry() Get a rectangular polygon representing this untrimmed cell boundary. Declaration public Curve GetCellGeometry() Returns Type Description Curve A rectangle representing this cell in world coordinates. GetCellNodes() Get the points at the corners of all grid cells. /// Declaration public List<Vector3> GetCellNodes() Returns Type Description System.Collections.Generic.List < Vector3 > GetCells() Recursively retrieve all bottom-level cells from this grid. Declaration public List<Grid2d> GetCells() Returns Type Description System.Collections.Generic.List < Grid2d > A list of all bottom-level cells in the grid. GetCellSeparators(GridDirection, Boolean) Get the top-level lines separating cells from one another. Declaration public List<ICurve> GetCellSeparators(GridDirection direction, bool trim = false) Parameters Type Name Description GridDirection direction The grid direction in which you want to get separators. System.Boolean trim Whether or not to trim cell separators with the trimmed cell boundary Returns Type Description System.Collections.Generic.List < ICurve > The lines between cells, running parallel to the grid direction selected. GetColumnAtIndex(Int32) Get a list of all the top-level cells at a given u index. Declaration public List<Grid2d> GetColumnAtIndex(int u) Parameters Type Name Description System.Int32 u The u index Returns Type Description System.Collections.Generic.List < Grid2d > A list of the column of all cells with this u index. GetRowAtIndex(Int32) Get a list of all the top-level cells at a given v index. Declaration public List<Grid2d> GetRowAtIndex(int v) Parameters Type Name Description System.Int32 v The v index Returns Type Description System.Collections.Generic.List < Grid2d > A list of the row of all cells with this v index. GetTrimmedCellGeometry() Get a list of polygons representing this cell boundary, trimmed by any polygon boundary. If the cell falls completely outside of the boundary, an empty array will be returned. Declaration public Curve[] GetTrimmedCellGeometry() Returns Type Description Curve [] Curves representing this cell in world coordinates. IsTrimmed() Test if the cell is trimmed by a boundary. Declaration public bool IsTrimmed() Returns Type Description System.Boolean True if the cell is trimmed by the grid boundary. SplitAtPoint(Vector3) Split the grid at a point in world space Declaration public void SplitAtPoint(Vector3 point) Parameters Type Name Description Vector3 point The point at which to split. SplitAtPoints(IEnumerable<Vector3>) Split the grid at points in world space Declaration public void SplitAtPoints(IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The points at which to split SplitAtPosition(Vector3) Split the grid at a position in the grid's coordinate system Declaration public void SplitAtPosition(Vector3 position) Parameters Type Name Description Vector3 position The position at which to split, with X = U and Y = V. SplitAtPosition(Double, Double) Split the grid at a position in the grid's coordinate system Declaration public void SplitAtPosition(double uPosition, double vPosition) Parameters Type Name Description System.Double uPosition The U position System.Double vPosition The V position SplitAtPositions(IEnumerable<Vector3>) Split the grid at positions in the grid's coordinate system Declaration public void SplitAtPositions(IEnumerable<Vector3> positions) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > positions The positions at which to split, with X = U and Y = V."
  },
  "api/Elements.Spatial.GridDirection.html": {
    "href": "api/Elements.Spatial.GridDirection.html",
    "title": "Enum GridDirection | Hypar Docs",
    "keywords": "Enum GridDirection A direction/dimension on a 2d grid. Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum GridDirection Fields Name Description U The U Direction V The V Direction"
  },
  "api/Elements.Spatial.html": {
    "href": "api/Elements.Spatial.html",
    "title": "Namespace Elements.Spatial | Hypar Docs",
    "keywords": "Namespace Elements.Spatial Classes Grid1d Represents a \"1-dimensional grid\", akin to a number line that can be subdivided. Grid2d Represents a 2-dimensional grid which can be subdivided MercatorProjection Methods for computing geographic coordinates using the Mercator projection. WebMercatorProjection Methods for computing web mercator projection tiles and coordinates. Enums EvenDivisionMode Describe how a target length should be treated FixedDivisionMode Different ways to handle the \"remainder\" when dividing an arbitrary length by a fixed size GridDirection A direction/dimension on a 2d grid. PatternMode Methods for repeating a pattern of lengths or types"
  },
  "api/Elements.Spatial.MercatorProjection.html": {
    "href": "api/Elements.Spatial.MercatorProjection.html",
    "title": "Class MercatorProjection | Hypar Docs",
    "keywords": "Class MercatorProjection Methods for computing geographic coordinates using the Mercator projection. Inheritance System.Object MercatorProjection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public static class MercatorProjection Methods LatToY(Double) Get the y coordinate, in meters, of the specified latitude. Declaration public static double LatToY(double lat) Parameters Type Name Description System.Double lat Returns Type Description System.Double LonToX(Double) Get the x coordinate, in meters, of the specified longitude. Declaration public static double LonToX(double lon) Parameters Type Name Description System.Double lon Returns Type Description System.Double ToGeoCoord(Double, Double) Get the latitude and longitude of the specified x and y coordinates. Declaration public static double[] ToGeoCoord(double x, double y) Parameters Type Name Description System.Double x System.Double y Returns Type Description System.Double [] An array of doubles containing the longitude and latitude in degrees. ToPixel(Double, Double) Get the coordinates of the longitude and latitude. Declaration public static double[] ToPixel(double lon, double lat) Parameters Type Name Description System.Double lon System.Double lat Returns Type Description System.Double [] An array of doubles containing the x, and y coordintes, in meters. XToLon(Double) Get the longitude of the specified x coordinate. Declaration public static double XToLon(double x) Parameters Type Name Description System.Double x The x coordinate. Returns Type Description System.Double The longitude in degrees. YToLat(Double) Get the latitude of the specified y coordinate. Declaration public static double YToLat(double y) Parameters Type Name Description System.Double y The y coordinate. Returns Type Description System.Double The latitude in degrees."
  },
  "api/Elements.Spatial.PatternMode.html": {
    "href": "api/Elements.Spatial.PatternMode.html",
    "title": "Enum PatternMode | Hypar Docs",
    "keywords": "Enum PatternMode Methods for repeating a pattern of lengths or types Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum PatternMode Fields Name Description Cycle For a pattern [A, B, C], split at A, B, C, A, B, C, A... Flip For a pattern [A, B, C], split at A, B, C, B, A, B, C, B, A None No Repeat. For a pattern [A, B, C], split A, B, C panels, and treat the remaining length according to FixedDivisionMode settings."
  },
  "api/Elements.Spatial.WebMercatorProjection.html": {
    "href": "api/Elements.Spatial.WebMercatorProjection.html",
    "title": "Class WebMercatorProjection | Hypar Docs",
    "keywords": "Class WebMercatorProjection Methods for computing web mercator projection tiles and coordinates. Inheritance System.Object WebMercatorProjection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public static class WebMercatorProjection Methods GetTileSizeMeters(Int32) Get the tile size, in meters, for the specified zoom. Declaration public static double GetTileSizeMeters(int zoom) Parameters Type Name Description System.Int32 zoom Returns Type Description System.Double TileIdToCenterWebMercator(Int32, Int32, Int32) Get the center of the mercator web tile. Declaration public static Vector3 TileIdToCenterWebMercator(int x, int y, int zoom) Parameters Type Name Description System.Int32 x System.Int32 y System.Int32 zoom Returns Type Description Vector3"
  },
  "api/Elements.StandardWall.html": {
    "href": "api/Elements.StandardWall.html",
    "title": "Class StandardWall | Hypar Docs",
    "keywords": "Class StandardWall A wall defined by a planar curve, a height, and a thickness. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_StandardWall.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a wall. var line = new Line(new Vector3(0, 0, 0), new Vector3(10, 10, 0)); var wall = new StandardWall(line, 0.1, 3.0); wall.AddOpening(1, 2, 1, 2); wall.AddOpening(3, 1, 1, 2); Inheritance System.Object Element GeometricElement Wall StandardWall Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members Wall.Height Wall.Profile Wall.Openings GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class StandardWall : Wall, INotifyPropertyChanged, IHasOpenings Constructors StandardWall(Line, Double, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a wall along a line. Declaration public StandardWall(Line centerLine, double thickness, double height, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Line centerLine The center line of the wall. System.Double thickness The thickness of the wall. System.Double height The height of the wall. Material material The wall's material. Transform transform The transform of the wall. This transform will be concatenated to the transform created to describe the wall in 2D. Representation representation The wall's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the wall. System.String name The name of the wall. Properties CenterLine The center line of the wall. Declaration public Line CenterLine { get; } Property Value Type Description Line Thickness The thickness of the wall. Declaration public double Thickness { get; set; } Property Value Type Description System.Double Methods AddOpening(Polygon, Double, Double, Double, Double) Add an opening in the wall. Declaration public Opening AddOpening(Polygon perimeter, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description Polygon perimeter The perimeter of the opening. System.Double x The distance to the origin of the perimeter opening along the center line of the wall. System.Double y The height to the origin of the perimeter along the center line of the wall. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening AddOpening(Double, Double, Double, Double, Double, Double) Add an opening in the wall. Declaration public Opening AddOpening(double width, double height, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description System.Double width The width of the opening. System.Double height The height of the opening. System.Double x The distance to the center of the opening along the center line of the wall. System.Double y The height to the center of the opening along the center line of the wall. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening UpdateRepresentations() Update solid operations. Declaration public override void UpdateRepresentations() Overrides Wall.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings"
  },
  "api/Elements.StringExtensions.html": {
    "href": "api/Elements.StringExtensions.html",
    "title": "Class StringExtensions | Hypar Docs",
    "keywords": "Class StringExtensions String utilities and extension methods. Inheritance System.Object StringExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class StringExtensions Methods NumberToString(Int32) Create a string A, B, C, ... AA, AB ... from an int value Declaration public static string NumberToString(int value) Parameters Type Name Description System.Int32 value The value to turn into a character string Returns Type Description System.String A string of Upper-case characters e.g. 1=A, 2=B, 27=AA"
  },
  "api/Elements.StructuralFraming.html": {
    "href": "api/Elements.StructuralFraming.html",
    "title": "Class StructuralFraming | Hypar Docs",
    "keywords": "Class StructuralFraming A structural element with a profile swept along a curve. Inheritance System.Object Element GeometricElement StructuralFraming Beam Brace Column Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public abstract class StructuralFraming : GeometricElement, INotifyPropertyChanged Constructors StructuralFraming(Curve, Profile, Material, Double, Double, Double, Transform, Representation, Boolean, Guid, String) Construct a beam. Declaration public StructuralFraming(Curve curve, Profile profile, Material material = null, double startSetback = 0, double endSetback = 0, double rotation = 0, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Curve curve The center line of the beam. Profile profile The structural framing's profile. Material material The structural framing's material. System.Double startSetback The setback distance of the beam's extrusion at its start. System.Double endSetback The setback distance of the beam's extrusion at its end. System.Double rotation An optional rotation in degrees of the transform around its z axis. Transform transform The element's Transform. Representation representation The structural framing's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The structural framing's id. System.String name The structural framing's name. Properties Curve The center line of the framing element. Declaration public Curve Curve { get; set; } Property Value Type Description Curve EndSetback The setback of the framing's extrusion at the end. Declaration public double EndSetback { get; set; } Property Value Type Description System.Double Profile The structural framing's profile. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Rotation The profile rotation around the center curve of the beam in degrees. Declaration public double Rotation { get; set; } Property Value Type Description System.Double StartSetback The setback of the framing's extrusion at the start. Declaration public double StartSetback { get; set; } Property Value Type Description System.Double Methods ProfileTransformed() Get the cross-section profile of the framing element transformed by the element's transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() Calculate the volume of the element. Declaration public double Volume() Returns Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Topography.html": {
    "href": "api/Elements.Topography.html",
    "title": "Class Topography | Hypar Docs",
    "keywords": "Class Topography A topographic mesh defined by an array of elevation values. var scene = new THREE.Scene(); var div = document.getElementById(\"model\") var camera = new THREE.PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new THREE.OrbitControls( camera, renderer.domElement ); var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); var axesHelper = new THREE.AxesHelper( 2 ); scene.add( axesHelper ); var size = 100; var divisions = 100; var colorCenterLine = new THREE.Color( 0xa0a0a0 ); // var colorGrid = new THREE.Color( 0xdbdbdb ); // var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid); // scene.add( gridHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new THREE.GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Topography.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); gltf.animations; // Array<THREE.AnimationClip> gltf.scene; // THREE.Scene gltf.scenes; // Array<THREE.Scene> gltf.cameras; // Array<THREE.Camera> gltf.asset; // Object fitCameraToObject(gltf.scene, 2.0, controls) }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { const boundingBox = new THREE.Box3(); boundingBox.setFromObject( object ); const center = boundingBox.getCenter(); const size = boundingBox.getSize(); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = this.camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; this.camera.far = cameraToFarEdge * 3; this.camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Read topo elevations from a file. var data = JsonConvert.DeserializeObject<Dictionary<string, double[]>>(File.ReadAllText(\"./elevations.json\")); var elevations = data[\"points\"]; var tileSize = WebMercatorProjection.GetTileSizeMeters(15); // Create a topography. var topo = new Topography(Vector3.Origin, tileSize, elevations); Inheritance System.Object Element GeometricElement MeshElement Topography Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members MeshElement._mesh MeshElement.Mesh MeshElement.Tessellate(Mesh, Transform, Color) GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Topography : MeshElement, INotifyPropertyChanged, ITessellate Constructors Topography(Vector3, Double, Double[], Material, Transform, Guid, String) Create a topography. Declaration public Topography(Vector3 origin, double width, double[] elevations, Material material = null, Transform transform = null, Guid id = default(Guid), string name = null) Parameters Type Name Description Vector3 origin The origin of the topography. System.Double width The width the topography. When constructed from a set of elevations, the width and the length of the topography will be the same. System.Double [] elevations An array of elevation samples which will be converted to a square array of width. Material material The topography's material. Transform transform The topography's transform. System.Guid id The topography's id. System.String name The topography's name. Properties CellHeight The height of a cell. Declaration public double CellHeight { get; } Property Value Type Description System.Double CellWidth The width of a cell. Declaration public double CellWidth { get; } Property Value Type Description System.Double Elevations A flat list of elevation data which is used to generate the topographic mesh's vertices. The elevations will be used with the RowWidth property to convert the flat list into a square grid. Declaration public double[] Elevations { get; } Property Value Type Description System.Double [] MaxElevation The maximum elevation of the topography. Declaration public double MaxElevation { get; } Property Value Type Description System.Double MinElevation The minimum elevation of the topography. Declaration public double MinElevation { get; } Property Value Type Description System.Double Origin The origin of the topography. Declaration public Vector3 Origin { get; } Property Value Type Description Vector3 RowWidth The number of cells 'across' the topography. Declaration public int RowWidth { get; } Property Value Type Description System.Int32 Methods AverageEdges(Topography, Units.CardinalDirection) Average the vertex placement along the specified edge of this topography with the vertex placement along the corresponding edge of a target topography. Declaration public void AverageEdges(Topography target, Units.CardinalDirection edgeToAverage) Parameters Type Name Description Topography target Units.CardinalDirection edgeToAverage GetEdgeVertices(Units.CardinalDirection) Get the vertices along the specified edge of a square topography. Declaration public Vertex[] GetEdgeVertices(Units.CardinalDirection direction) Parameters Type Name Description Units.CardinalDirection direction The edge of vertices to return. Returns Type Description Vertex [] A collection of vertices. UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged ITessellate"
  },
  "api/Elements.Units.CardinalDirection.html": {
    "href": "api/Elements.Units.CardinalDirection.html",
    "title": "Enum Units.CardinalDirection | Hypar Docs",
    "keywords": "Enum Units.CardinalDirection Cardinal directions. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum CardinalDirection Fields Name Description East East North North South South West West"
  },
  "api/Elements.Units.html": {
    "href": "api/Elements.Units.html",
    "title": "Class Units | Hypar Docs",
    "keywords": "Class Units Unit conversions and utilities. Inheritance System.Object Units Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class Units Fields PI_2 Pi/2 Declaration public const double PI_2 = 1.5707963267948966 Field Value Type Description System.Double Methods DegreesToRadians(Double) Convert from degrees to radians Declaration public static double DegreesToRadians(double degrees) Parameters Type Name Description System.Double degrees Returns Type Description System.Double The provided value converted to radians FeetToMeters(Double) Convert from feet to meters. Declaration public static double FeetToMeters(double feet) Parameters Type Name Description System.Double feet Returns Type Description System.Double The provided value converted to meters. GetConversionToMeters(Units.LengthUnit) Get the conversion factor from the provided length unit to meters. Declaration public static double GetConversionToMeters(Units.LengthUnit from) Parameters Type Name Description Units.LengthUnit from The length unit. Returns Type Description System.Double InchesToMeters(Double) Convert from inches to meters. Declaration public static double InchesToMeters(double inches) Parameters Type Name Description System.Double inches A value of inches. Returns Type Description System.Double The provided value converted to meters. MetersToFeet(Double) Convert from meters to feet. Declaration public static double MetersToFeet(double meters) Parameters Type Name Description System.Double meters Returns Type Description System.Double The provided value converted to feet. MetersToInches(Double) Convert from meters to inches. Declaration public static double MetersToInches(double meters) Parameters Type Name Description System.Double meters Returns Type Description System.Double The provided value converted to inches. RadiansToDegrees(Double) Convert from radians to degrees. Declaration public static double RadiansToDegrees(double radians) Parameters Type Name Description System.Double radians Returns Type Description System.Double The provided value converted to radians."
  },
  "api/Elements.Units.LengthUnit.html": {
    "href": "api/Elements.Units.LengthUnit.html",
    "title": "Enum Units.LengthUnit | Hypar Docs",
    "keywords": "Enum Units.LengthUnit Units of length. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum LengthUnit Fields Name Description Centimeter Centimeter Foot Foot Inch Inch Kilometer Kilometer Meter Meter Millimeter Millimeter"
  },
  "api/Elements.Units.UnitType.html": {
    "href": "api/Elements.Units.UnitType.html",
    "title": "Enum Units.UnitType | Hypar Docs",
    "keywords": "Enum Units.UnitType Unit types. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum UnitType Fields Name Description Area Area Force Force Length Length Mass Mass None None PlaneAngle Plane Angle Pressure Pressure Time Time Volume Volume"
  },
  "api/Elements.Validators.ArcValidator.html": {
    "href": "api/Elements.Validators.ArcValidator.html",
    "title": "Class ArcValidator | Hypar Docs",
    "keywords": "Class ArcValidator Inheritance System.Object ArcValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class ArcValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.BBox3Validator.html": {
    "href": "api/Elements.Validators.BBox3Validator.html",
    "title": "Class BBox3Validator | Hypar Docs",
    "keywords": "Class BBox3Validator Inheritance System.Object BBox3Validator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class BBox3Validator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.ColorValidator.html": {
    "href": "api/Elements.Validators.ColorValidator.html",
    "title": "Class ColorValidator | Hypar Docs",
    "keywords": "Class ColorValidator Inheritance System.Object ColorValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class ColorValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.ExtrudeValidator.html": {
    "href": "api/Elements.Validators.ExtrudeValidator.html",
    "title": "Class ExtrudeValidator | Hypar Docs",
    "keywords": "Class ExtrudeValidator Inheritance System.Object ExtrudeValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class ExtrudeValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.GeometricElementValidator.html": {
    "href": "api/Elements.Validators.GeometricElementValidator.html",
    "title": "Class GeometricElementValidator | Hypar Docs",
    "keywords": "Class GeometricElementValidator Inheritance System.Object GeometricElementValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class GeometricElementValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.html": {
    "href": "api/Elements.Validators.html",
    "title": "Namespace Elements.Validators | Hypar Docs",
    "keywords": "Namespace Elements.Validators Classes ArcValidator BBox3Validator ColorValidator ExtrudeValidator GeometricElementValidator LaminaValidator LineValidator MaterialValidator MatrixValidator PlaneValidator PolygonValidator PolylineValidator ProfileValidator SweepValidator Validator The supplier of validation logic for for element construction. Vector3Validator Interfaces IValidator Implement this interface to act as a validator."
  },
  "api/Elements.Validators.IValidator.html": {
    "href": "api/Elements.Validators.IValidator.html",
    "title": "Interface IValidator | Hypar Docs",
    "keywords": "Interface IValidator Implement this interface to act as a validator. Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public interface IValidator Properties ValidatesType The type to be validated. Declaration Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Post construction logic. Declaration void PostConstruct(object obj) Parameters Type Name Description System.Object obj The constructed object. PreConstruct(Object[]) Validate the object with the provided arguments. Declaration void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args"
  },
  "api/Elements.Validators.LaminaValidator.html": {
    "href": "api/Elements.Validators.LaminaValidator.html",
    "title": "Class LaminaValidator | Hypar Docs",
    "keywords": "Class LaminaValidator Inheritance System.Object LaminaValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class LaminaValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.LineValidator.html": {
    "href": "api/Elements.Validators.LineValidator.html",
    "title": "Class LineValidator | Hypar Docs",
    "keywords": "Class LineValidator Inheritance System.Object LineValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class LineValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.MaterialValidator.html": {
    "href": "api/Elements.Validators.MaterialValidator.html",
    "title": "Class MaterialValidator | Hypar Docs",
    "keywords": "Class MaterialValidator Inheritance System.Object MaterialValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class MaterialValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.MatrixValidator.html": {
    "href": "api/Elements.Validators.MatrixValidator.html",
    "title": "Class MatrixValidator | Hypar Docs",
    "keywords": "Class MatrixValidator Inheritance System.Object MatrixValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class MatrixValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.PlaneValidator.html": {
    "href": "api/Elements.Validators.PlaneValidator.html",
    "title": "Class PlaneValidator | Hypar Docs",
    "keywords": "Class PlaneValidator Inheritance System.Object PlaneValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class PlaneValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.PolygonValidator.html": {
    "href": "api/Elements.Validators.PolygonValidator.html",
    "title": "Class PolygonValidator | Hypar Docs",
    "keywords": "Class PolygonValidator Inheritance System.Object PolygonValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class PolygonValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.PolylineValidator.html": {
    "href": "api/Elements.Validators.PolylineValidator.html",
    "title": "Class PolylineValidator | Hypar Docs",
    "keywords": "Class PolylineValidator Inheritance System.Object PolylineValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class PolylineValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.ProfileValidator.html": {
    "href": "api/Elements.Validators.ProfileValidator.html",
    "title": "Class ProfileValidator | Hypar Docs",
    "keywords": "Class ProfileValidator Inheritance System.Object ProfileValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class ProfileValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.SweepValidator.html": {
    "href": "api/Elements.Validators.SweepValidator.html",
    "title": "Class SweepValidator | Hypar Docs",
    "keywords": "Class SweepValidator Inheritance System.Object SweepValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class SweepValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.Validator.html": {
    "href": "api/Elements.Validators.Validator.html",
    "title": "Class Validator | Hypar Docs",
    "keywords": "Class Validator The supplier of validation logic for for element construction. Inheritance System.Object Validator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class Validator Properties Instance The validator singleton. Declaration public static Validator Instance { get; } Property Value Type Description Validator Methods GetFirstValidatorForType<T>() Gets the first validator for the supplied T. Declaration public IValidator GetFirstValidatorForType<T>() Returns Type Description IValidator A validator for T, or null if no validator for T can be found. Type Parameters Name Description T"
  },
  "api/Elements.Validators.Vector3Validator.html": {
    "href": "api/Elements.Validators.Vector3Validator.html",
    "title": "Class Vector3Validator | Hypar Docs",
    "keywords": "Class Vector3Validator Inheritance System.Object Vector3Validator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class Vector3Validator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Wall.html": {
    "href": "api/Elements.Wall.html",
    "title": "Class Wall | Hypar Docs",
    "keywords": "Class Wall A wall defined by a planar profile extruded to a height. Inheritance System.Object Element GeometricElement Wall StandardWall Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Wall : GeometricElement, INotifyPropertyChanged, IHasOpenings Constructors Wall(Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a wall by extruding a profile. Declaration public Wall(Profile profile, double height, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The plan profile of the wall. System.Double height The height of the wall. Material material The material of the wall. Transform transform An option transform for the wall. Representation representation The wall's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the wall. System.String name The name of the wall. Wall(Transform, Material, Representation, Boolean, Guid, String) A pass-through constructor to set the id, name, and transform. Declaration protected Wall(Transform transform, Material material, Representation representation, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Transform transform Material material Representation representation System.Boolean isElementDefinition Is this an element definition? System.Guid id System.String name Properties Height The height of the wall. Declaration public double Height { get; protected set; } Property Value Type Description System.Double Openings A collection of openings in the wall. Declaration public List<Opening> Openings { get; } Property Value Type Description System.Collections.Generic.List < Opening > Profile The profile of the wall. Declaration public Profile Profile { get; protected set; } Property Value Type Description Profile Methods UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings"
  },
  "api/Elements.WallByProfile.html": {
    "href": "api/Elements.WallByProfile.html",
    "title": "Class WallByProfile | Hypar Docs",
    "keywords": "Class WallByProfile A wall drawn using the elevation profile Inheritance System.Object Element GeometricElement WallByProfile Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.CreateInstance(Transform, String) Element.Id Element.Name Element.PropertyChanged Element.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class WallByProfile : GeometricElement, INotifyPropertyChanged Constructors WallByProfile(Profile, Double, Line, Transform, Material, Representation, Boolean) Create a wall requiring only the profile, thickness and centerline. Declaration public WallByProfile(Profile profile, double thickness, Line centerline, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false) Parameters Type Name Description Profile profile System.Double thickness Line centerline Transform transform Material material Representation representation System.Boolean isElementDefinition WallByProfile(Profile, Double, Line, Transform, Material, Representation, Boolean, Guid, String) Declaration public WallByProfile(Profile profile, double thickness, Line centerline, Transform transform, Material material, Representation representation, bool isElementDefinition, Guid id, string name) Parameters Type Name Description Profile profile System.Double thickness Line centerline Transform transform Material material Representation representation System.Boolean isElementDefinition System.Guid id System.String name Properties Centerline The Centerline of the wall Declaration public Line Centerline { get; set; } Property Value Type Description Line Profile The profile, which includes openings that will be extruded. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Thickness The overall thickness of the wall Declaration public double Thickness { get; set; } Property Value Type Description System.Double Methods UpdateRepresentations() Update the geometric representation of this wall. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "C-Sharp.html": {
    "href": "C-Sharp.html",
    "title": "Writing Hypar Functions in C# | Hypar Docs",
    "keywords": "Writing Hypar Functions in C# By uploading a function to Hypar you can produce multiple options for a building problem in just a few seconds, and combine them with other people's functions to create rich, realistic designs. In this introduction to Hypar, we'll work with a much simpler function that generates masses of variable dimensions. Tutorial Videos Creating Functions in C# Pre-Flight Check Before getting started, there are a few things you'll need and some other things you might want to know. Things you'll need A 'modern' web browser. We'll use Google Chrome for this guide, but Firefox or Brave should also work fine. Chrome Firefox Brave Visual Studio Code (Windows, Mac OS, Linux) or any other C#-compatible code editor. We strongly suggest using VSCode to follow along with this tutorial, although Visual Studio will also work fine. Download VSCode A Hypar Account: Sign up at hypar.io . Access to a command line for your operating system. We'll use the Windows Command Prompt for this guide, but other operating system command prompts should work similarly. Windows: Hypar is known to work on the windows command prompt and git bash. Some users have experienced issues using Hypar on PowerShell. PowerShell is not recommended. Mac: Hypar is known to work on bash and zsh. Linux: Hypar is known to work on zsh. .NET Core 3.1 Hypar uses the cross-platform dotnet framework created and maintained by Microsoft. The version number is important! There might be issues with earlier or later versions of .NET Core. Be sure to download the SDK installer from the left-hand side, not the runtime. Things you might want to know It's helpful to review the short conceptual overview of Hypar Elements, Functions, and Workflows before beginning this tutorial. Basic familiarity with the C# programming language will help, but if you're not familiar with C# we'll do our best to walk you through making changes to the initial code you'll get by following the steps in this guide. If you want to share your Hypar functions, you have to explicitly make your work public, so don't worry that perfect strangers are judging your work. They will, but only if you decide to make them public. The procedures you'll use in this guide compile your code on your desktop and only upload the resulting binary file. No one at Hypar will examine your source code because we won't have it unless you make it public by some other means or if you send it to us so we can help you solve a problem. None of the Hypar libraries you'll use in this guide bind your code to Hypar web services. For example, if you'd like to use the Elements library for a desktop application, it's an open source project on GitHub and will always be free for anyone to use or extend. You don't even have to tell us you're using it. Installing and Using the Hypar Command Line Interface (CLI) Open a Command Prompt ( cmd.exe on Windows, or Terminal on Mac or Linux) and input the following command to install the Hypar CLI: dotnet tool install -g hypar.cli Close and reopen the Command Prompt to finish the installation. Sign in to Hypar with this command in the Command Prompt: hypar sign-in Creating a Function Next, return to the Hypar web interface and sign in. Scroll down to see Your Functions , and click New Function followed by New C# Function . This wizard will take you through setting up your function. For consistency with the rest of this example, give your function the name Starter Function . Click Next to proceed to configuring your function's inputs. Click or drag three \"Range\" inputs and name them Width, Length, and Height, and set their minimum values to 1: You can also select \"Preview\" to visualize how the inputs will look in the function. Go on to the next step. We'll save the Connections section for another tutorial, so click next again so that Step 4: Outputs is highlighted at the top. Click the + to add a new output to report the box's volume, and configure it like so: Move on to the final step, Logic . Click \" Publish Function ,\" and then click the button to copy the terminal command. Now your function has been published (privately) to Hypar! Next, we'll write some code to define the logic for the function. Return to your command prompt. Decide where you want Hypar to save the code for your function on your computer, and use the cd command to set that location as the current working directory: cd C:/users/yourUserName/repos Then paste the command you copied from the Hypar web interface, and run that (don't copy the one below, it won't have the right ID): hypar new --function-id=96a0df70-2a7d-4612-9c0e-7f6d86830576 A bunch of messages will go by as Hypar sets up your local project. Next, open VS Code and open the project folder we just created. It should be in the location you picked earlier, with the folder name \"StarterFunction.\" The Hypar CLI just created a bunch of files for you. Here's what that looks like in VS Code: It may seem like a lot, but the good news is you rarely have to edit most of these files — Hypar takes care of all of that for you. Any file you see that ends with .g.cs is not meant to be edited by you. The file we care about most is StarterFunction.cs in the /src directory — this contains the logic for your function. Let's open it up. The Execute method is the entry point into our function. It doesn't do anything very exciting right away; it creates an \"Outputs\" object, and returns it. Note that the method has a few arguments. The one called input contains the inputs we defined earlier, like Width, Length, and Height. Let's use some of those inputs to create a rectangle. Add this line to your function, in between the two existing lines of the method: var rectangle = Polygon.Rectangle(input.Width, input.Length); Next we'll make a Mass Element to pass out to the Hypar 3d environment. Note that if you want something to show up in the 3d view, it has to be an Element of some kind. Add this line after the rectangle: var mass = new Mass(rectangle, input.Height); We also have to put the mass we created in the output model, like so: output.Model.AddElement(mass); Finally, we created an output called Volume to report the box's volume. These data outputs are provided to the constructor for the Outputs object — so let's edit the first line of our method to look like this: var output = new StarterFunctionOutputs(input.Width * input.Length * input.Height); Our function should look like this when we're all done. Be sure to save the file! public static StarterFunctionOutputs Execute(Dictionary<string, Model> inputModels, StarterFunctionInputs input) { // create an outputs object and populate any output values var output = new StarterFunctionOutputs(input.Width * input.Length * input.Height); // create a rectangle var rectangle = Polygon.Rectangle(input.Width, input.Length); // create a mass from the rectangle var mass = new Mass(rectangle, input.Height); // add the mass to the output model output.Model.AddElement(mass); return output; } View on Github To publish our changes to the web, open up your command prompt again (or open VS Code's integrated terminal). Make sure your working directory is the one Hypar created for you — you might need to cd StarterFunction first. Then publish your function logic like this: hypar publish Now your function logic has been added to your function on Hypar. Let's go test it out! Return to hypar.io and sign in. Create a new workflow by clicking New Workflow and selecting New Blank Workflow. Once it opens up, give it a name in the nav bar. Type in any name you want (perhaps \"Starter workflow\"). You'll see this screen: In the Function Library panel, search for \"Starter Function\" (or whatever you named your function). Now let's try out our function. Click Insert on Starter Function and hide the Function Library by clicking the \"X\" to close it. Your function will run automatically and you should see something like this: You've just run a web application that you created! Click in the 3D view to zoom, pan, and rotate the result. Now click on Starter Function to open up its inputs. Try adjusting the sliders to see how the mass changes shape. Check the \" Sample Range \" checkbox under the height and width sliders. Then click the \" Alternatives \" button ( ) on your workflow to see the options that have been generated. In the alternatives list, you can see that your function has actually run many times with different input values. Click different alternatives to view them in 3D. The range sliders on the left are set to allow all possible lengths and widths. You can shrink these ranges to generate just the options you want. This diagram summarizes the process we just went through to create, define, and publish our function: Editing your function While developing a function, you may need to add additional inputs or outputs and change function logic. In this section we'll see how to do this. In your workflow, you should see an \" About \" link under the name of your function. Click it to open the function details. As the owner of this function, you have the ability to make changes here. Switch to the Inputs tab and click Edit Function Details at the bottom of the window. This brings us to the same interface we used to create the inputs originally. Let's add a new Color input by dragging \"Color\" to the top. We'll call it \"Mass Color\" and click the color swatch to set a different color as the default. Any value you set in this window will be the default value that shows up when your function is added to a workflow. Switch to the Outputs tab so we can add an output for the base area of our mass. Click + to add it, and configure it like so: Click Save Changes to register your changes to the function's configuration. Next, we'll need to pull those changes into our local code files, so that we can use the new input and output. Switch to the Logic tab and copy the second command: hypar pull && hypar init hypar pull pulls the changes we made in the web interface to our hypar.json configuration file, and hypar init generates new code files from that configuration. You are also welcome to run these commands independently — you don't need to copy them from the web every time. Let's return to VS Code, and take a closer look. If you select hypar.json in the righthand side, you can view the configuration that describes this function. If you scroll down, you should see our new Color input and Area output reflected: NOTE Advanced users may find it easier to edit hypar.json manually rather than editing the function in the web UI and running hypar pull — it's completely up to you. Just remember to use hypar init after any changes to hypar.json to make sure the corresponding C# code gets regenerated. Returning to StarterFunction.cs , we can take advantage of our new inputs and outputs. We'll edit the first line to add the base area output: var output = new StarterFunctionOutputs(input.Width * input.Length * input.Height, input.Width * input.Length); And create a new material before we create our mass: var material = new Material(\"Box Color\", input.MassColor); And finally add the material to the mass. var mass = new Mass(rectangle, input.Height, material); Here's how the updated Execute method code should look now: public static StarterFunctionOutputs Execute(Dictionary<string, Model> inputModels, StarterFunctionInputs input) { // create an output object var output = new StarterFunctionOutputs(input.Width * input.Length * input.Height, input.Width * input.Length); // create a rectangle var rectangle = Polygon.Rectangle(input.Width, input.Length); // create a new material var material = new Material(\"Box Color\", input.MassColor); // create a mass from the rectangle var mass = new Mass(rectangle, input.Height, material); // add the mass to the output model output.Model.AddElement(mass); return output; } View on Github Be sure to save the file, and then publish these changes by running hypar publish again. Then we'll return to our workflow on Hypar, and reload the page to update the function. You may have to adjust a slider value to cause the function to recompute. This diagram summarizes the steps we've taken to edit and update our function: Sharing your function Your function always starts out private to you: only you can see and use it in a workflow. Once you're happy with your function, you can share it with the world! Click the \"About\" link under your function name again, and this time navigate to the Permissions tab. Uncheck the Private checkbox to make your function public. You can also choose to share it in a more limited way, by sharing with specific email addresses or with a whole email domain (like myfirm.com ). You may also want to add a thumbnail to your function so others can get a sense of what it does. To do this, go to the Details tab, click Edit Function Details , and drag-and-drop an image on the drop zone. Then click Save Changes to save the thumbnail. Testing your function When developing a function, it's useful to be able to make changes and visualize them immediately. The Hypar CLI provides a way to run your function locally and test it in the context of a workflow. Return to your workflow, and remove your function from the workflow by clicking the \"X.\" Then go to the Hypar menu in the upper-right hand corner of the window, and select Test a Local Function Click the \"Copy to clipboard\" button under the command: Then return to your terminal, ensure you're in your project directory (\"StarterFunction\") and paste the copied command, which should look like this: hypar run --workflow-id=6bcece6c-2fa5-4a4d-a5c7-43732bff053b Wait until you see this message: Workflow update subscription acknowledgement received with id 518f1c6f-1b07-40e9-8461-fbc8fdbe3c06. Waiting for workspace updates... And then return to the workflow and click the \"Ready\" button. Now, when you edit the inputs of the function, they're passed to your locally-running function, instead of being executed on the cloud. HYPAR RUN The hypar run command we pasted earlier stays running continuously until we exit. While it's running, it serves the local function, and also monitors your code for changes. If you make changes to hypar.json or to your C# code, it will rebuild the function and re-execute dynamically. This makes it easy to write code, quickly try things out, and visualize how they will function on Hypar. Let's make some changes to our code, with hypar run still running. We'll insert a void running through our mass. For this we'll need to create a smaller rectangle inside our first one, and create a profile from those two rectangles. First, we'll make the second rectangle: var innerRectangle = Polygon.Rectangle(input.Width * 0.5, input.Length * 0.5); And then a Profile from the two rectangles: var profile = new Profile(rectangle, innerRectangle); And then edit the line where we make the Mass to use our new profile: var mass = new Mass(profile, input.Height, material); The updated execute method should look like this: public static StarterFunctionOutputs Execute(Dictionary<string, Model> inputModels, StarterFunctionInputs input) { // create an output object var output = new StarterFunctionOutputs(input.Width * input.Length * input.Height, input.Width * input.Length); // create a rectangle var rectangle = Polygon.Rectangle(input.Width, input.Length); // create an inner void rectangle var innerRectangle = Polygon.Rectangle(input.Width * 0.5, input.Length * 0.5); // create a profile from the two rectangles var profile = new Profile(rectangle, innerRectangle); // create a new material var material = new Material(\"Box Color\", input.MassColor); // create a mass from the rectangle var mass = new Mass(profile, input.Height, material); // add the mass to the output model output.Model.AddElement(mass); return output; } View on Github As soon as you save your code, you should see the function results update in your workflow: When you're happy with your local changes, hit ctrl+C in the terminal to stop hypar run . Finally, publish your updated function with hypar publish . The next time you use it in a workflow, it will reflect the changes you made. Anyone you've shared your function with will also have access to the latest and greatest version you just published. This diagram summarizes the steps we've taken to edit and test our function with live preview: What's next? Congratulations on creating your first Hypar function! There's more to learn, but you should start thinking about building a real, useful function. Here are a few tips for deciding what to make: Solve one small problem. Hypar Functions are easy to compose. No single function needs to do too much on its own. Take something you've done before and do it again on Hypar. Scratch an itch. What do you hate doing manually? What would look cool? What would look silly? You don't need to be original. Just get started. Feel free to make another version of something you've already seen. Here are some other good resources: Hypar CLI Reference Hypar's Discord live chat . Lots of people should be there to answer questions or share ideas. Hypar's YouTube channel has walkthrough videos and livestreams. The Elements GitHub repository and the tabs on top of this page have more information about Hypar's data model. Hypar's Building Blocks repo has the source code for many Hypar functions. Read those to see how they work, and feel free to branch or improve any of them."
  },
  "Elements/WhatIsElements.html": {
    "href": "Elements/WhatIsElements.html",
    "title": "What is Elements? | Hypar Docs",
    "keywords": "What is Elements? Elements is a cross-platform library for creating building elements. It's meant to be used by architects, engineers, and other building professionals who want to write code that generates buildings. When we started Hypar we needed a library that would generate building elements and run at the core of each function on the platform. Because we don't like rebuilding the wheel, we looked around for existing libraries that fulfilled the following requirements: The library must be small and fast. Elements is currently ~300kb and we're working every day to make it smaller. The library must be cross-platform. The library must have great visual documentation. If we're going to pass this library on as a recommendation to developers on Hypar, we want great docs. The library must be free of dependencies on host applications like Rhino or Revit or geometry kernels like Open Cascade which, while really cool, become a black box in your system. The library must be able to serialize data to formats like JSON, IFC ,and glTF , that are useful to architects, engineers, contractors, and people building real-time visualization applications for AEC. The library must be written in a language that supports developer productivity through things like type safety, and which supports code re-use in other popular AEC applications like Dynamo, Grasshopper, Revit, and Unity. Serialization and deserialization of types that extend Element should be possible provided that those types are made up of primitives defined in this library. We couldn't find anything quite right. So we started building this."
  },
  "Excel.html": {
    "href": "Excel.html",
    "title": "Getting Started with Excel Functions | Hypar Docs",
    "keywords": "Getting Started with Excel Functions All Hypar functions (Excel, Grasshopper, C# etc..) work by receiving some Inputs, executing some logic, and then returning some Outputs. When we turn Excel spreadsheets into a Hypar function we are talking about an Excel spreadsheet acting as the \"logic\" between some Inputs and some Outputs. Excel functions can be created by uploading an Excel spreadsheet to Hypar where the system exposes some named spreadsheet cells as Inputs to the function and other named cells as Outputs from the formulas contained in the spreadsheet. Detailed instructions are below this short video describing the process. Prepping Your Excel File. Before uploading your file to Hypar, designate some spreadsheet cells as Inputs and some cells as Outputs by using the Excel feature called Named Ranges. Cells named with the prefix \"INPUT.\" become Inputs, and names that start with \"OUTPUT.\" become Outputs. There are two places in Excel where you can see cell names. First, when a cell is selected you can see and edit the name in the upper left of the Excel spreadsheet view. Second, under the \"Formula\" tab, there is a button called \"Named Ranges\" with a dialog that will pop up, showing you all of the named regions in the spreadsheet. Name some cells in a spreadsheet, prefixing with INPUT. and OUTPUT. and when you're done, proceed to the next section. Upload to Hypar Now that your Excel file is equipped with cells named INPUT.[your name here] and OUTPUT.[your name here] you're ready to upload it to Hypar. Navigate to https://hypar.io , sign in, and you should see the workflow gallery. Now scroll to the section labeled \"Your Functions\" and click on the \"New Function\" button. Choose \"New Excel Function\" Now you'll see a dialog with a summary of the instructions, and a drop box to which, you can drag your prepared Excel spreadsheet, or click and choose the file from a file dialog. Once you drop your Excel file on the target box your file is uploaded to Hypar where Inputs and Outputs are extracted. When the process is complete, you should see a summary of the resulting function's characteristics: This dialog box lets you edit your function name and description and shows you a list of the Inputs and Outputs found when Hypar analyzed your file for Named cells. If you like what you see, click the \"Publish Function\" button. Here we see the detailed view of your function, and if you would like to make further edits click on \"Edit Function Details\" Editing the Function on Hypar Here you can use \"Edit Function Details\" to change the function name and description, upload a thumbnail for your function's card on Hypar, and even upload a new Excel file if you need to update the spreadsheet with new formulae or edited Inputs and Outputs. You can also edit the numeric range of your Inputs. Hypar tries to choose smart defaults based on your initial values, but you should double check that all the values here make sense. Now it's time to run your function! Make note of your function's name, and then click close (or anywhere outside of this window) to go back to the gallery. Now click \"New Workflow\", and select \"New Blank Workflow\" as your template. You should now be in a blank Workflow, where you can rename your Workflow to something you'll remember. After that, choose \"Add Function\", search for your function name, and add it to your Workflow. Now, click on your function, move any sliders you want to adjust, and to see the results, click to open the Output pane. Congratulations, you've finished creating an Excel function with Hypar!"
  },
  "Functions.html": {
    "href": "Functions.html",
    "title": "Making Hypar Functions | Hypar Docs",
    "keywords": "Making Hypar Functions Hypar Functions are the building blocks of Hypar. They capture a piece of intelligence: the logic of some system, object, or process. Hypar functions can be created in a number of different ways: you can write C# Code , build an Excel spreadsheet , or develop a Grasshopper script . By uploading a function to Hypar you can produce multiple options for a building problem in just a few seconds, and combine them with other people's functions to create rich, realistic designs. All Hypar functions describe their inputs and their outputs. The various function languages treat these slightly differently, but the basic concepts are the same: you specify the information your function needs to run -- like numbers, boolean values, choices from a list, or elements from the model -- and you designate these pieces of information as Inputs and Model Dependencies. Similarly, you specify the information your function generates -- numerical data or other elements to be added to the model -- and designate these as Outputs and Model Outputs. Choose a function language to learn more C# Grasshopper (Requires Rhino 6 or above) Excel"
  },
  "Grasshopper.html": {
    "href": "Grasshopper.html",
    "title": "Getting Started with Grasshopper Functions | Hypar Docs",
    "keywords": "Getting Started with Grasshopper Functions Hypar functions are a way to capture the logic of a system in a way that can be easily combined with other systems, and shared with other people. One of the ways you can create a function is by publishing a Grasshopper script to Hypar. This guide will walk you through the process. You can follow the video tutorials below, or walk through the step-by-step guide at your own pace; they cover roughly the same information. Video Tutorials Tutorial Index Part 1: Getting Started Part 2: Outputs and Deconstruct Element Part 3: Input Types, Materials, and Mesh Elements Part 4: Custom Schemas + Solids Part 5: Model Dependencies Part 6: Instances Installing the Grasshopper Plugin To install the Hypar plugin for Grasshopper, it is best to use the Rhino Package Manager. In Rhino 6, type TestPackageManager in the Rhino Command line -- it may not autocomplete, but the command will work. In Rhino 7 or later, type PackageManager to open the dialog. Search for Hypar, select the result, and click \"Download and Install.\" If Grasshopper was already running, you'll need to shut down Rhino and restart it, otherwise you can proceed to launch Grasshopper. If you are having trouble with the package manager, you can also download the plug-in from Food4Rhino , but this is not recommended. NOTE Only Rhino 6 and 7 on Windows are fully supported. Rhino on Mac also works in most but not all cases. Building a simple function To start, we'll build a very simple Grasshopper function: just a Center Box component with some sliders from 0 to 100 controlling X, Y, and Z. We need to do three things to make this function ready for Hypar. Navigate to the Hypar tab in your Grasshopper window, and grab the following components from the 1. Setup section. Give your function a name and description with the component. Connect one component to each of your Sliders (there should be three total.) Each slider should feed into the \"O\" input of the Function Input component. Create a component and supply it with a name. Your definition should look like this: Lastly, in order to produce geometry out of our function, we have to create Hypar Elements -- these are special objects that Hypar knows how to read and display. You can learn more about Hypar Elements here . To create a Hypar Element in Grasshopper, we'll use the component. Place it on the canvas, and right click it to open a menu of possible Element types: Select \"MeshElement\" from the list. The component should change shape, generating inputs on the left-hand side for all the information that a \"MeshElement\" requires. Connect your box to the \"Mesh\" input, and connect the \"E\" output to the \"E\" input of the component we created earlier. The final definition should look like this: Publishing the function Save the definition as a .gh file. Open hypar.io , and log in. Scroll down until you see \"Your Functions\": Click \"New Function\" and then click \"New Grasshopper Function.\" Drag and drop the .gh file you saved earlier onto the region marked \"Drop a Grasshopper Definition Here,\" or click it to bring up a file browser and locate the file that way. It will upload the file and load the information from it. Don't worry if it takes a little while -- it shouldn't show \"Loading Function Details\" longer than about 30 seconds. When it has successfully loaded, you'll see a preview of the information it's gathered from your file. Feel free to edit the name and description of the file at this point. Click \"Publish Function,\" and when the dialog changes, click \"Close.\" Your function should now show up under \"Your Functions.\" Next click \"New Workflow,\" and choose \"New Blank Workflow.\" Search for your function in the Function Library, and click \"Insert\" when you've found it. You should see a box appear in your model. Click on the function name to open its settings: Adjust the sliders and watch the cube change dynamically. Congratulations! You've authored your first Hypar function with Grasshopper! Working with Elements and Custom Types WARNING Grasshopper for Mac does not support building custom types. As shown in the previous section, to create geometry for the model that you can see in Hypar, you need to create Elements. This is done with the Construct Element component, which can take on a number of different types. However, it doesn't stop there! Many other types are available, and you can even create your own custom types . You can visit the Types section for details, but for our purposes it suffices to know that a type is defined with a .JSON file hosted somewhere on the web. The Hypar Schemas repository collects a good number of these, but they can be hosted anywhere that's public. If we want to construct an Envelope Element, for instance, we'll need to grab a reference to the Envelope schema. Copy and paste this URL: https://raw.githubusercontent.com/hypar-io/Schemas/master/Envelope.json into a text panel in Grasshopper, and connect it to the \"S\" input of a component, like so: It will show \"Loading\" for a bit while it downloads that schema and loads the type. When it's done, all Hypar components will be able to use the Envelope type. If you right click a Construct Element component, you will now be able to create an Envelope: Solids and Representations When you reference a custom type like Envelope , Hypar has no way of knowing how to construct its 3D geometry, so you have to explicitly provide a \"Representation\" of that geometry. The component will accept a list of Solid s which can be used to describe the geometry. Here's an example of defining an Envelope , with an Extrude solid as its representation: Specifying Model Dependencies In many cases, you'll want to build a function that references information from other functions in the model. Hypar functions can declare \"Model Dependencies,\" and thereby access specific elements produced by other functions. A Facade function might depend on the Envelope produced by an Envelope By Sketch function, for instance. Let's build a function that depends on Envelope. Log into Hypar, click \"New Workflow.\" This time, select the \"Simple Tower\" template. Click on \"Envelope By Sketch,\" and then click the \"About\" button. Pay special attention to the information under \"Model Output\" and \"Element Types\": Right click \"Envelope\" under \"Element types,\" and copy the link address. Open Grasshopper and start a new Definition. As in the previous section, we'll need to reference the \" Envelope \" type. The link we just copied contains the schema URL for this type; paste it into a text panel and connect it to the \"S\" input of a component, like so: Now place a component. Type \"Envelope\" into a text panel, and connect it to the \"K\" input. This input should match the \"Model Output\" text we just referred to in the function details view on the Hypar web interface. For common types like Envelope, reference geometry is automatically loaded. For more complex types, you may need to download a JSON representation of a model to use as test geometry to build your function against. If your \"Model Dependency\" component shows no output, go to the workflow and click \"Export\" in the lower left-hand corner. In our case this is not necessary, but feel free to try it out. Download the JSON file, and supply the file path to the \"J\" input of the Model Dependency component. You'll notice that the Model Dependency component outputs several kinds of Elements. An easy way to filter this down is to supply a type filter to the T input of the Model Dependency component. Connect your \"Envelope\" panel to this input as well to limit your dependency to Elements of type Envelope . Now, connect a component to the output of Model Dependency. It will automatically take on all the properties of an Envelope, and you can use any of the resulting outputs and geometry as information for your function. When the function is run on Hypar, this information will be replaced by the Envelope s in the workflow. Updating a Grasshopper Function on Hypar You can update the version of the Grasshopper script for a given function. Just click the tile for that function in \"Your Functions,\" and choose \"Edit Function Details\": Just drop a new version of your script on the file drop zone to update the logic of your function. Limitations Currently Custom Type generation is not supported on Grasshopper for Mac. Only certain 3rd party plug-ins are currently supported on Hypar: Wombat TreeFrog Human Clipper Tools MetaHopper Custom scripts (C#, VB.NET, and Python) are not currently supported. Function Execution has a time limit of 15-30 seconds. If your definition takes longer than this to run, you may experience timeouts on Hypar. Component Reference Category Icon Name Description 1. Setup Hypar Function Setup Use this component to set up the parameters of your Hypar function. 1. Setup Function Input Select a function input 1. Setup Function Output Designate a data output for your function 1. Setup Model Output Create a model output from elements 1. Setup Model Dependency Refer to other elements in the model 2. Elements Deconstruct Element Instance Deconstruct an Element Instance 2. Elements Construct Element Construct a Hypar element 2. Elements Deconstruct Element Use this component to deconstruct the properties of any element. 2. Elements Material Create a Elements.Material 2. Elements Representation Create a Elements.Geometry.Representation 2. Elements Construct Element Instance Construct an Element Instance from another element 3. Solids Sweep Create a Elements.Geometry.Solids.Sweep 3. Solids Extrude Create a Elements.Geometry.Solids.Extrude 3. Solids Lamina Create a Elements.Geometry.Solids.Lamina 4. Special Model to JSON Convert elements into a model and output it as JSON."
  },
  "Hub.html": {
    "href": "Hub.html",
    "title": "Getting Started with the Hypar Hub | Hypar Docs",
    "keywords": "Getting Started with the Hypar Hub The Hypar Hub is currently part of the Hypar CLI. If you have not already installed the Hypar CLI, follow these instructions first. The Hypar Hub acts as the single point of synchronization between your workflows on Hypar and your local machine. The hub listens for update messages from Hypar, and builds a local cache of data representating the output of the functions in your workflow. To learn how to use the hub, you can do hypar hub -h from the command line hub: Work with the hypar hub. Usage: Hypar hub [command] Commands: add Add a workflow to a hub. remove Remove a workflow from the hub. hide Hide a function in a workflow. show Show a function in a workflow. When run without modifiers, the hypar hub command will use the settings provided by the hub.json in your hypar directory . If a hub.json file cannot be found, one will be created for you. The first time a hub.json file is created, it will ask you to add a workflow to the hub. You can find the id of a workflow by looking at its url in Hypar. The workflow id is the last part of the url. Here's an example: https://hypar.io/w26cc62-e421-4790-89a5-a9332c3427a2orkflows/80 . The workflow id is 8026cc62-e421-4790-89a5-a9332c3427a2 . The next thing the hub command will ask for is a Revit file name. If you associate a Revit file name with a workflow in the hub, the workflow's contents will be visible inside that Revit project. The file name should be added withtout the path, like Building.rvt . You can leave this blank. If you do, the newly added workflow won't show up in any Revit projects. If you've already got a hub.json and would like to add or remove a workflow, you can do hypar hub add or hypar hub remove to add or remove workflows. You can see some more examples of how to use the hub here Once you've got a valid hub.json file, you can run the hub like this: hypar hub Once started, the hub will do two things. First, it syncs the workflows specified in your hub.json from Hypar to your local hypar directory. Then it creates a .NET assembly containing all of the types that are used by all the functions in your workflows. The hub writes data into the current user's home directory in a folder called .hypar (this might be hidden on some machines). For example, on Windows, the hub writes its data to C:/Users/{user name}/.hypar . Log files are also written to this directory. When changes are made to workflows that are being watched by the hub, the hub will receive those changes and update the local data store. It will then emit change notifications to all connected clients. Hypar Directory The hub stores information locally in a .hypar directory in the user's \"home\" folder. For Windows users this will be something like C:\\Users\\<you>\\.hypar For *nix users this will be ~/.hypar Examples Run the hub: hypar hub Add a workflow to the hub: hypar hub add --id 8026cc62-e421-4790-89a5-a9332c3427a2 Remove a workflow from the hub: hypar hub remove --id 8026cc62-e421-4790-89a5-a9332c3427a2 Associate a Revit file with a workflow: hypar hub add revit --id 8026cc62-e421-4790-89a5-a9332c3427a2 --file-name Building.rvt Remove the association between a Revit file and a workflow: hypar hub remove revit --id 8026cc62-e421-4790-89a5-a9332c3427a2 --file-name Building.rvt Hide a function in a workflow: hypar hub hide --id 8026cc62-e421-4790-89a5-a9332c3427a2 --function-name Levels by Envelope Settings The hub.json file provides configuration information for the hub. You can edit it manually or use the Hypar CLI to add or remove workflows, control visibility of functions in workflows, or sync specific workflows with Revit files. A hub.json file looks like this: { \"8026cc62-e421-4790-89a5-a9332c3427a2\": { \"hidden\": [ \"Envelope By Sketch\", \"Levels By Envelope\" ], \"revit\": { \"file_name\": \"HyparTest.rvt\" }, \"active\": false }, } The hidden property is an array of function names which you would like to be hidden from hub clients. It's often useful to hide certain functions, like those which provide datums: Levels, Grids, etc., so that your client application doesn't need to draw or import those. The active property is a boolean value indicating whether the workflow should be sent to the hub clients. A workflow with \"active\": false will still be synced to the hub, but its update notifications will not be sent to the clients. The revit property contains information for syncing with Revit. The file_name property on this object specifies the file name (without directory) of the Revit file in which this workflow will be made visible. Hub Clients Hub clients receive update messages from the hub when data has changed. For example, when the Revit hub client receives an update message it updates the visualization in the active 3D view to include what's in the hub. If you're interested in seeing how a hub client works internally, you can view the Revit hub source code on github. Known Limitations The hub creates dlls containing all the types required by your synced workflows. For applications which will deserialize models from JSON, these assemblies are loaded to provide type definitions for deserialization. In applications like Revit, assemblies can not be unloaded and are locked by the system. After the first load of an assembly, you can not update it or reload it. If you add a function to a workflow, the hub will attempt to create a new assembly containing the types required by that workflow, and will not be able to. You will need to restart the hub."
  },
  "Hypar-CLI-Reference.html": {
    "href": "Hypar-CLI-Reference.html",
    "title": "Hypar CLI Reference | Hypar Docs",
    "keywords": "Hypar CLI Reference The Hypar Command Line Interface (CLI) connects your desktop to the Hypar cloud. It packages utilities for function authoring, code generation, testing, and synchronization with desktop applications. This page describes the commands supported by the Hypar CLI for your reference. This information is also available from within the CLI at any time by running hypar --help in your terminal. Installation instructions Commands Command Description new Create a new Hypar function. publish Publish your function to Hypar. delete Delete a function from Hypar. generate-catalog Generate code for a ContentCatalog. generate-types Generate user element types from the specified url. init Generate input, output, and function classes from a hypar.json. rename Rename a function. sign-in Sign in to Hypar. sign-out Sign out of Hypar. run Run the hypar function found in the current directory. Defaults to running the function whenever the function's code or its input change, but can also run across a provided list of input values instead. pull Pull changes made to your function via the Hypar web UI down to your local hypar.json. version, --version Display version information update Update the current function to the latest version of Hypar, or to a specified version. hub Work with the hypar hub. Typical C# Function Development Flows"
  },
  "index.html": {
    "href": "index.html",
    "title": "Getting Started with Hypar | Hypar Docs",
    "keywords": "Getting Started with Hypar Here's a short video that explains some of the Hypar concepts that we'll be using in this getting started guide. Hypar is a cloud platform for generating buildings that makes it easy to publish, distribute, and maintain your building design logic. Rather than requiring web development skills to scale and deliver your design logic, Hypar lets you concentrate on what you want to get done while the platform creates the interface for your audience and provides computation, visualization, delivery, interoperability, and access control for your functions. Signing up for Hypar To use the Hypar platform, you're going to need an account. Point your browser to https://hypar.io , and you should see a page that looks like this. If you don't have an account already, click on the Create a free account button below the logo. That should take you to the Sign Up screen. Fill in a username, an email address you can access, and the password you'd like to use. Then click on the Sign up button. Then we do some explaining: Now check the email account you supplied for a message that looks something like this: Click on the Verify Email link in the message and you should see a confirmation page: Where to go next That's it! You now have a Hypar account. Time to start building some workflows or authoring some functions ! You might also explore these resources to get ideas for building a function, or learn more about the platform: Hypar's Discord live chat . Lots of people should be there to answer questions or share ideas. Hypar's YouTube channel has walkthrough videos and livestreams. <!-- TODO: Labels can't be trivially added to masses right now. What if we wanted to see these results in the graphic display as well? We'll handle that by adding **properties** to the generated masses, and display them using the **Label** dropdown. For the moment the **Label** dropdown only has **None** as an entry: ![](./images/HyparLabels.png) <div style=\"page-break-after: always;\"></div> To add labels for our **volume** and **area** values open **StarterFunction.cs** in VSC. Move the two value calculations up under the **height** input, because we're going to need those values a little earlier so we can add them as properties to our **mass**: ![](./images/HyparStartFunctionLabels1.PNG) <div style=\"page-break-after: always;\"></div> Before we add the **mass** to our Hypar **model**, we need to add a couple of **NumericProperty** entries to the **mass**. Add these lines before **model.AddElement(mass)**: ![](./images/HyparAddProperties.PNG) There's a lot happening in these two lines, so let's look at each part, using our new **Volume** property as an example of how both lines work. Since we're adding a property to our **mass**, we use its method **AddProperty**: ![](./images/HyparAddProperty.PNG) The first argument this method needs is a name for the new property, which in this case is **\"Volume\"**: ![](./images/HyparAddPropertyName.PNG) Next the method needs to know what kind of property you're going to add. Eligible values for this argument are **StringProperty** (if we were adding a string value), or in this case **NumericProperty**: ![](./images/HyparAddNumericProperty.PNG) <div style=\"page-break-after: always;\"></div> The new **NumericProperty** needs two arguments: the value, which in this case is the **volume** variable calculated above, and then the **UnitType**, which for this output is **UnitType.Volume**: ![](./images/HyparNewNumericProperty.PNG) Save the file and publish **StarterFunction** again: ![](./images/HyparPublish2019.06.16.png) <div style=\"page-break-after: always;\"></div> When you return to Hypar, click on the **Sample 20 Options** button in **StarterFunction** to create 20 new options, then click on one of the options to open it in the interactive display. In the **Label** dropdown you should see the two new properties you just added: ![](./images/HyparLabels2.PNG) Select **volume** and you should see the value appear in the graphic display on the mass: ![](./images/HyparLabels3.png) Now you see why we specified the **UnitType** for the new property. Specifying the **UnitType** as **UnitType.Volume** tells Hypar to add **m3** to the displayed value to denote cubic meters. Internally Hypar maintains all values in metric units. Functions can calculate the conversion to Imperial units if required. <div style=\"page-break-after: always;\"></div> If you select **area** in the **Label** dropdown, you should see the value notated in square meters: ![](./images/HyparLabels4.png) You're not limited to simple values like these. You can add any static or calculated value you'd like to any Hypar Element (like Mass). -->"
  },
  "InputSchema.html": {
    "href": "InputSchema.html",
    "title": "Input Types | Hypar Docs",
    "keywords": "Input Types Every C# function describes its inputs in the InputSchema portion of the hypar.json . You can edit this in the \"Inputs\" section of the function editor in the Hypar web interface when creating or editing a function, or you can edit it manually in hypar.json for greater control. The following guide demonstrates the different ways inputs can be configured."
  },
  "Revit.html": {
    "href": "Revit.html",
    "title": "NOTE: Hypar for Revit is currently in beta. Do not use Hypar for Revit for production work. | Hypar Docs",
    "keywords": "NOTE: Hypar for Revit is currently in beta. Do not use Hypar for Revit for production work. Getting Started with Hypar for Revit Hypar for Revit is a Revit addin that allows you to connect your Revit models to your Hypar workflows in two ways. If you want live visualization of your hypar workflow as context inside your Revit model you can use the Hypar Hub, to stream the data from your workflow directly into the Revit view. If you would like to integrate Hypar into your design work, you can extract Revit models into Hypar json files, use that json model as part of your Hypar workflow, and then use custom converters to bring your results back into Revit. See below for more information on these two paths. Installation (beta) Download and install the latest Revit plugin installer from releases page . Install the latest Hypar CLI . You'll need this to use the hub command. NOTE: For betas, you'll need to install a beta release of the Hypar CLI which has a slightly different syntax. dotnet tool install -g hypar.cli --version 0.7.3-beta.1 Live Visualization with Hypar Hub Running Start the hub. From the command line do hypar hub . See the hub instructions here . Open Revit, go to the addins tab, and look for the Hypar Panel. These two buttons start and stop the connection to the hyapr hub. Clicking on Hypar Hub Start will start visualization of the hub in your current active 3D view. You may need to rotate/pan/zoom to get the visualization to show. Clicking on Hypar Hub Stop will stop syncing with the hub. NOTE: If after rotate/pan/zoom, you still don't see visualization of your workflow geometry in the view, the hub may be misconfigured. Ensure that the hub references your workflow, and that the workflow is set to sync with the active Revit model. For more information on setting up the hub go here . Troubleshooting The Hypar Revit log is available at C:/Users/{you}/./hypar/hypar-revit.log . If you run into problems, you can send that log to support@hypar.io. Known Limitations When the hub is first started, you will not see any visualizations until you zoom, pan, or rotate. This is a limitation of Revit's RefreshActiveView API which does not work as advertised. Transparency is not currently supported. Converting Revit to and from Hypar The conversion process is designed so anyone using the Elements library can add their own custom converters that will be run by the addin. For more information about writing Element Converters refer to the Sample Converter Repo . Extracting a Revit model to Elements There are three buttons that support different filters while extracting your Revit model into a Hypar model. Each button will only send elements if there are available converters that support that element type. All to Hypar will send everything in the model that can be sent. Some items that are view specific, like Areas, won't be sent in this mode. Selection to Hypar will send only the items that are currently selected. Open Views to Hypar sends all items visible in all open views. Only items from the currently active model will be sent, not all open models. Once you've chosen one of these button the converter will ask you to save a json file, and that json file can be imported into Hypar using the JSON to Model function. Loading an Elements model Loading Elements into your Revit model requires converters that are designed to work with a given Revit template / project. There are currently no converters installed by default, but we have designed the system so that you can build your own specific to your company's needs. See the sample sample converter and documentation here . In the future as more converters come online we will be looking at ways for hte community to automatically share their converters, and if you would like further assistance please reach out to support@hypar.io"
  },
  "Types.html": {
    "href": "Types.html",
    "title": "Types | Hypar Docs",
    "keywords": "Types Let's say that you're a mechanical engineer and you want to introduce a new type to Elements called \"VAV Box\". To introduce this new type, first you need to design it. Where will it fit in the existing Elements type hierarchy? Will an existing base type be used? If so, will the base type need to be changed? Once that's figured out you'll need to write code that represents your type (in the case of Elements as a C# class) and propose that change to the maintainers of the library. The maintainers approve the change and your \"VAV Box\" class is made availble in the next release. Any small iteration on the design of your type based on use or user feedback requires that you repeat the whole cycle. This scenario creates several challenges. First, it requires direct interaction with the maintainers of the Elements library. Most AEC developers don't know how to propose a change to the Elements code and requiring that they undertake our code review process just to introduce a container for data that represents a thing they know is challenging. Second, the maintainers of Elements now \"own\" the \"VAV Box\" type and are therefore required to make sure that they don't break it in the future. Imagine how many hundreds of thousands, or potentially millions, of different types of components are in a building. It's not reasonable to assume that one library is going to be able to encapsulate them all. Finally, although having the base description for a type be C# code works well in the short term, it limits the Elements' team's flexibility in the future to work with other languages. To address these challenges we've introduced the ability for an AEC developer to create a schema which describes their type using JSON schema , and to generate source code from that schema. Schemas can be shared and extended allowing for the growth of a type system from the community. Getting Started Core Concepts Element The primary concept behind Elements types is the Element . An Element is the base type for all things that you will create. It has a unique identifier and a name. That's it. Everything else will be added by you. Primitives An Element is extended by adding properties to a schema. The properties can be of the following types. Curve Arc - An arc defined by a center and a radius. Line - A line defined by a start and end points. Polygon - A collection of vertices describing an enclosed polygonal shape. Material - A material specified using the physically based rendering model. NumericProperty - A property value with a unit type. Plane - A plane described by its origin and normal vector. Profile - A composite type containing a perimeter Polygon and a collection of Polygon Representation - A container for solid operations like Extrude and Sweep . Transform - A right-handed coordinate system with +Z \"up\". Vector3 - A vector with x, y, and z components. Create a Type The first step is to define a schema that represents your type. Good examples for what a schema looks like can be found in the Hypar base schemas. Here's the schema for GeometricElement , a type which extends Element to include a Transform and a Representation . JSON schemas can be authored in any text editor, although an editor with good JSON schema support, like Visual Studio Code , is recommended. Good editors have built in JSON schema validation and code completion. You can also use an online validator . An Example Beam The following schema describes a simple beam with a center line and a cross-section profile. Note that using the allOf field, we can inherit from GeometricElement so that a Beam will extend that base type. { \"$id\": \"https://hypar.io/Schemas/Beam.json\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"description\": \"A beam.\", \"title\": \"Beam\", \"x-namespace\": \"Elements\", \"type\": [\"object\", \"null\"], \"allOf\": [{\"$ref\": \"https://hypar.io/Schemas/GeometricElement.json\"}], \"required\": [\"CenterLine\", \"Profile\"], \"properties\": { \"CenterLine\": { \"description\": \"The center line of the beam.\", \"$ref\": \"https://hypar.io/Schemas/Geometry/Line.json\" }, \"Profile\": { \"description\": \"The beam's cross section.\", \"$ref\": \"https://hypar.io/Schemas/Geometry/Profile.json\" } }, \"additionalProperties\": false } Generate Code for your Type The Hypar CLI can be used to generate code for your type. hypar generate-types -u ./beam.json -o ./Structural Generate Code for your Hypar Function You can specify that your Hypar function requires additional types by declaring those types in the element_types property of the hypar.json . The element_types array contains uris, either as relative file paths or urls to JSON schemas representing types. When you run hypar init code will be generated from each of the schemas specified in the element_types array and placed in your function's /src directory."
  }
}