{
  "api/Elements.Analysis.AnalysisImage.html": {
    "href": "api/Elements.Analysis.AnalysisImage.html",
    "title": "Class AnalysisImage | Hypar Docs",
    "keywords": "Class AnalysisImage A visualization of computed values at locations in space. Use this instead of AnalysisMesh to create a lightweight mesh with an image texture, rather than mesh faces for each pixel. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Analysis_AnalysisImage.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var origin = new Vector3(0, 0); var size = 900; var shape = Polygon.Rectangle(900, 900); Func<Vector3, double> analyze = (v) => { return Math.Min(v.DistanceTo(origin) / size * 2, 1); }; var colorScale = new ColorScale(new List<Elements.Geometry.Color>() { Colors.Magenta, Colors.Yellow, Colors.Lime, Colors.Teal }); var analysisImage = new AnalysisImage(shape, 10, 10, colorScale, analyze); analysisImage.Analyze(); this.Model.AddElement(analysisImage); Inheritance System.Object Element GeometricElement AnalysisMesh AnalysisImage Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members AnalysisMesh._results AnalysisMesh._analyze AnalysisMesh._min AnalysisMesh._max AnalysisMesh.TotalAnalysisLocations AnalysisMesh.ULength AnalysisMesh.VLength AnalysisMesh.Perimeter AnalysisMesh.ColorScale GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Analysis Assembly : Hypar.Elements.dll Syntax public class AnalysisImage : AnalysisMesh, INotifyPropertyChanged, ITessellate Constructors AnalysisImage(Polygon, Double, Double, ColorScale, Func<Vector3, Double>, Guid, String) An AnalysisImage is similar to an AnalysisMesh in that it renders a mesh with analysis colors. However, it uses a mapped image texture rather than mesh vertex colors to lighten the resulting geometry. Declaration public AnalysisImage(Polygon perimeter, double uLength, double vLength, ColorScale colorScale, Func<Vector3, double> analyze, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The perimeter of the mesh image. System.Double uLength The number of divisions in the u direction. System.Double vLength The number of divisions in the v direction. ColorScale colorScale The color scale to be used in the visualization. System.Func < Vector3 , System.Double > analyze A function which takes a location and computes a value. System.Guid id The id of the analysis image. System.String name The name of the analysis image. Properties InterpolateTexture Should the texture be interpolated? False by default. Declaration public bool InterpolateTexture { get; set; } Property Value Type Description System.Boolean If false, renders hard pixels in the texture rather than fading between adjacent pixels. Methods Analyze() Compute a value for each grid cell, and create the required material. Declaration public override void Analyze() Overrides AnalysisMesh.Analyze() Tessellate(ref Mesh, Transform, Color) Gives an element with a mapped texture. Declaration public override void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh Transform transform Color color Overrides AnalysisMesh.Tessellate(ref Mesh, Transform, Color) Implements System.ComponentModel.INotifyPropertyChanged ITessellate Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Analysis.AnalysisMesh.html": {
    "href": "api/Elements.Analysis.AnalysisMesh.html",
    "title": "Class AnalysisMesh | Hypar Docs",
    "keywords": "Class AnalysisMesh A visualization of computed values at locations in space. A maximum of 65,535 analytical values is allowed. For an unlimited number of analytical values, use AnalysisImage. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Analysis_AnalysisMesh.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var perimeter1 = Polygon.L(10, 10, 3); var perimeter2 = Polygon.Ngon(5, 5); var move = new Transform(3, 7, 0); var perimeter = perimeter1.Union((Polygon)perimeter2.Transformed(move)); var mc = new ModelCurve(perimeter); this.Model.AddElement(mc); // Construct a mass from which we will measure // distance to the analysis mesh's cells. var center = perimeter.Centroid(); var mass = new Mass(Polygon.Rectangle(1, 1)); mass.Transform.Move(center); this.Model.AddElement(mass); // The analyze function computes the distance // to the attractor. var analyze = new Func<Vector3, double>((v) => { return center.DistanceTo(v); }); // Construct a color scale from a small number // of colors. var colorScale = new ColorScale(new List<Color>() { Colors.Cyan, Colors.Purple, Colors.Orange }, 10); var analysisMesh = new AnalysisMesh(perimeter, 0.2, 0.2, colorScale, analyze); analysisMesh.Analyze(); Inheritance System.Object Element GeometricElement AnalysisMesh AnalysisImage Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Analysis Assembly : Hypar.Elements.dll Syntax public class AnalysisMesh : GeometricElement, INotifyPropertyChanged, ITessellate Constructors AnalysisMesh(Polygon, Double, Double, ColorScale, Func<Vector3, Double>, Guid, String) Construct an analysis mesh. Declaration public AnalysisMesh(Polygon perimeter, double uLength, double vLength, ColorScale colorScale, Func<Vector3, double> analyze, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The perimeter of the mesh. System.Double uLength The number of divisions in the u direction. System.Double vLength The number of divisions in the v direction. ColorScale colorScale The color scale to be used in the visualization. System.Func < Vector3 , System.Double > analyze A function which takes a location and computes a value. System.Guid id The id of the analysis mesh. System.String name The name of the analysis mesh. Fields _analyze A function that returns a numerical analysis result, given a point in space. Declaration protected Func<Vector3, double> _analyze Field Value Type Description System.Func < Vector3 , System.Double > _max A computed maximum result value. Declaration protected double _max Field Value Type Description System.Double _min A computed minimum result value. Declaration protected double _min Field Value Type Description System.Double _results A list of all the created cells and their resultant value via the _analyze function. Declaration protected List<(BBox3 cell, double value)> _results Field Value Type Description System.Collections.Generic.List < System.ValueTuple < BBox3 , System.Double >> Properties ColorScale The color scale used to represent this analysis mesh. Declaration public ColorScale ColorScale { get; set; } Property Value Type Description ColorScale Perimeter The perimeter of the analysis mesh. Declaration public Polygon Perimeter { get; set; } Property Value Type Description Polygon TotalAnalysisLocations The total number of analysis locations. Declaration [JsonIgnore] public double TotalAnalysisLocations { get; } Property Value Type Description System.Double ULength The length of the cells in the u direction. Declaration public double ULength { get; set; } Property Value Type Description System.Double VLength The length of the cells in the v direction. Declaration public double VLength { get; set; } Property Value Type Description System.Double Methods Analyze() Compute a value for each grid cell. Declaration public virtual void Analyze() Tessellate(ref Mesh, Transform, Color) Tessellate the analysis mesh. Declaration public virtual void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh Transform transform Color color Implements System.ComponentModel.INotifyPropertyChanged ITessellate Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Analysis.ColorScale.html": {
    "href": "api/Elements.Analysis.ColorScale.html",
    "title": "Class ColorScale | Hypar Docs",
    "keywords": "Class ColorScale A range of colors interpolated between a number of key values. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Analysis_ColorScale.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Construct a color scale specifying only // a few colors. The rest will be interpolated. var colorScale = new ColorScale(new List<Color>() { Colors.Cyan, Colors.Purple, Colors.Orange }); var i = 0; foreach (var c in colorScale.Colors) { var panel = new Panel(Polygon.Rectangle(1, 1), new Material($\"Material{i}\", c)); panel.Transform.Move(new Vector3(i * 1.1, 0, 0)); this.Model.AddElement(panel); i++; } Inheritance System.Object ColorScale Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Analysis Assembly : Hypar.Elements.dll Syntax public class ColorScale Constructors ColorScale(List<Color>) Create a ColorScale from a list of colors. The scale will automatically have a domain from 0 to 1. Declaration public ColorScale(List<Color> colors) Parameters Type Name Description System.Collections.Generic.List < Color > colors ColorScale(List<Color>, List<Double>) Construct a ColorScale from a list of colors and corresponding values Declaration public ColorScale(List<Color> colors, List<double> values) Parameters Type Name Description System.Collections.Generic.List < Color > colors The color scale's key values. System.Collections.Generic.List < System.Double > values List of values each color corresponds to on your scale. It expects one value per color, in ascending numerical order. ColorScale(List<Color>, Int32) Construct a color scale with a discrete number of color bands Declaration public ColorScale(List<Color> colors, int colorCount) Parameters Type Name Description System.Collections.Generic.List < Color > colors The color scale's key values. System.Int32 colorCount The number of colors in the final color scale These values will be interpolated between the provided colors. Properties Colors The colors of the scale. Declaration [JsonProperty] public List<Color> Colors { get; } Property Value Type Description System.Collections.Generic.List < Color > Methods GetColor(Double) Get the color from the color scale most closely approximating the provided value. Declaration public Color GetColor(double t) Parameters Type Name Description System.Double t A number within the numerical parameters from when you constructed your color scale. If this was initiated with colorCount, must be between 0 and 1. Returns Type Description Color A color. GetColorForValue(Double) Get the color calculated for a value. Declaration [Obsolete(\"Use GetColor instead.\")] public Color GetColorForValue(double t) Parameters Type Name Description System.Double t Value to return color for. Returns Type Description Color"
  },
  "api/Elements.Analysis.html": {
    "href": "api/Elements.Analysis.html",
    "title": "Namespace Elements.Analysis | Hypar Docs",
    "keywords": "Namespace Elements.Analysis Classes AnalysisImage A visualization of computed values at locations in space. Use this instead of AnalysisMesh to create a lightweight mesh with an image texture, rather than mesh faces for each pixel. AnalysisMesh A visualization of computed values at locations in space. A maximum of 65,535 analytical values is allowed. For an unlimited number of analytical values, use AnalysisImage. ColorScale A range of colors interpolated between a number of key values."
  },
  "api/Elements.Annotations.AlignedDimension.html": {
    "href": "api/Elements.Annotations.AlignedDimension.html",
    "title": "Class AlignedDimension | Hypar Docs",
    "keywords": "Class AlignedDimension A linear dimension aligned along the line between the specified start and end. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Annotations_AlignedDimension.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var l = Polygon.L(5, 5, 1); var m = new Mass(l, 1, BuiltInMaterials.Glass); this.Model.AddElement(m); var offset = 0.125; m.UpdateRepresentations(); var dimensions = new List<LinearDimension>(); foreach (var f in m.Representation.SolidOperations[0].Solid.Faces) { var p = f.Value.Outer.ToPolygon(); var segs = p.Segments(); var plane = p.Plane(); for (var i = 0; i < segs.Length; i++) { var a = segs[i]; var d = new AlignedDimension(a.Start, a.End, offset, a.Direction().Cross(plane.Normal)); dimensions.Add(d); } } Inheritance System.Object Element Annotation LinearDimension AlignedDimension Implements System.ComponentModel.INotifyPropertyChanged IOverrideLinked Inherited Members LinearDimension.Start LinearDimension.End LinearDimension.ReferencePlane LinearDimension.LinkedProperty LinearDimension.ToModelArrowsAndText(Color) LinearDimension.ToModelArrowsAndTexts(IList<LinearDimension>, Color) Annotation.DisplayValue Annotation.Prefix Annotation.Suffix Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax public class AlignedDimension : LinearDimension, INotifyPropertyChanged, IOverrideLinked Constructors AlignedDimension(Vector3, Vector3, Plane, String, String, String) Create an aligned dimension from JSON. Declaration [JsonConstructor] public AlignedDimension(Vector3 start, Vector3 end, Plane referencePlane, string prefix = null, string suffix = null, string displayValue = null) Parameters Type Name Description Vector3 start The start of the dimension. Vector3 end The end of the dimension. Plane referencePlane The plane on which the dimension is projected. System.String prefix Text that appears before the dimension's value. System.String suffix Text that appears after the dimension's value. System.String displayValue Text that appears in place of the dimension's value. AlignedDimension(Vector3, Vector3, Double, Vector3) Create a linear dimension where the reference line is created by offsetting from the line created between start and end by the provided value. Declaration public AlignedDimension(Vector3 start, Vector3 end, double offset = 0, Vector3 offsetDirection = default(Vector3)) Parameters Type Name Description Vector3 start The start of the dimension. Vector3 end The end of the dimension. System.Double offset The offset of the reference line. Vector3 offsetDirection The direction in which the annotation will be offset from the dimension line. Implements System.ComponentModel.INotifyPropertyChanged IOverrideLinked Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Annotations.Annotation.html": {
    "href": "api/Elements.Annotations.Annotation.html",
    "title": "Class Annotation | Hypar Docs",
    "keywords": "Class Annotation An annotation. Inheritance System.Object Element Annotation LinearDimension Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax public abstract class Annotation : Element, INotifyPropertyChanged Constructors Annotation() Create a annotation. Declaration public Annotation() Properties DisplayValue Text to be displayed in place of the annotation's value. Declaration public string DisplayValue { get; set; } Property Value Type Description System.String Prefix Text to be displayed before the annotation's value. Declaration public string Prefix { get; set; } Property Value Type Description System.String Suffix Text to be displayed after the annotation's value. Declaration public string Suffix { get; set; } Property Value Type Description System.String Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Annotations.ContinuousDimension.html": {
    "href": "api/Elements.Annotations.ContinuousDimension.html",
    "title": "Class ContinuousDimension | Hypar Docs",
    "keywords": "Class ContinuousDimension A linear dimension where start and end are projected onto the dimension line. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Annotations_ContinuousDimension.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var l = Polygon.L(5, 5, 1); var m = new Mass(l, 1, BuiltInMaterials.Glass); this.Model.AddElement(m); // Flatten all polygon points along the X axis and sort. var pts = new List<Vector3>(); var yz = new Plane(Vector3.Origin, Vector3.YAxis); foreach (var pt in l.Vertices) { var proj = pt.Project(yz); if (!pts.Contains(proj)) { pts.Add(proj); } } pts.Sort(new DirectionComparer(Vector3.XAxis)); var dimensions = new List<LinearDimension>(); var refLine = new Line(new Vector3(0, 7, 0), new Vector3(5, 10, 0)); for (var i = 0; i < pts.Count - 1; i++) { var d = new ContinuousDimension(pts[i], pts[i + 1], refLine); dimensions.Add(d); } Inheritance System.Object Element Annotation LinearDimension ContinuousDimension Implements System.ComponentModel.INotifyPropertyChanged IOverrideLinked Inherited Members LinearDimension.Start LinearDimension.End LinearDimension.ReferencePlane LinearDimension.LinkedProperty LinearDimension.ToModelArrowsAndText(Color) LinearDimension.ToModelArrowsAndTexts(IList<LinearDimension>, Color) Annotation.DisplayValue Annotation.Prefix Annotation.Suffix Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax public class ContinuousDimension : LinearDimension, INotifyPropertyChanged, IOverrideLinked Constructors ContinuousDimension(Vector3, Vector3, Line) Create a continuous dimension with an optional reference line. The start and end points will be projected onto the dimension line. Declaration public ContinuousDimension(Vector3 start, Vector3 end, Line dimensionLine) Parameters Type Name Description Vector3 start The start of the dimension. Vector3 end The end of the dimension. Line dimensionLine A line on which the start and end points will be projected. ContinuousDimension(Vector3, Vector3, Plane, String, String, String) Create a continuous dimension from JSON. Declaration [JsonConstructor] public ContinuousDimension(Vector3 start, Vector3 end, Plane referencePlane, string prefix = null, string suffix = null, string displayValue = null) Parameters Type Name Description Vector3 start The start of the dimension. Vector3 end The end of the dimension. Plane referencePlane The plane on which the dimension will be projected. System.String prefix Text that appears before the dimension's value. System.String suffix Text that appears after the dimension's value. System.String displayValue Text that appears in place of the dimension's value. Implements System.ComponentModel.INotifyPropertyChanged IOverrideLinked Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Annotations.html": {
    "href": "api/Elements.Annotations.html",
    "title": "Namespace Elements.Annotations | Hypar Docs",
    "keywords": "Namespace Elements.Annotations Classes AlignedDimension A linear dimension aligned along the line between the specified start and end. Annotation An annotation. ContinuousDimension A linear dimension where start and end are projected onto the dimension line. LinearDimension A linear dimension. LinkedPropertyInfo Information describing a linked property for this annotation. For instance, a dimension which represents the width of a mass would store linked property info describing the box element's \"Width\" property. Message An element that stores warning messages. Interfaces IOverrideLinked An annotation element which may be linked to the value of a property of another element. Enums MessageSeverity The severity of a given message."
  },
  "api/Elements.Annotations.IOverrideLinked.html": {
    "href": "api/Elements.Annotations.IOverrideLinked.html",
    "title": "Interface IOverrideLinked | Hypar Docs",
    "keywords": "Interface IOverrideLinked An annotation element which may be linked to the value of a property of another element. Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax public interface IOverrideLinked Properties LinkedProperty The property to which this annotation is linked. Declaration LinkedPropertyInfo LinkedProperty { get; set; } Property Value Type Description LinkedPropertyInfo Null if not linked, otherwise, a LinkedPropertyInfo describing the linked element, property, and override details."
  },
  "api/Elements.Annotations.LinearDimension.html": {
    "href": "api/Elements.Annotations.LinearDimension.html",
    "title": "Class LinearDimension | Hypar Docs",
    "keywords": "Class LinearDimension A linear dimension. Inheritance System.Object Element Annotation LinearDimension AlignedDimension ContinuousDimension Implements System.ComponentModel.INotifyPropertyChanged IOverrideLinked Inherited Members Annotation.DisplayValue Annotation.Prefix Annotation.Suffix Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax public abstract class LinearDimension : Annotation, INotifyPropertyChanged, IOverrideLinked Constructors LinearDimension(Vector3, Vector3, Plane, String, String, String) Create a linear dimension with a reference plane. Declaration [JsonConstructor] public LinearDimension(Vector3 start, Vector3 end, Plane referencePlane, string prefix = null, string suffix = null, string displayValue = null) Parameters Type Name Description Vector3 start The start of the dimension. Vector3 end The end of the dimension. Plane referencePlane The plane on which the start and end points will be projected. System.String prefix Text to be displayed before the dimension's value. System.String suffix Text to be displayed after the dimension's value. System.String displayValue Text to be displayed in place of the dimension's value. Properties End The end of the dimension. Declaration public Vector3 End { get; protected set; } Property Value Type Description Vector3 LinkedProperty Information about the element and property that this dimension is linked to, if any. Declaration public LinkedPropertyInfo LinkedProperty { get; set; } Property Value Type Description LinkedPropertyInfo ReferencePlane The plane on which the start and end points are projected. Declaration public Plane ReferencePlane { get; protected set; } Property Value Type Description Plane Start The start of the dimension. Declaration public Vector3 Start { get; protected set; } Property Value Type Description Vector3 Methods ToModelArrowsAndText(Color) Draw the dimension. Declaration public List<Element> ToModelArrowsAndText(Color color) Parameters Type Name Description Color color Returns Type Description System.Collections.Generic.List < Element > ToModelArrowsAndTexts(IList<LinearDimension>, Color) Draw a set of dimensions. Declaration public static List<Element> ToModelArrowsAndTexts(IList<LinearDimension> dimensions, Color color = default(Color)) Parameters Type Name Description System.Collections.Generic.IList < LinearDimension > dimensions Color color Returns Type Description System.Collections.Generic.List < Element > Implements System.ComponentModel.INotifyPropertyChanged IOverrideLinked Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Annotations.LinkedPropertyInfo.html": {
    "href": "api/Elements.Annotations.LinkedPropertyInfo.html",
    "title": "Class LinkedPropertyInfo | Hypar Docs",
    "keywords": "Class LinkedPropertyInfo Information describing a linked property for this annotation. For instance, a dimension which represents the width of a mass would store linked property info describing the box element's \"Width\" property. Inheritance System.Object LinkedPropertyInfo Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax public class LinkedPropertyInfo Properties ElementId The id of the element that this property is linked to. Declaration public Guid ElementId { get; set; } Property Value Type Description System.Guid Index If the linked property is an array, this is the index of the value in the array this annotation represents. Declaration public int? Index { get; set; } Property Value Type Description System.Nullable < System.Int32 > OverrideName The name of the override containing the linked property. Declaration public string OverrideName { get; set; } Property Value Type Description System.String PropertyName The name of the linked property. Declaration public string PropertyName { get; set; } Property Value Type Description System.String VisibleOnlyOnSelection If true, this annotation should only be visible when the linked element is selected. Declaration public bool VisibleOnlyOnSelection { get; set; } Property Value Type Description System.Boolean"
  },
  "api/Elements.Annotations.Message.html": {
    "href": "api/Elements.Annotations.Message.html",
    "title": "Class Message | Hypar Docs",
    "keywords": "Class Message An element that stores warning messages. Inheritance System.Object Element GeometricElement Message Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class Message : GeometricElement, INotifyPropertyChanged Constructors Message() Empty constructor. Declaration public Message() Message(String, String, String, MessageSeverity, Transform, Material, Representation, Boolean, Guid, String) Default json constructor for a message that may have geometry. Declaration [JsonConstructor] public Message(string message, string shortMessage, string stackTrace, MessageSeverity severity, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description System.String message System.String shortMessage System.String stackTrace MessageSeverity severity Transform transform Material material Representation representation System.Boolean isElementDefinition System.Guid id System.String name Properties ErrorMaterial The material used for messages with \"Error\" severity. Declaration public static Material ErrorMaterial { get; set; } Property Value Type Description Material InfoMaterial The material used for messages with \"Info\" severity. Declaration public static Material InfoMaterial { get; set; } Property Value Type Description Material MessageText A warning message for the user. Declaration [JsonProperty(\"Message\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public string MessageText { get; set; } Property Value Type Description System.String Severity Developer specific message about the failure in the code. Declaration [JsonProperty(\"Severity\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] [JsonConverter(typeof(StringEnumConverter))] public MessageSeverity Severity { get; set; } Property Value Type Description MessageSeverity ShortMessage A short message for the user. For a more detailed message, use MessageText. Declaration [JsonProperty(\"ShortMessage\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public string ShortMessage { get; set; } Property Value Type Description System.String StackTrace Developer specific message about the failure in the code. Declaration [JsonProperty(\"Stack Trace\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public string StackTrace { get; set; } Property Value Type Description System.String WarningMaterial The material used for messages with \"Warning\" severity. Declaration public static Material WarningMaterial { get; set; } Property Value Type Description Material Methods DetailsFromException(Exception) Extract the string details including any stack trace from the exception. Declaration public static string DetailsFromException(Exception e) Parameters Type Name Description System.Exception e The Exception. Returns Type Description System.String Error(Nullable<Vector3>, String) Create an error message. Declaration public static Message Error(Vector3? point, string message = null) Parameters Type Name Description System.Nullable < Vector3 > point System.String message Returns Type Description Message FromCurve(String, BoundedCurve, MessageSeverity, Double, String, String, String) Create a simple message along a curve. Declaration public static Message FromCurve(string messageText, BoundedCurve curve, MessageSeverity severity = MessageSeverity.Warning, double sideLength = 0.3, string name = null, string stackTrace = null, string shortMessage = null) Parameters Type Name Description System.String messageText The message to the user. BoundedCurve curve MessageSeverity severity The severity of the message. System.Double sideLength System.String name The name given to the message. System.String stackTrace Any stack trace associated with the message. System.String shortMessage A short message. Returns Type Description Message FromPoint(String, Nullable<Vector3>, MessageSeverity, Double, String, String, String) Create a simple message at a point. Declaration public static Message FromPoint(string messageText, Vector3? point, MessageSeverity severity = MessageSeverity.Warning, double sideLength = 0.3, string name = null, string stackTrace = null, string shortMessage = null) Parameters Type Name Description System.String messageText The message to the user. System.Nullable < Vector3 > point MessageSeverity severity The severity of the message. System.Double sideLength System.String name The name given to the message. System.String stackTrace Any stack trace associated with the message. System.String shortMessage A short message. Returns Type Description Message FromPolygon(String, Polygon, MessageSeverity, Double, String, String, String) Create a simple message from a polygon. Declaration public static Message FromPolygon(string messageText, Polygon polygon, MessageSeverity severity = MessageSeverity.Warning, double height = 0, string name = null, string stackTrace = null, string shortMessage = null) Parameters Type Name Description System.String messageText The message to the user. Polygon polygon MessageSeverity severity The severity of the message. System.Double height System.String name The name given to the message. System.String stackTrace Any stack trace associated with the message. System.String shortMessage A short message. Returns Type Description Message FromPolygons(String, IEnumerable<Polygon>, MessageSeverity, Double, String, String, String) Create a simple message from polygons. Declaration public static Message[] FromPolygons(string messageText, IEnumerable<Polygon> polygons, MessageSeverity severity = MessageSeverity.Warning, double height = 0, string name = null, string stackTrace = null, string shortMessage = null) Parameters Type Name Description System.String messageText The message to the user. System.Collections.Generic.IEnumerable < Polygon > polygons MessageSeverity severity The severity of the message. System.Double height System.String name The name given to the message. System.String stackTrace Any stack trace associated with the message. System.String shortMessage A short message. Returns Type Description Message [] FromText(String, String, MessageSeverity, String, String) Create a simple message from the given text. Declaration public static Message FromText(string message, string name = null, MessageSeverity severity = MessageSeverity.Warning, string stackTrace = null, string shortMessage = null) Parameters Type Name Description System.String message The message to the user. System.String name The name given to the message. MessageSeverity severity The severity of the message. System.String stackTrace Any stack trace associated with the message. System.String shortMessage A short message. Returns Type Description Message Info(Nullable<Vector3>, String) Create an informational message. Declaration public static Message Info(Vector3? point, string message = null) Parameters Type Name Description System.Nullable < Vector3 > point System.String message Returns Type Description Message Warning(Nullable<Vector3>, String) Create a warning message. Declaration public static Message Warning(Vector3? point, string message = null) Parameters Type Name Description System.Nullable < Vector3 > point System.String message Returns Type Description Message Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Annotations.MessageSeverity.html": {
    "href": "api/Elements.Annotations.MessageSeverity.html",
    "title": "Enum MessageSeverity | Hypar Docs",
    "keywords": "Enum MessageSeverity The severity of a given message. Namespace : Elements.Annotations Assembly : Hypar.Elements.dll Syntax public enum MessageSeverity Fields Name Description Error Message is for an error. Info Message is for information purposes only. Warning Message is for a warning."
  },
  "api/Elements.BaseCeiling.html": {
    "href": "api/Elements.BaseCeiling.html",
    "title": "Class BaseCeiling | Hypar Docs",
    "keywords": "Class BaseCeiling The base class for all ceilings. Inheritance System.Object Element GeometricElement BaseCeiling OpenCeiling SolidCeiling TiledCeiling Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public abstract class BaseCeiling : GeometricElement, INotifyPropertyChanged Constructors BaseCeiling(Polygon, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling from perimeter. Declaration protected BaseCeiling(Polygon perimeter, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan perimeter of the ceiling. It must lie on the XY plane. Z coordinate will be used as elevation Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. BaseCeiling(Polygon, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling from perimeter and an elevation. Declaration protected BaseCeiling(Polygon perimeter, double elevation, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double elevation The elevation of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. BaseCeiling(Polygon, Double, Guid, Material, Transform, Representation, Boolean, String) Construct a ceiling. It's a private constructor that doesn't add elevation to transform. Declaration [JsonConstructor] protected BaseCeiling(Polygon perimeter, double elevation, Guid id = default(Guid), Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double elevation The elevation of the ceiling. System.Guid id The id of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.String name The name of the ceiling. Properties Elevation The elevation of the ceiling. Declaration public double Elevation { get; protected set; } Property Value Type Description System.Double Perimeter The perimeter of the ceiling. Declaration public Polygon Perimeter { get; protected set; } Property Value Type Description Polygon Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.BaseError.html": {
    "href": "api/Elements.BaseError.html",
    "title": "Class BaseError | Hypar Docs",
    "keywords": "Class BaseError Represents error that occur during application execution Inheritance System.Object BaseError ElementError Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class BaseError Constructors BaseError(Exception) Initializes a new instance of BaseError class base on System.Exception info Declaration public BaseError(Exception exception) Parameters Type Name Description System.Exception exception s BaseError(String) Initializes a new instance of BaseError class Declaration public BaseError(string message) Parameters Type Name Description System.String message The error message BaseError(String, String) Initializes a new instance of BaseError class Declaration public BaseError(string message, string stackTrace) Parameters Type Name Description System.String message The error message System.String stackTrace A string representation of the immediate frames on the call stack Properties Message Gets a message that describes the current error Declaration public string Message { get; } Property Value Type Description System.String StackTrace Gets a string representation of the immediate frames on the call stack Declaration public string StackTrace { get; } Property Value Type Description System.String"
  },
  "api/Elements.Beam.html": {
    "href": "api/Elements.Beam.html",
    "title": "Class Beam | Hypar Docs",
    "keywords": "Class Beam A structural framing element defined by a center line curve and a profile. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Beam.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a framing type. var profile = _wideFlangeFactory.GetProfileByType(WideFlangeProfileType.W10x100); // Create a straight beam. var line = new Line(Vector3.Origin, new Vector3(5, 0, 5)); var linearBeam = new Beam(line, profile, 0, 0, 15, material: BuiltInMaterials.Wood); var lineT = line.TransformAt(0).ToModelCurves(linearBeam.Transform); // Create a polygon beam. var polygon = Polygon.Ngon(5, 2); var polygonBeam = new Beam(polygon, profile, 0, 0, 45, new Transform(6, 0, 0), BuiltInMaterials.Steel); var polyT = polygon.TransformAt(0).ToModelCurves(polygonBeam.Transform); // Create a curved beam. var arc = new Arc(new Transform(Vector3.Origin, Vector3.XAxis), 5.0, Math.PI * 0.25, Math.PI * 0.75); var arcBeam = new Beam(arc, profile, 0, 0, 0, new Transform(12, 0, 0), BuiltInMaterials.Steel); var arcT = arc.TransformAt(arc.Domain.Min).ToModelCurves(arcBeam.Transform); // Create an elliptical beam. var ellipticalArc = new EllipticalArc(Vector3.Origin, 2.5, 1.5, 0, 210); var ellipticBeam = new Beam(ellipticalArc, profile, 0, 0, 0, new Transform(18, 0, 0), BuiltInMaterials.Steel); var ellipseT = ellipticalArc.TransformAt(ellipticalArc.Domain.Min).ToModelCurves(ellipticBeam.Transform); Inheritance System.Object Element GeometricElement StructuralFraming Beam Implements System.ComponentModel.INotifyPropertyChanged Inherited Members StructuralFraming.Curve StructuralFraming.StartSetback StructuralFraming.EndSetback StructuralFraming.Profile StructuralFraming.Rotation StructuralFraming.Volume() StructuralFraming.ProfileTransformed() StructuralFraming.UpdateRepresentations() GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Beam : StructuralFraming, INotifyPropertyChanged Constructors Beam() Construct a beam. Declaration public Beam() Beam(BoundedCurve, Profile, Transform, Material, Representation, Boolean, Guid, String) Construct a beam. Declaration public Beam(BoundedCurve curve, Profile profile, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description BoundedCurve curve The beam's center line. Profile profile The beam's profile. Transform transform The beam's transform. Material material The beam's material. Representation representation The beam's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the transform. System.String name The name of the transform. Beam(BoundedCurve, Profile, Double, Double, Double, Transform, Material, Representation, Boolean, Guid, String) Construct a beam. Declaration public Beam(BoundedCurve curve, Profile profile, double startSetback, double endSetback, double rotation, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description BoundedCurve curve The beam's center line. Profile profile The beam's profile. System.Double startSetback The setback of the beam's geometry at the start. System.Double endSetback The setback of the beam's geometry at the end. System.Double rotation An optional rotation of the beam's cross section around it's axis. Transform transform The beam's transform. Material material The beam's material. Representation representation The beam's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the transform. System.String name The name of the transform. Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Brace.html": {
    "href": "api/Elements.Brace.html",
    "title": "Class Brace | Hypar Docs",
    "keywords": "Class Brace A Brace is a structural framing element which is often diagonal. Inheritance System.Object Element GeometricElement StructuralFraming Brace Implements System.ComponentModel.INotifyPropertyChanged Inherited Members StructuralFraming.Curve StructuralFraming.StartSetback StructuralFraming.EndSetback StructuralFraming.Profile StructuralFraming.Rotation StructuralFraming.Volume() StructuralFraming.ProfileTransformed() StructuralFraming.UpdateRepresentations() GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Brace : StructuralFraming, INotifyPropertyChanged Constructors Brace(BoundedCurve, Profile, Material, Double, Double, Double, Transform, Boolean, Guid, String) Construct a Brace. Declaration public Brace(BoundedCurve curve, Profile profile, Material material = null, double startSetback = 0, double endSetback = 0, double rotation = 0, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description BoundedCurve curve The brace's center line. Profile profile The brace's profile. Material material The brace's material. System.Double startSetback The setback of the brace's geometry at the start. System.Double endSetback The setback of the brace's geometry at the end. System.Double rotation An optional rotation of the beam's profile around its axis. Transform transform The brace's transform. System.Boolean isElementDefinition Is this an element definition? System.Guid id The brace's id. System.String name The brace's name. Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.BuiltInMaterials.html": {
    "href": "api/Elements.BuiltInMaterials.html",
    "title": "Class BuiltInMaterials | Hypar Docs",
    "keywords": "Class BuiltInMaterials Built in materials. Inheritance System.Object BuiltInMaterials Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class BuiltInMaterials Properties Black Black Declaration public static Material Black { get; } Property Value Type Description Material Concrete Concrete. Declaration public static Material Concrete { get; } Property Value Type Description Material Default The default material. Declaration public static Material Default { get; } Property Value Type Description Material Edges Edges Declaration public static Material Edges { get; } Property Value Type Description Material EdgesHighlighted Edges Highlighted Declaration public static Material EdgesHighlighted { get; } Property Value Type Description Material Glass Glass. Declaration public static Material Glass { get; } Property Value Type Description Material Mass Default material used to represent masses. Declaration public static Material Mass { get; } Property Value Type Description Material Points Points Declaration public static Material Points { get; } Property Value Type Description Material Steel Steel. Declaration public static Material Steel { get; } Property Value Type Description Material Topography Topography Declaration public static Material Topography { get; } Property Value Type Description Material Trans Fully transparent material. Declaration public static Material Trans { get; } Property Value Type Description Material Void Void Declaration public static Material Void { get; } Property Value Type Description Material Wood Wood. Declaration public static Material Wood { get; } Property Value Type Description Material XAxis X Axis Declaration public static Material XAxis { get; } Property Value Type Description Material YAxis Y Axis Declaration public static Material YAxis { get; } Property Value Type Description Material ZAxis Z Axis Declaration public static Material ZAxis { get; } Property Value Type Description Material"
  },
  "api/Elements.Column.html": {
    "href": "api/Elements.Column.html",
    "title": "Class Column | Hypar Docs",
    "keywords": "Class Column A vertical structural framing element. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Column.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a framing type. var profile = _profileFactory.GetProfileByType(WideFlangeProfileType.W10x100); // Create a column. var column = new Column(Vector3.Origin, 3.0, null, profile, material: BuiltInMaterials.Steel); Inheritance System.Object Element GeometricElement StructuralFraming Column Implements System.ComponentModel.INotifyPropertyChanged Inherited Members StructuralFraming.Curve StructuralFraming.StartSetback StructuralFraming.EndSetback StructuralFraming.Profile StructuralFraming.Rotation StructuralFraming.Volume() StructuralFraming.ProfileTransformed() StructuralFraming.UpdateRepresentations() GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Column : StructuralFraming, INotifyPropertyChanged Constructors Column() Construct a column. Declaration public Column() Column(Vector3, Double, Curve, Profile, Transform, Material, Representation, Boolean, Guid, String) Construct a Column. Declaration public Column(Vector3 location, double height, Curve curve, Profile profile, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Vector3 location The location of the base of the column. System.Double height The column's height. Curve curve The center line of the column. Will be ignored, so you can use 'null'. This parameter is required to support schema Profile profile The column's profile. Transform transform The column's transform. Material material The column's material. Representation representation The column's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The column's id. System.String name The column's name. Column(Vector3, Double, Curve, Profile, Double, Double, Double, Transform, Material, Representation, Boolean, Guid, String) Construct a Column. Declaration public Column(Vector3 location, double height, Curve curve, Profile profile, double startSetback, double endSetback, double rotation, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Vector3 location The location of the base of the column. System.Double height The column's height. Curve curve The center line of the column. Will be ignored, so you can use 'null'. This parameter is required to support schema Profile profile The column's profile. System.Double startSetback The setback of the column's extrusion from the base of the column. System.Double endSetback The setback of the column's extrusion from the top of the column. System.Double rotation An optional rotation of the column's profile around its axis. Transform transform The column's transform. Material material The column's material. Representation representation The column's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The column's id. System.String name The column's name. Properties Height The height of the column. Declaration public double Height { get; set; } Property Value Type Description System.Double Location The location of the base of the column. Declaration public Vector3 Location { get; set; } Property Value Type Description Vector3 Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ContentCatalog.html": {
    "href": "api/Elements.ContentCatalog.html",
    "title": "Class ContentCatalog | Hypar Docs",
    "keywords": "Class ContentCatalog A collection of content elements. Inheritance System.Object Element ContentCatalog Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class ContentCatalog : Element, INotifyPropertyChanged Constructors ContentCatalog(IList<ContentElement>, IList<Element>, Guid, String) Construct a content catalog. Declaration [JsonConstructor] public ContentCatalog(IList<ContentElement> content, IList<Element> referenceConfiguration, Guid id = default(Guid), string name = null) Parameters Type Name Description System.Collections.Generic.IList < ContentElement > content System.Collections.Generic.IList < Element > referenceConfiguration System.Guid id System.String name Properties Content The content elements in this catalog. Declaration [JsonProperty(\"Content\", Required = Required.Always)] [Required] public IList<ContentElement> Content { get; set; } Property Value Type Description System.Collections.Generic.IList < ContentElement > ReferenceConfiguration An example arrangement of the elements contained in this catalog. Declaration [JsonProperty(\"ReferenceConfiguration\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public IList<Element> ReferenceConfiguration { get; set; } Property Value Type Description System.Collections.Generic.IList < Element > Methods FromJson(String) Deserialize the give JSON text into the ContentCatalog Declaration public static ContentCatalog FromJson(string json) Parameters Type Name Description System.String json Returns Type Description ContentCatalog ToJson() Convert the ContentCatalog into its JSON representation. Declaration public string ToJson() Returns Type Description System.String UseReferenceOrientation() Modifies the transforms of the content internal to this catalog to use the orientation of the reference instances that exist. Declaration public void UseReferenceOrientation() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ContentElement.html": {
    "href": "api/Elements.ContentElement.html",
    "title": "Class ContentElement | Hypar Docs",
    "keywords": "Class ContentElement An element representing user content. Inheritance System.Object Element GeometricElement ContentElement Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class ContentElement : GeometricElement, INotifyPropertyChanged Constructors ContentElement(String, BBox3, Double, Vector3, Transform, Material, Representation, Boolean, Guid, String) This constructor adds backwards compatibility with the old constructor, before Symbols were added. Declaration public ContentElement(string gltfLocation, BBox3 boundingBox, double gltfScaleToMeters, Vector3 sourceDirection, Transform transform, Material material, Representation representation, bool isElementDefinition, Guid id, string name) Parameters Type Name Description System.String gltfLocation The path to the .glb file. BBox3 boundingBox The BBox3 of this Content Element. System.Double gltfScaleToMeters The number required to scale this contents dimensions to meters. Used during gltf merging. Vector3 sourceDirection The direction the element was facing when it was extracted from it's source. Transform transform The transform of this ContentElement. Material material The material, used for the BBox representation of this element. Representation representation The representation which will be updated when needed. System.Boolean isElementDefinition Should the element be used to create instances, or should it be inserted into a 3D scene. System.Guid id The guid of this element. System.String name The name of this element. ContentElement(String, BBox3, Double, Vector3, Transform, Material, Representation, Boolean, Guid, String, String) This constructor adds the ability to include additionalProperties. The additional properties should be a dictionary that has been serialized to a string, they are deserialized during construction. This is used in Revit Content workflows to store instance parameter data. Declaration public ContentElement(string gltfLocation, BBox3 boundingBox, double gltfScaleToMeters, Vector3 sourceDirection, Transform transform, Material material, Representation representation, bool isElementDefinition, Guid id, string name, string additionalProperties) Parameters Type Name Description System.String gltfLocation The path to the .glb file. BBox3 boundingBox The BBox3 of this Content Element. System.Double gltfScaleToMeters The number required to scale this contents dimensions to meters. Used during gltf merging. Vector3 sourceDirection The direction the element was facing when it was extracted from it's source. Transform transform The transform of this ContentElement. Material material The material, used for the BBox representation of this element. Representation representation The representation which will be updated when needed. System.Boolean isElementDefinition Should the element be used to create instances, or should it be inserted into a 3D scene. System.Guid id The guid of this element. System.String name The name of this element. System.String additionalProperties The string json serialization of a dictionary of additional parameters. ContentElement(String, BBox3, Double, Vector3, IList<Symbol>, Transform, Material, Representation, Boolean, Guid, String) Construct a content element. Declaration [JsonConstructor] public ContentElement(string gltfLocation, BBox3 boundingBox, double gltfScaleToMeters, Vector3 sourceDirection, IList<Symbol> symbols, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description System.String gltfLocation BBox3 boundingBox System.Double gltfScaleToMeters Vector3 sourceDirection System.Collections.Generic.IList < Symbol > symbols Transform transform Material material Representation representation System.Boolean isElementDefinition System.Guid id System.String name ContentElement(String, BBox3, Double, Vector3, IList<Symbol>, Transform, Material, Representation, Boolean, Guid, String, String) This constructor adds the ability to include additionalProperties. The additional properties should be a dictionary that has been serialized to a string, they are deserialized during construction. This is used in Revit Content workflows to store instance parameter data. Declaration public ContentElement(string gltfLocation, BBox3 boundingBox, double gltfScaleToMeters, Vector3 sourceDirection, IList<Symbol> symbols, Transform transform, Material material, Representation representation, bool isElementDefinition, Guid id, string name, string additionalProperties) Parameters Type Name Description System.String gltfLocation The path to the .glb file. BBox3 boundingBox The BBox3 of this Content Element. System.Double gltfScaleToMeters The number required to scale this contents dimensions to meters. Used during gltf merging. Vector3 sourceDirection The direction the element was facing when it was extracted from it's source. System.Collections.Generic.IList < Symbol > symbols Any additional symbol representations of this content element. Transform transform The transform of this ContentElement. Material material The material, used for the BBox representation of this element. Representation representation The representation which will be updated when needed. System.Boolean isElementDefinition Should the element be used to create instances, or should it be inserted into a 3D scene. System.Guid id The guid of this element. System.String name The name of this element. System.String additionalProperties The string json serialization of a dictionary of additional parameters. Properties BoundingBox The bounding box of the content. Declaration [JsonProperty(\"Bounding Box\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public BBox3 BoundingBox { get; set; } Property Value Type Description BBox3 GltfLocation The URI of the gltf for this element. Declaration [JsonProperty(\"gltfLocation\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public string GltfLocation { get; set; } Property Value Type Description System.String GltfScaleToMeters The scale needed to convert the gltf to meters. Declaration [JsonProperty(\"Gltf Scale to Meters\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public double GltfScaleToMeters { get; set; } Property Value Type Description System.Double SourceDirection A vector indicating the direction the source object was originally facing. Declaration [JsonProperty(\"SourceDirection\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public Vector3 SourceDirection { get; set; } Property Value Type Description Vector3 Symbols Alternate symbolic representations of the object. Declaration [JsonProperty(\"Symbols\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public IList<Symbol> Symbols { get; set; } Property Value Type Description System.Collections.Generic.IList < Symbol > Methods UpdateRepresentations() Update the ContentElement representation with a solid of the Bounding Box. This is used in the absence of finding a Gltf for import. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.CoplanarSetClassification.html": {
    "href": "api/Elements.CoplanarSetClassification.html",
    "title": "Enum CoplanarSetClassification | Hypar Docs",
    "keywords": "Enum CoplanarSetClassification Coplanar classification. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum CoplanarSetClassification Fields Name Description ACoplanarB A coplanar with B BCoplanarA B coplanar with A None None"
  },
  "api/Elements.DirectionalLight.html": {
    "href": "api/Elements.DirectionalLight.html",
    "title": "Class DirectionalLight | Hypar Docs",
    "keywords": "Class DirectionalLight A directional light. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_DirectionalLight.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a directional light. var origin = new Vector3(10, 10, 10); var light = new DirectionalLight(Colors.White, new Transform(origin, origin.Unitized()), 1.0); var sunMaterial = new Material(\"Sun\", Colors.Yellow, unlit: true); // Create a model curve to visualize the light direction. var dirCurve = new ModelCurve(new Line(light.Transform.Origin, light.Transform.Origin + light.Transform.ZAxis.Negate() * 10), sunMaterial); var floor = new Floor(Polygon.Rectangle(20, 20), 0.1); var column = new Column(new Vector3(5, 5), 5.0, null, Polygon.Rectangle(0.2, 0.2)); var mass = new Mass(Polygon.Rectangle(1, 1), 1.0, sunMaterial, new Transform(light.Transform.Origin)); Inheritance System.Object Element Light DirectionalLight Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Light.LightType Light.Intensity Light.Color Light.Transform Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class DirectionalLight : Light, INotifyPropertyChanged Constructors DirectionalLight(Color, Transform, Double, Guid, String) Create a directional light. Declaration public DirectionalLight(Color color, Transform transform, double intensity = 1, Guid id = default(Guid), string name = \"Sun\") Parameters Type Name Description Color color The color of the light. Transform transform The light's transform. System.Double intensity The intensity of the light measured in lux. System.Guid id The unique identifier of the light. System.String name The name of the light. Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Domain1d.html": {
    "href": "api/Elements.Domain1d.html",
    "title": "Struct Domain1d | Hypar Docs",
    "keywords": "Struct Domain1d A 1 dimensional interval or domain. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements Assembly : Hypar.Elements.dll Syntax public struct Domain1d Constructors Domain1d(Double, Double) Construct a 1D Domain Declaration public Domain1d(double min = 0, double max = 1) Parameters Type Name Description System.Double min The lower bound of the domain. System.Double max The upper bound of the domain. Properties Length The length of the domain  Max-Min. Note that for non-increasing domains this value can be negative. Declaration [JsonIgnore] public readonly double Length { get; } Property Value Type Description System.Double Max The upper bound of the domain Declaration public readonly double Max { get; } Property Value Type Description System.Double Min The lower bound of the domain Declaration public readonly double Min { get; } Property Value Type Description System.Double Methods DivideByCount(Int32) Split a domain evenly into N subdomains. Declaration public Domain1d[] DivideByCount(int n) Parameters Type Name Description System.Int32 n The number of domains Returns Type Description Domain1d [] An array of N equally-sized subdomains. IsCloseToBoundary(Double) Test if a position is within global tolerance of the domain boundary. Declaration public bool IsCloseToBoundary(double position) Parameters Type Name Description System.Double position The position to test. Returns Type Description System.Boolean True if the position is within tolerance of the domain Min or Max. Mid() Calculate the middle of the domain. Declaration public double Mid() Returns Type Description System.Double SplitAt(Double) Split domain into two at a position within its extents. Positions at the domain's ends will be rejected. Declaration public Domain1d[] SplitAt(double position) Parameters Type Name Description System.Double position The position value at which to split the domain. Returns Type Description Domain1d [] An array of 2 1d domains split at the designated position. ToString() Convert to string of the form \"From Min to Max\" Declaration public override string ToString() Returns Type Description System.String Overrides System.ValueType.ToString()"
  },
  "api/Elements.DomainExtensions.html": {
    "href": "api/Elements.DomainExtensions.html",
    "title": "Class DomainExtensions | Hypar Docs",
    "keywords": "Class DomainExtensions Extension and utility methods for mathematical operations. Inheritance System.Object DomainExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class DomainExtensions Methods ApproximatelyEquals(Double, Double, Double) Test if two values are approximately equal to each other with an optional tolerance value. Declaration public static bool ApproximatelyEquals(this double value, double other, double tolerance = 1E-05) Parameters Type Name Description System.Double value The first value to test. System.Double other The other value to test. System.Double tolerance The threshold for equality. If not supplied, the global tolerance will be used. Returns Type Description System.Boolean True if |other - value| < tolerance MapBetweenDomains(Double, Domain1d, Domain1d) Map/Scale a value from one domain to another. 3 mapped from (2,4) to (10, 20) would be 15. Declaration public static double MapBetweenDomains(this double value, Domain1d source, Domain1d target) Parameters Type Name Description System.Double value The value to map. Domain1d source The source domain to map from. Domain1d target The target domain to map to. Returns Type Description System.Double MapFromDomain(Double, Domain1d) Map/Normalize a value from a domain to the domain (0,1). Declaration public static double MapFromDomain(this double value, Domain1d domain) Parameters Type Name Description System.Double value The value to map Domain1d domain The domain to map from. Returns Type Description System.Double (value - domain.Min) / domain.Length MapToDomain(Double, Domain1d) Map/scale a value between 0-1 to a target domain. Will not reject values outside 0-1. Declaration public static double MapToDomain(this double value, Domain1d domain) Parameters Type Name Description System.Double value The value to map. Domain1d domain The domain to map to. Returns Type Description System.Double value * domain.Length + domain.Min"
  },
  "api/Elements.EdgeDisplayDashMode.html": {
    "href": "api/Elements.EdgeDisplayDashMode.html",
    "title": "Enum EdgeDisplayDashMode | Hypar Docs",
    "keywords": "Enum EdgeDisplayDashMode Different ways to interpret the Width property of a EdgeDisplaySettings. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum EdgeDisplayDashMode Fields Name Description None Dashed display is not enabled. Dash size is ignored. ScreenUnits Dash sizes are specified in pixels, and maintain a constant size when zooming. WorldUnits Dash sizes are specified in meters, and maintain a constant size relative to the model."
  },
  "api/Elements.EdgeDisplaySettings.html": {
    "href": "api/Elements.EdgeDisplaySettings.html",
    "title": "Class EdgeDisplaySettings | Hypar Docs",
    "keywords": "Class EdgeDisplaySettings Settings for how a curve or line should be displayed. Inheritance System.Object EdgeDisplaySettings Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class EdgeDisplaySettings Properties DashMode Whether and how to display dashes along the line. Declaration public EdgeDisplayDashMode DashMode { get; set; } Property Value Type Description EdgeDisplayDashMode DashSize The size of the dash. If Mode is set to None, this value will be ignored. Note that the units for this value (screen vs world) are affected by the choice of Dash Mode. Declaration public double DashSize { get; set; } Property Value Type Description System.Double GapSize The size of the gaps between dashes. If Mode is set to None, this value will be ignored. If this value is set to null, DashSize will be used. Note that the units for this value (screen vs world) are affected by the choice of Dash Mode. Declaration public double? GapSize { get; set; } Property Value Type Description System.Nullable < System.Double > LineWidth The width of the line. If Mode is set to Screen Units, this will be in pixels (and rounded to the nearest integer). If set to World Units, this will be in meters. Declaration public double LineWidth { get; set; } Property Value Type Description System.Double WidthMode How the Width should be interpreted. If set to Screen Units, Width is interpreted as a constant pixel width (and rounded to the nearest integer). If set to World Units, Width is interpreted as a constant meter width. Declaration public EdgeDisplayWidthMode WidthMode { get; set; } Property Value Type Description EdgeDisplayWidthMode"
  },
  "api/Elements.EdgeDisplayWidthMode.html": {
    "href": "api/Elements.EdgeDisplayWidthMode.html",
    "title": "Enum EdgeDisplayWidthMode | Hypar Docs",
    "keywords": "Enum EdgeDisplayWidthMode Different ways to interpret the Width property of a EdgeDisplaySettings. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum EdgeDisplayWidthMode Fields Name Description ScreenUnits The Width property is interpreted as a constant pixel width (and rounded to the nearest integer). WorldUnits The Width property is interpreted as a constant meter width."
  },
  "api/Elements.Element.html": {
    "href": "api/Elements.Element.html",
    "title": "Class Element | Hypar Docs",
    "keywords": "Class Element An object which is identified with a unique identifier and a name. Inheritance System.Object Element Annotation ContentCatalog ElementInstance ElementProxy<T> GeometricElement Profile Light MappingBase Material CellComplex Implements System.ComponentModel.INotifyPropertyChanged Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public abstract class Element : INotifyPropertyChanged Constructors Element(Guid, String) Construct an element. Declaration [JsonConstructor] public Element(Guid id = default(Guid), string name = null) Parameters Type Name Description System.Guid id The unique id of the element. System.String name The name of the element. Properties AdditionalProperties A collection of additional properties. Declaration [JsonExtensionData] public IDictionary<string, object> AdditionalProperties { get; set; } Property Value Type Description System.Collections.Generic.IDictionary < System.String , System.Object > Id A unique id. Declaration [JsonProperty(\"Id\", Required = Required.Always)] [Required(AllowEmptyStrings = true)] public Guid Id { get; set; } Property Value Type Description System.Guid Name A name. Declaration [JsonProperty(\"Name\", Required = Required.Default)] public string Name { get; set; } Property Value Type Description System.String Methods GetMapping(String) Retrieve a mapping for a given context. Declaration public MappingBase GetMapping(string context) Parameters Type Name Description System.String context The context of the mapping being requested. Returns Type Description MappingBase The mapping if it exists, null if not. GetMapping<T>(String) Retrieve a mapping for a given context. Declaration public T GetMapping<T>(string context) where T : MappingBase Parameters Type Name Description System.String context The context of the mapping being requested. Returns Type Description T Type Parameters Name Description T The Type of mapping expected. RaisePropertyChanged(String) Raise a property change event. Declaration protected virtual void RaisePropertyChanged(string propertyName = null) Parameters Type Name Description System.String propertyName The name of the property. SetMapping(String, MappingBase) The method used to set a mapping for a given context. Declaration public void SetMapping(string context, MappingBase mapping) Parameters Type Name Description System.String context MappingBase mapping Events PropertyChanged An event raised when a property is changed. Declaration public event PropertyChangedEventHandler PropertyChanged Event Type Type Description System.ComponentModel.PropertyChangedEventHandler Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ElementError.html": {
    "href": "api/Elements.ElementError.html",
    "title": "Class ElementError | Hypar Docs",
    "keywords": "Class ElementError Represents error that occur inside an element during application execution Inheritance System.Object BaseError ElementError Inherited Members BaseError.Message BaseError.StackTrace System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ElementError : BaseError Constructors ElementError(Guid, Exception) Initializes a new instance of ElementError class Declaration public ElementError(Guid id, Exception exception) Parameters Type Name Description System.Guid id The element Id System.Exception exception The exception that occured during application execution Properties ElementId Gets element Id where the error occured Declaration public Guid ElementId { get; } Property Value Type Description System.Guid"
  },
  "api/Elements.ElementInstance.html": {
    "href": "api/Elements.ElementInstance.html",
    "title": "Class ElementInstance | Hypar Docs",
    "keywords": "Class ElementInstance An instance of an element in the model. Instances point to one instance of a type, but have individual ids and transforms. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ElementInstance.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a test user element. var profile = new Profile(Polygon.Rectangle(1.0, 1.0)); var material = new Material(\"yellow\", Colors.Yellow); var line = new Line(Vector3.Origin, new Vector3(5, 5, 5)); // Set the isElementDefinition parameter to true, // so the element is considered an instance definition. var testUserElement = new TestUserElement(line, profile, material, isElementDefinition: true); // Create instances of that element // with varied transforms. var attractor = new Vector3(30, 20); for (var x = 0.0; x < 50; x += 1.5) { for (var y = 0.0; y < 50; y += 1.5) { var loc = new Vector3(x, y); var d = loc.DistanceTo(attractor); var s = d == 0 ? 1 : 5 * Math.Sin(1 / d); var t = new Transform(); t.Scale(new Vector3(s, s, s)); t.Move(loc); var instance = testUserElement.CreateInstance(t, $\"Test User Element {x}:{y}\"); this.Model.AddElement(instance); } } Inheritance System.Object Element ElementInstance Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ElementInstance : Element, INotifyPropertyChanged Properties BaseDefinition The element from which this instance is derived. Declaration public GeometricElement BaseDefinition { get; } Property Value Type Description GeometricElement Transform The transform of the instance. Declaration public Transform Transform { get; } Property Value Type Description Transform Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ElementProxy.html": {
    "href": "api/Elements.ElementProxy.html",
    "title": "Class ElementProxy | Hypar Docs",
    "keywords": "Class ElementProxy Wrapper/utilities for ElementProxy generics. Inheritance System.Object ElementProxy Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ElementProxy Methods ClearCache() Clears the current proxy cache. Use this at the beginning of functions so that the previous cache is not polluting our current run. Declaration public static void ClearCache()"
  },
  "api/Elements.ElementProxy-1.html": {
    "href": "api/Elements.ElementProxy-1.html",
    "title": "Class ElementProxy<T> | Hypar Docs",
    "keywords": "Class ElementProxy<T> Proxy for an element from another function. This is used to attach additional information to upstream elements. Proxies created via Element.Proxy() are intended to be reused, so we are not creating multiple proxies for each element. Proxies deserialized from other functions are not added to the current proxy cache, so that each function will create its own, new proxies for each element. Inheritance System.Object Element ElementProxy<T> Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ElementProxy<T> : Element, INotifyPropertyChanged where T : Element Type Parameters Name Description T Properties Dependency Dependency string for the dependency that this element came from. Declaration [JsonProperty(\"dependency\")] public string Dependency { get; set; } Property Value Type Description System.String Element Original element that the proxy refers to. If null, the element needs to be hydrated. Declaration [JsonIgnore] public T Element { get; } Property Value Type Description T ElementId ID of element that this is a proxy for. Declaration [JsonProperty(\"elementId\")] public Guid ElementId { get; set; } Property Value Type Description System.Guid Methods Hydrate(Dictionary<String, Model>) Re-populate the element reference in a proxy if it is missing. Does nothing if it is already populated. Declaration public T Hydrate(Dictionary<string, Model> models) Parameters Type Name Description System.Collections.Generic.Dictionary < System.String , Model > models Keyed dictionary of available models to search for the element reference in. Returns Type Description T Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ElementProxyExtensions.html": {
    "href": "api/Elements.ElementProxyExtensions.html",
    "title": "Class ElementProxyExtensions | Hypar Docs",
    "keywords": "Class ElementProxyExtensions Extension methods for element proxies. Inheritance System.Object ElementProxyExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class ElementProxyExtensions Methods Elements<T>(IEnumerable<ElementProxy<T>>) Returns a list of element proxies' element references. Assumes they have already been hydrated. Declaration public static IEnumerable<T> Elements<T>(this IEnumerable<ElementProxy<T>> proxies) where T : Element Parameters Type Name Description System.Collections.Generic.IEnumerable < ElementProxy <T>> proxies Returns Type Description System.Collections.Generic.IEnumerable <T> Type Parameters Name Description T Hydrate<T>(IEnumerable<ElementProxy<T>>, Dictionary<String, Model>) Re-populate a list of element proxies' element references. Declaration public static IEnumerable<T> Hydrate<T>(this IEnumerable<ElementProxy<T>> proxies, Dictionary<string, Model> models) where T : Element Parameters Type Name Description System.Collections.Generic.IEnumerable < ElementProxy <T>> proxies System.Collections.Generic.Dictionary < System.String , Model > models Keyed dictionary of available models to search for the element reference in. Returns Type Description System.Collections.Generic.IEnumerable <T> Type Parameters Name Description T Proxies<T>(IEnumerable<T>, String) Create or get proxies for a list of elements. Declaration public static IEnumerable<ElementProxy<T>> Proxies<T>(this IEnumerable<T> elements, string dependencyName) where T : Element Parameters Type Name Description System.Collections.Generic.IEnumerable <T> elements System.String dependencyName The name of the dependency these elements came from. The assumption is that we only need proxies for elements from dependencies. Returns Type Description System.Collections.Generic.IEnumerable < ElementProxy <T>> Type Parameters Name Description T Proxy<T>(T, String) Create a proxy for this element, or get the existing proxy already created for this element if it exists. Declaration public static ElementProxy<T> Proxy<T>(this T element, string dependencyName) where T : Element Parameters Type Name Description T element System.String dependencyName The name of the dependency this element came from. The assumption is that we only need proxies for elements from dependencies. Returns Type Description ElementProxy <T> Type Parameters Name Description T Proxy<T>(IEnumerable<ElementProxy<T>>, T) Grab the proxy for an element from a list of proxies. Declaration public static ElementProxy<T> Proxy<T>(this IEnumerable<ElementProxy<T>> proxies, T element) where T : Element Parameters Type Name Description System.Collections.Generic.IEnumerable < ElementProxy <T>> proxies Proxies to search for teh element in. T element The element to find a proxy for. Returns Type Description ElementProxy <T> Type Parameters Name Description T"
  },
  "api/Elements.Floor.html": {
    "href": "api/Elements.Floor.html",
    "title": "Class Floor | Hypar Docs",
    "keywords": "Class Floor A floor is a horizontal element defined by a profile. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Floor.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a floor with no elevation. var p = Polygon.Rectangle(10, 20); var floor1 = new Floor(p, 0.1); // Create a floor with an elevation. var floor2 = new Floor(p, 0.1, new Transform(0, 0, 3)); // Create some openings. floor1.AddOpening(1, 1, 1, 1); floor2.AddOpening(3, 3, 3, 3); Inheritance System.Object Element GeometricElement Floor Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Floor : GeometricElement, INotifyPropertyChanged, IHasOpenings Constructors Floor() Empty constructor for compatibility purposes. It is best to use the structured constructor with arguments, to ensure the floor is correctly created. Declaration public Floor() Floor(Profile, Double, Transform, Material, Representation, Boolean, Guid, String) Create a floor. Declaration public Floor(Profile profile, double thickness, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The perimeter of the floor. System.Double thickness The thickness of the floor. Transform transform The floor's transform. Create a transform with a Z coordinate for the origin, to define the elevation of the floor. Material material The floor's material. Representation representation The floor's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The floor's id. System.String name The floor's name. Floor(Profile, Double, Nullable<Guid>, Transform, Material, Representation, Boolean, Guid, String) Create a floor. Declaration public Floor(Profile profile, double thickness, Guid? level, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The perimeter of the floor. System.Double thickness The thickness of the floor. System.Nullable < System.Guid > level The level this floor belongs to. Transform transform The floor's transform. Create a transform with a Z coordinate for the origin, to define the elevation of the floor. Material material The floor's material. Representation representation The floor's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The floor's id. System.String name The floor's name. Properties Elevation The elevation from which the floor is extruded. Declaration [JsonIgnore] public double Elevation { get; } Property Value Type Description System.Double Level The Level this floor belongs to. Declaration public Guid? Level { get; set; } Property Value Type Description System.Nullable < System.Guid > Openings A collection of openings in the floor. Declaration public List<Opening> Openings { get; } Property Value Type Description System.Collections.Generic.List < Opening > Profile The untransformed profile of the floor. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Thickness The thickness of the floor. Declaration public double Thickness { get; set; } Property Value Type Description System.Double Methods AddOpening(Polygon, Double, Double, Double, Double) Add an opening in the wall. Declaration public Opening AddOpening(Polygon perimeter, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description Polygon perimeter The perimeter of the opening. System.Double x The distance to the origin of the perimeter along the host's x axis. System.Double y The height to the origin of the perimeter along the host's y axis. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening AddOpening(Double, Double, Double, Double, Double, Double) Add an opening. Declaration public Opening AddOpening(double width, double height, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description System.Double width The width of the opening. System.Double height The height of the opening. System.Double x The distance to the center of the opening along the host's x axis. System.Double y The distance to the center of the opening along the host's y axis. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening Area() The area of the floor. Declaration public double Area() Returns Type Description System.Double The area of the floor, not including the area of openings. ProfileTransformed() Get the profile of the floor transformed by the floor's transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() The area of the floor. Declaration public double Volume() Returns Type Description System.Double The area of the floor, not including the area of openings. Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.FontSize.html": {
    "href": "api/Elements.FontSize.html",
    "title": "Enum FontSize | Hypar Docs",
    "keywords": "Enum FontSize Model text font sizes. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum FontSize Fields Name Description PT12 12 pt PT24 24 pt PT36 36 pt PT48 48 pt PT60 60 pt PT72 72 pt"
  },
  "api/Elements.Frame.html": {
    "href": "api/Elements.Frame.html",
    "title": "Class Frame | Hypar Docs",
    "keywords": "Class Frame An element defined by a perimeter and a cross section swept along that perimeter. Inheritance System.Object Element GeometricElement Frame Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Frame : GeometricElement, INotifyPropertyChanged Constructors Frame(Polygon, Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Create a frame. Declaration public Frame(Polygon curve, Profile profile, double offset = 0, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon curve The frame's perimeter. Profile profile The frame's profile. System.Double offset The amount which the perimeter will be offset internally. Material material The frame's material. Transform transform The frame's transform. Representation representation The frame's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the frame. System.String name The name of the frame. Properties Curve The perimeter of the frame. Declaration public BoundedCurve Curve { get; set; } Property Value Type Description BoundedCurve Profile The frame's profile. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Methods UpdateRepresentations() Update representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.GeoJSON.Feature.html": {
    "href": "api/Elements.GeoJSON.Feature.html",
    "title": "Class Feature | Hypar Docs",
    "keywords": "Class Feature A GeoJSON feature. Inheritance System.Object Feature Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Feature Constructors Feature(Geometry, Dictionary<String, Object>) Construct a feature. Declaration public Feature(Geometry geometry, Dictionary<string, object> properties) Parameters Type Name Description Geometry geometry System.Collections.Generic.Dictionary < System.String , System.Object > properties Properties BBox The bounding box of the feature. Declaration [JsonProperty(\"bbox\", NullValueHandling = NullValueHandling.Ignore)] public IEnumerable<double> BBox { get; } Property Value Type Description System.Collections.Generic.IEnumerable < System.Double > Geometry The geometry of the feature. Declaration [JsonProperty(\"geometry\")] [JsonConverter(typeof(GeometryConverter))] public Geometry Geometry { get; set; } Property Value Type Description Geometry Properties All properties of the feature. Declaration [JsonProperty(\"properties\", NullValueHandling = NullValueHandling.Ignore)] public Dictionary<string, object> Properties { get; set; } Property Value Type Description System.Collections.Generic.Dictionary < System.String , System.Object > Type The type of the feature. Declaration [JsonProperty(\"type\")] public string Type { get; } Property Value Type Description System.String"
  },
  "api/Elements.GeoJSON.FeatureCollection.html": {
    "href": "api/Elements.GeoJSON.FeatureCollection.html",
    "title": "Class FeatureCollection | Hypar Docs",
    "keywords": "Class FeatureCollection A GeoJSON feature collection. Inheritance System.Object FeatureCollection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class FeatureCollection Constructors FeatureCollection(IEnumerable<Feature>) Construct a feature collection. Declaration public FeatureCollection(IEnumerable<Feature> features) Parameters Type Name Description System.Collections.Generic.IEnumerable < Feature > features A collection of features. Properties Features A collection of features. Declaration [JsonProperty(\"features\")] public IEnumerable<Feature> Features { get; set; } Property Value Type Description System.Collections.Generic.IEnumerable < Feature > Type The type of the feature. Declaration [JsonProperty(\"type\")] public string Type { get; } Property Value Type Description System.String"
  },
  "api/Elements.GeoJSON.Geometry.html": {
    "href": "api/Elements.GeoJSON.Geometry.html",
    "title": "Class Geometry | Hypar Docs",
    "keywords": "Class Geometry The base class for all GeoJSON geometry types. Inheritance System.Object Geometry Line LineString MultiLineString MultiPoint MultiPolygon Point Polygon Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public abstract class Geometry Properties Type The type of the geometry. Declaration [JsonProperty(\"type\")] public virtual string Type { get; } Property Value Type Description System.String"
  },
  "api/Elements.GeoJSON.GeometryCollection.html": {
    "href": "api/Elements.GeoJSON.GeometryCollection.html",
    "title": "Class GeometryCollection | Hypar Docs",
    "keywords": "Class GeometryCollection A GeoJSON geometry collection. Inheritance System.Object GeometryCollection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class GeometryCollection Constructors GeometryCollection(Geometry[]) Construct a geometry collection. Declaration public GeometryCollection(Geometry[] geometries) Parameters Type Name Description Geometry [] geometries An array of geometries."
  },
  "api/Elements.GeoJSON.html": {
    "href": "api/Elements.GeoJSON.html",
    "title": "Namespace Elements.GeoJSON | Hypar Docs",
    "keywords": "Namespace Elements.GeoJSON Classes Feature A GeoJSON feature. FeatureCollection A GeoJSON feature collection. Geometry The base class for all GeoJSON geometry types. GeometryCollection A GeoJSON geometry collection. Line A GeoJSON line. LineString A GeoJSON linestring. MultiLineString A GeoJSON multi line string. MultiPoint A GeoJSON multipoint. MultiPolygon A GeoJSON multi polygon. Point A GeoJSON point. Polygon A GeoJSON polygon. Position A GeoJSON position specified by longitude and latitude."
  },
  "api/Elements.GeoJSON.Line.html": {
    "href": "api/Elements.GeoJSON.Line.html",
    "title": "Class Line | Hypar Docs",
    "keywords": "Class Line A GeoJSON line. Inheritance System.Object Geometry Line Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Line : Geometry Constructors Line(Position[]) Construct a Line. Declaration public Line(Position[] coordinates) Parameters Type Name Description Position [] coordinates Properties Coordinates The coordinates of the geometry. Declaration [JsonProperty(\"coordinates\")] public Position[] Coordinates { get; } Property Value Type Description Position []"
  },
  "api/Elements.GeoJSON.LineString.html": {
    "href": "api/Elements.GeoJSON.LineString.html",
    "title": "Class LineString | Hypar Docs",
    "keywords": "Class LineString A GeoJSON linestring. Inheritance System.Object Geometry LineString Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class LineString : Geometry Constructors LineString(Position[]) Construct a LineString. Declaration public LineString(Position[] coordinates) Parameters Type Name Description Position [] coordinates Properties Coordinates The coordinates of the geometry. Declaration [JsonProperty(\"coordinates\")] public Position[] Coordinates { get; } Property Value Type Description Position []"
  },
  "api/Elements.GeoJSON.MultiLineString.html": {
    "href": "api/Elements.GeoJSON.MultiLineString.html",
    "title": "Class MultiLineString | Hypar Docs",
    "keywords": "Class MultiLineString A GeoJSON multi line string. Inheritance System.Object Geometry MultiLineString Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class MultiLineString : Geometry Constructors MultiLineString(Position[][]) Construct a MultiLineString. Declaration public MultiLineString(Position[][] coordinates) Parameters Type Name Description Position [][] coordinates Properties Coordinates The coordinates of the geometry. Declaration [JsonProperty(\"coordinates\")] public Position[][] Coordinates { get; } Property Value Type Description Position [][]"
  },
  "api/Elements.GeoJSON.MultiPoint.html": {
    "href": "api/Elements.GeoJSON.MultiPoint.html",
    "title": "Class MultiPoint | Hypar Docs",
    "keywords": "Class MultiPoint A GeoJSON multipoint. Inheritance System.Object Geometry MultiPoint Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class MultiPoint : Geometry Constructors MultiPoint(Position[]) Construct a MultiPoint. Declaration public MultiPoint(Position[] coordinates) Parameters Type Name Description Position [] coordinates Properties Coordinates The coordinates of the geometry. Declaration [JsonProperty(\"coordinates\")] public Position[] Coordinates { get; } Property Value Type Description Position []"
  },
  "api/Elements.GeoJSON.MultiPolygon.html": {
    "href": "api/Elements.GeoJSON.MultiPolygon.html",
    "title": "Class MultiPolygon | Hypar Docs",
    "keywords": "Class MultiPolygon A GeoJSON multi polygon. Inheritance System.Object Geometry MultiPolygon Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class MultiPolygon : Geometry Constructors MultiPolygon(Position[][]) Construct a MultiPolygon. Declaration public MultiPolygon(Position[][] coordinates) Parameters Type Name Description Position [][] coordinates Properties Coordinates The coordinates of the geometry. Declaration [JsonProperty(\"coordinates\")] public Position[][] Coordinates { get; } Property Value Type Description Position [][]"
  },
  "api/Elements.GeoJSON.Point.html": {
    "href": "api/Elements.GeoJSON.Point.html",
    "title": "Class Point | Hypar Docs",
    "keywords": "Class Point A GeoJSON point. Inheritance System.Object Geometry Point Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Point : Geometry Constructors Point(Position) Construct a Point. Declaration public Point(Position coordinates) Parameters Type Name Description Position coordinates Properties Coordinates The coordinates of the geometry. Declaration [JsonProperty(\"coordinates\")] public Position Coordinates { get; } Property Value Type Description Position"
  },
  "api/Elements.GeoJSON.Polygon.html": {
    "href": "api/Elements.GeoJSON.Polygon.html",
    "title": "Class Polygon | Hypar Docs",
    "keywords": "Class Polygon A GeoJSON polygon. Inheritance System.Object Geometry Polygon Inherited Members Geometry.Type System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax public class Polygon : Geometry Constructors Polygon(Position[][]) Construct a Polygon. Declaration public Polygon(Position[][] coordinates) Parameters Type Name Description Position [][] coordinates Properties Coordinates The coordinates of the geometry. Declaration [JsonProperty(\"coordinates\")] public Position[][] Coordinates { get; } Property Value Type Description Position [][] Methods ToPolygons(Position) Convert the coordinate array to a collection of polygons. The last position of the polygon is dropped. Declaration public Polygon[] ToPolygons(Position relativeToOrigin) Parameters Type Name Description Position relativeToOrigin Returns Type Description Polygon []"
  },
  "api/Elements.GeoJSON.Position.html": {
    "href": "api/Elements.GeoJSON.Position.html",
    "title": "Class Position | Hypar Docs",
    "keywords": "Class Position A GeoJSON position specified by longitude and latitude. Inheritance System.Object Position Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.GeoJSON Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(PositionConverter))] public class Position Constructors Position(Double, Double) Construct a position. Declaration [JsonConstructor] public Position(double latitude, double longitude) Parameters Type Name Description System.Double latitude The latitude. System.Double longitude The longitude. Properties Latitude The latitude in decimal degrees. Declaration [JsonProperty(\"latitude\", Required = Required.Always)] public double Latitude { get; set; } Property Value Type Description System.Double Longitude The longitude in decimal degrees. Declaration [JsonProperty(\"longitude\", Required = Required.Always)] public double Longitude { get; set; } Property Value Type Description System.Double Methods Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) FromVectorMeters(Position, Vector3) Convert the position to a vector in meters relative to an origin position. Declaration public static Position FromVectorMeters(Position relativeToOrigin, Vector3 location) Parameters Type Name Description Position relativeToOrigin A position marking the latitude and longitude of (0,0) Vector3 location The position to convert to latitude and longitude. Returns Type Description Position GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() ToVectorMeters(Position) Convert the position to a vector in meters relative to an origin position. Declaration public Vector3 ToVectorMeters(Position relativeToOrigin) Parameters Type Name Description Position relativeToOrigin A position marking the latitude and longitude of (0,0) Returns Type Description Vector3"
  },
  "api/Elements.GeometricElement.html": {
    "href": "api/Elements.GeometricElement.html",
    "title": "Class GeometricElement | Hypar Docs",
    "keywords": "Class GeometricElement An element with a geometric representation. Inheritance System.Object Element GeometricElement AnalysisMesh Message BaseCeiling ContentElement Floor Frame GridLine Mass MeshElement ModelArrows ModelCurve ModelLines ModelPoints Opening Panel Space Obstacle StructuralFraming Wall Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class GeometricElement : Element, INotifyPropertyChanged Constructors GeometricElement(Transform, Material, Representation, Boolean, Guid, String) Create a geometric element. Declaration [JsonConstructor] public GeometricElement(Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Transform transform The element's transform. Material material The element's material. Representation representation System.Boolean isElementDefinition System.Guid id System.String name Properties Bounds The element's bounds. The bounds are only available when the geometry has been updated using UpdateBoundsAndComputeSolid(), Declaration [JsonIgnore] public BBox3 Bounds { get; } Property Value Type Description BBox3 IsElementDefinition When true, this element will act as the base definition for element instances, and will not appear in visual output. Declaration [JsonProperty(\"IsElementDefinition\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public bool IsElementDefinition { get; set; } Property Value Type Description System.Boolean Material The element's material. Declaration [JsonProperty(\"Material\", Required = Required.AllowNull)] public Material Material { get; set; } Property Value Type Description Material ModifyVertexAttributes A function used to modify vertex attributes of the object's mesh during tesselation. Each vertex is passed to the modifier as the object is tessellated. Declaration [JsonIgnore] public Func<(Vector3 position, Vector3 normal, UV uv, Color? color), (Vector3 position, Vector3 normal, UV uv, Color? color)> ModifyVertexAttributes { get; set; } Property Value Type Description System.Func < System.ValueTuple < Vector3 , Vector3 , UV , System.Nullable < Color >>, System.ValueTuple < Vector3 , Vector3 , UV , System.Nullable < Color >>> Representation The element's representation. Declaration [JsonProperty(\"Representation\", Required = Required.AllowNull)] public Representation Representation { get; set; } Property Value Type Description Representation Transform The element's transform. Declaration [JsonProperty(\"Transform\", Required = Required.AllowNull)] public Transform Transform { get; set; } Property Value Type Description Transform Methods CreateInstance(Transform, String) Create an instance of this element. Instances will point to the same instance of an element. Declaration public ElementInstance CreateInstance(Transform transform, string name) Parameters Type Name Description Transform transform The transform for this element instance. System.String name The name of this element instance. Returns Type Description ElementInstance HasGeometry() Does this geometric element have geometry? Declaration public bool HasGeometry() Returns Type Description System.Boolean Intersects(Plane, out Dictionary<Guid, List<Polygon>>, out Dictionary<Guid, List<Polygon>>, out Dictionary<Guid, List<Line>>) Does this element intersect the provided plane? Declaration public bool Intersects(Plane plane, out Dictionary<Guid, List<Polygon>> intersectionPolygons, out Dictionary<Guid, List<Polygon>> beyondPolygons, out Dictionary<Guid, List<Line>> lines) Parameters Type Name Description Plane plane The plane of intersection. System.Collections.Generic.Dictionary < System.Guid , System.Collections.Generic.List < Polygon >> intersectionPolygons A collection of polygons representing the intersections of the plane and the element's solid geometry. System.Collections.Generic.Dictionary < System.Guid , System.Collections.Generic.List < Polygon >> beyondPolygons A collection of polygons representing coplanar faces beyond the plane of intersection. System.Collections.Generic.Dictionary < System.Guid , System.Collections.Generic.List < Line >> lines A collection of lines representing intersections of zero-thickness elements with the plane. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. ToMesh(Boolean) Get the mesh representing the this Element's geometry. By default it will be untransformed. Declaration public Mesh ToMesh(bool transform = false) Parameters Type Name Description System.Boolean transform Should the mesh be transformed into its final location? Returns Type Description Mesh TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Get graphics buffers and other metadata required to modify a GLB. Declaration public virtual bool TryToGraphicsBuffers(out List<GraphicsBuffers> graphicsBuffers, out string id, out MeshPrimitive.ModeEnum? mode) Parameters Type Name Description System.Collections.Generic.List < GraphicsBuffers > graphicsBuffers System.String id System.Nullable < glTFLoader.Schema.MeshPrimitive.ModeEnum > mode Returns Type Description System.Boolean True if there is graphicsbuffers data applicable to add, false otherwise. Out variables should be ignored if the return value is false. UpdateBoundsAndComputeSolid(Boolean) Update the computed solid and the bounding box of the element. Declaration public void UpdateBoundsAndComputeSolid(bool transformed = false) Parameters Type Name Description System.Boolean transformed UpdateRepresentations() This method provides an opportunity for geometric elements to adjust their solid operations before tesselation. As an example, a floor might want to clip its opening profiles out of the profile of the floor. Declaration public virtual void UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Geometry.Arc.html": {
    "href": "api/Elements.Geometry.Arc.html",
    "title": "Class Arc | Hypar Docs",
    "keywords": "Class Arc An arc defined as a CCW rotation from the +X axis around a center between a start angle and an end angle. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Arc.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var arc = new Arc(Vector3.Origin, 2.0, 0.0, 90.0); Assert.True(new Vector3(2, 0, 0).IsAlmostEqualTo(arc.Start)); Assert.True(new Vector3(0, 2, 0).IsAlmostEqualTo(arc.End)); var arc1 = new Arc(Vector3.Origin, 2.0, 0.0, -90.0); Assert.True(new Vector3(2, 0, 0).IsAlmostEqualTo(arc1.Start)); Assert.True(new Vector3(0, -2, 0).IsAlmostEqualTo(arc1.End)); // A transformed arc. var arc2 = new Arc(new Transform(Vector3.Origin, Vector3.XAxis), 2.0, 0, Math.PI); Inheritance System.Object Curve BoundedCurve TrimmedCurve < Circle > Arc Implements ICurve ITransformable < Curve > IBoundedCurve ITrimmedCurve < Circle > System.IEquatable < Arc > Inherited Members TrimmedCurve<Circle>.BasisCurve BoundedCurve.DefaultMinimumChordLength BoundedCurve.IsClosedForRendering BoundedCurve.Frames(Double, Double, Double) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Arc : TrimmedCurve<Circle>, ICurve, ITransformable<Curve>, IBoundedCurve, ITrimmedCurve<Circle>, IEquatable<Arc> Constructors Arc(Circle, Double, Double) Create an arc. Declaration public Arc(Circle circle, double startParameter, double endParameter) Parameters Type Name Description Circle circle The circle on which this arc is based. System.Double startParameter The parameter, from 0.0->2PI, of the start of the arc. System.Double endParameter The parameter, from 0.0->2PI, of the end of the arc. Arc(Transform, Double, Double, Double) Create an arc. Constructs a circular basis curve internally with the provided transform. Declaration public Arc(Transform transform, double radius = 1, double startParameter = 0, double endParameter = 6.2831853071795862) Parameters Type Name Description Transform transform The transform for the basis curve of the arc. System.Double radius The radius of the arc. System.Double startParameter The parameter, from 0.0->2PI, of the start of the arc. System.Double endParameter The parameter, from 0.0->2PI, of the end of the arc. Arc(Vector3, Double, Double, Double) Create an arc. Declaration [JsonConstructor] public Arc(Vector3 center, double radius, double startAngle, double endAngle) Parameters Type Name Description Vector3 center The center of the arc. System.Double radius The radius of the arc. System.Double startAngle The angle from 0.0, in degrees, at which the arc will start with respect to the positive X axis. System.Double endAngle The angle from 0.0, in degrees, at which the arc will end with respect to the positive X axis. Arc(Double) Create a circular arc. Declaration public Arc(double radius) Parameters Type Name Description System.Double radius Arc(Double, Double, Double) Create an arc. Constructs a circular basis curve internally with a default transform. Declaration public Arc(double radius, double startAngle, double endAngle) Parameters Type Name Description System.Double radius The radius of the arc. System.Double startAngle The CCW angle from 0.0, in degrees, at which the arc will start with respect to the positive X axis. System.Double endAngle The CCW angle from 0.0, in degrees, at which the arc will end with respect to the positive X axis. Properties Center The center of the arc. Declaration public Vector3 Center { get; } Property Value Type Description Vector3 Domain The domain of the curve. Declaration [JsonIgnore] public override Domain1d Domain { get; } Property Value Type Description Domain1d Overrides BoundedCurve.Domain End The end point of the arc. Declaration [JsonIgnore] public override Vector3 End { get; } Property Value Type Description Vector3 Overrides BoundedCurve.End EndAngle The angle from 0.0, in degrees, at which the arc will end with respect to the positive X axis. Declaration [JsonProperty(\"EndAngle\", Required = Required.Always)] [Range(0, 360)] public double EndAngle { get; protected set; } Property Value Type Description System.Double Radius The radius of the arc. Declaration public double Radius { get; } Property Value Type Description System.Double Start The start point of the arc. Declaration [JsonIgnore] public override Vector3 Start { get; } Property Value Type Description Vector3 Overrides BoundedCurve.Start StartAngle The angle from 0.0, in degrees, at which the arc will start with respect to the positive X axis. Declaration [JsonProperty(\"StartAngle\", Required = Required.Always)] [Range(0, 360)] public double StartAngle { get; protected set; } Property Value Type Description System.Double Methods ArcLength(Double, Double) Calculate the length of the arc between start and end parameters. Declaration public override double ArcLength(double start, double end) Parameters Type Name Description System.Double start System.Double end Returns Type Description System.Double Overrides BoundedCurve.ArcLength(Double, Double) Bounds() Get a bounding box for this arc. Declaration public override BBox3 Bounds() Returns Type Description BBox3 A bounding box for this arc. Overrides BoundedCurve.Bounds() ByThreePoints(Vector3, Vector3, Vector3) Create an arc by three points. Declaration public static Arc ByThreePoints(Vector3 a, Vector3 b, Vector3 c) Parameters Type Name Description Vector3 a The first point. Vector3 b The second point. Vector3 c The third point. Returns Type Description Arc An arc through the three points. Complement() Return the arc which is the complement of this arc. Declaration public Arc Complement() Returns Type Description Arc Equals(Arc) Is this arc equal to the provided arc? Declaration public bool Equals(Arc other) Parameters Type Name Description Arc other The arc to test. Returns Type Description System.Boolean Returns true if the two arcs are equal, otherwise false. Fillet(Line, Line, Double) Create a fillet arc between two lines. Declaration public static Arc Fillet(Line a, Line b, double radius) Parameters Type Name Description Line a The first line. Line b The second line. System.Double radius The radiuse of the fillet arc. Returns Type Description Arc A fillet arc between the two lines. GetSubdivisionParameters(Double, Double) Get parameters to be used to find points along the curve for visualization. Declaration public override double[] GetSubdivisionParameters(double startSetbackDistance = 0, double endSetbackDistance = 0) Parameters Type Name Description System.Double startSetbackDistance An optional setback from the start of the curve. System.Double endSetbackDistance An optional setback from the end of the curve. Returns Type Description System.Double [] A collection of parameter values. Overrides BoundedCurve.GetSubdivisionParameters(Double, Double) Length() Calculate the length of the arc. Declaration public override double Length() Returns Type Description System.Double Overrides BoundedCurve.Length() Mid() The mid point of the line. Declaration public override Vector3 Mid() Returns Type Description Vector3 Overrides BoundedCurve.Mid() ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) Plane() Compute the plane of the arc. Declaration public Plane Plane() Returns Type Description Plane The plane in which the arc lies. PointAt(Double) Get the point at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u Returns Type Description Vector3 The point at parameter u if us is within the trim, otherwise an exception is thrown. Overrides Curve.PointAt(Double) Reversed() Get an arc which is the reverse of this Arc. Declaration public Arc Reversed() Returns Type Description Arc ToPolyline(Int32) Create a polyline through a set of points along the curve. Declaration public override Polyline ToPolyline(int divisions = 10) Parameters Type Name Description System.Int32 divisions The number of divisions of the curve. Returns Type Description Polyline A polyline. Overrides BoundedCurve.ToPolyline(Int32) TransformAt(Double) Get the transform at parameter u. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u Returns Type Description Transform The transform at parameter u if us is within the trim, otherwise an exception is thrown. Overrides Curve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedArc(Transform) Construct a transformed copy of this Arc. Declaration public Arc TransformedArc(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Arc Implements ICurve ITransformable<T> IBoundedCurve ITrimmedCurve<TBasis> System.IEquatable<T>"
  },
  "api/Elements.Geometry.BBox3.html": {
    "href": "api/Elements.Geometry.BBox3.html",
    "title": "Struct BBox3 | Hypar Docs",
    "keywords": "Struct BBox3 An axis-aligned bounding box. Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public struct BBox3 Constructors BBox3(Element) Create the BBox3 for an Element. Elements without any geometry will return invalid boxes. Properties of the element that are themselves elements will not be considered. Declaration public BBox3(Element element) Parameters Type Name Description Element element The element. BBox3(Profile) Create the BBox3 for a Profile. Declaration public BBox3(Profile profile) Parameters Type Name Description Profile profile The Profile. BBox3(Vector3, Vector3) Create a bounding box. Declaration [JsonConstructor] public BBox3(Vector3 min, Vector3 max) Parameters Type Name Description Vector3 min The minimum point. Vector3 max The maximum point. BBox3(IEnumerable<Vector3>) Construct a bounding box from an array of points. Declaration public BBox3(IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The points which are contained within the bounding box. BBox3(IList<Polygon>) Create a bounding box for a collection of polygons. Declaration public BBox3(IList<Polygon> polygons) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons Properties Max The maximum extent of the bounding box. Declaration [JsonProperty(\"Max\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public Vector3 Max { get; set; } Property Value Type Description Vector3 Min The minimum extent of the bounding box. Declaration [JsonProperty(\"Min\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public Vector3 Min { get; set; } Property Value Type Description Vector3 Volume The volume of the bounding box. Declaration [JsonIgnore] public readonly double Volume { get; } Property Value Type Description System.Double XDomain A domain representing the x extents of the bounding box. Declaration [JsonIgnore] public readonly Domain1d XDomain { get; } Property Value Type Description Domain1d XSize The x dimension of the bounding box. Declaration [JsonIgnore] public readonly double XSize { get; } Property Value Type Description System.Double YDomain A domain representing the y extents of the bounding box. Declaration [JsonIgnore] public readonly Domain1d YDomain { get; } Property Value Type Description Domain1d YSize The y dimension of the bounding box. Declaration [JsonIgnore] public readonly double YSize { get; } Property Value Type Description System.Double ZDomain A domain representing the z extents of the bounding box. Declaration [JsonIgnore] public readonly Domain1d ZDomain { get; } Property Value Type Description Domain1d ZSize The z dimension of the bounding box. Declaration [JsonIgnore] public readonly double ZSize { get; } Property Value Type Description System.Double Methods Center() Get the center of the bounding box. Declaration public Vector3 Center() Returns Type Description Vector3 The center of the bounding box. Contains(Vector3) Does this bounding box contain the provided point? Declaration public bool Contains(Vector3 point) Parameters Type Name Description Vector3 point The point to test. Returns Type Description System.Boolean True if the bounding box contains the point, otherwise false. Corners() Get all 8 corners of this bounding box. Ordering is CCW bottom, then CCW top, each starting from minimum (X,Y). For a unit cube this would be: (0,0,0),(1,0,0),(1,1,0),(0,1,0),(0,0,1),(1,0,1),(1,1,1),(0,1,1) Declaration public List<Vector3> Corners() Returns Type Description System.Collections.Generic.List < Vector3 > The corners of the bounding box. Equals(Object) Is the provided object a bounding box? If so, is it equal to this bounding box within Epsilon? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.ValueType.Equals(System.Object) Extend(Vector3) Extend this bounding box to contain the specified point. Declaration public void Extend(Vector3 point) Parameters Type Name Description Vector3 point The point to include in the bounding box. Extend(Vector3[]) Extend this bound box to contain the specified points. Declaration public void Extend(params Vector3[] points) Parameters Type Name Description Vector3 [] points The points to include in the bounding box. GetHashCode() Get the hash code for the bounding box. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() Intersects(BBox3) Does this bounding box intersect the other bounding box? Declaration public bool Intersects(BBox3 other) Parameters Type Name Description BBox3 other The bounding box to test. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. Intersects(Plane, out RelationToPlane, Transform) Does the bounding box intersect the provided plane? Declaration public bool Intersects(Plane plane, out RelationToPlane relationToPlane, Transform transform = null) Parameters Type Name Description Plane plane The plane. RelationToPlane relationToPlane The relation of the bounding box to the plane. Transform transform An optional transform of the bounding box to apply before intersection. Returns Type Description System.Boolean True if the bounding box intersects, otherwise false. IsDegenerate() Does this bounding box have a dimension of 0 along any axis? Declaration public bool IsDegenerate() Returns Type Description System.Boolean IsValid() Does this bounding box have a valid set value? Declaration public bool IsValid() Returns Type Description System.Boolean Offset(Double) Offset a box in each coordinate by a given amount. Declaration public BBox3 Offset(double amount) Parameters Type Name Description System.Double amount Offset distance. Returns Type Description BBox3 PointAt(Vector3) Get a point from this bounding box by supplying a vector specifying normalized parameters from 0 to 1. A point at (0,0,0) will be the minimum point of the bounding box, a point at (1,1,1) will be the maximum point, and a point at (0.5,0.5,0.5) will be the center. Declaration public Vector3 PointAt(Vector3 uvw) Parameters Type Name Description Vector3 uvw The vector in the box's parametric UVW coordinate space. Returns Type Description Vector3 A point in world coordinates. PointAt(Double, Double, Double) Get a point from this bounding box by supplying normalized parameters from 0 to 1. A point at (0,0,0) will be the minimum point of the bounding box, a point at (1,1,1) will be the maximum point, and a point at (0.5,0.5,0.5) will be the center. Declaration public Vector3 PointAt(double u, double v, double w) Parameters Type Name Description System.Double u The u parameter at which to evaluate the box. System.Double v The v parameter at which to evaluate the box. System.Double w The w parameter at which to evaluate the box. Returns Type Description Vector3 A point in world coordinates. ToString() The string representation of the bounding box. Declaration public override string ToString() Returns Type Description System.String Overrides System.ValueType.ToString() TransformAt(Double, Double, Double) Get a transform from this bounding box by supplying normalized parameters from 0 to 1. A point at (0,0,0) will be a transform at the minimum point of the bounding box, a point at (1,1,1) will be at the maximum point, and a point at (0.5,0.5,0.5) will be at the center. Declaration public Transform TransformAt(double u, double v, double w) Parameters Type Name Description System.Double u The u parameter at which to evaluate the box. System.Double v The v parameter at which to evaluate the box. System.Double w The w parameter at which to evaluate the box. Returns Type Description Transform Translated(Vector3) Get a translated copy of the bounding box. Declaration public BBox3 Translated(Vector3 translation) Parameters Type Name Description Vector3 translation The translation to apply. Returns Type Description BBox3 UVWAtPoint(Vector3) For a point in world coordinates, get the corresponding vector in the box's parametric UVW coordinate space. Declaration public Vector3 UVWAtPoint(Vector3 point) Parameters Type Name Description Vector3 point A point in world coordinates. Returns Type Description Vector3 A Vector3 representing the corresponding U,V,W coordinates in the box's coordinate space. Operators Equality(BBox3, BBox3) Are the two bounding boxes equal within Epsilon? Declaration public static bool operator ==(BBox3 a, BBox3 b) Parameters Type Name Description BBox3 a BBox3 b Returns Type Description System.Boolean Inequality(BBox3, BBox3) Are the two bounding boxes not equal within Epsilon? Declaration public static bool operator !=(BBox3 a, BBox3 b) Parameters Type Name Description BBox3 a BBox3 b Returns Type Description System.Boolean Extension Methods ModelCurveExtensions.ToModelCurves(BBox3, Transform, Material)"
  },
  "api/Elements.Geometry.Bezier.html": {
    "href": "api/Elements.Geometry.Bezier.html",
    "title": "Class Bezier | Hypar Docs",
    "keywords": "Class Bezier A Bezier curve. Parameterization of the curve is 0 -> 1. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Bezier.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = Vector3.Origin; var b = new Vector3(5, 0, 1); var c = new Vector3(5, 5, 2); var d = new Vector3(0, 5, 3); var e = new Vector3(0, 0, 4); var f = new Vector3(5, 0, 5); var ctrlPts = new List<Vector3> { a, b, c, d, e, f }; var bezier = new Bezier(ctrlPts); Inheritance System.Object Curve BoundedCurve Bezier Implements ICurve ITransformable < Curve > IBoundedCurve Inherited Members BoundedCurve.DefaultMinimumChordLength BoundedCurve.Start BoundedCurve.End BoundedCurve.Mid() BoundedCurve.IsClosedForRendering BoundedCurve.Frames(Double, Double, Double) BoundedCurve.ToPolyline(Int32) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Bezier : BoundedCurve, ICurve, ITransformable<Curve>, IBoundedCurve Constructors Bezier(List<Vector3>, FrameType) Construct a bezier. Declaration public Bezier(List<Vector3> controlPoints, FrameType frameType = FrameType.Frenet) Parameters Type Name Description System.Collections.Generic.List < Vector3 > controlPoints The control points of the curve. FrameType frameType The frame type to use when calculating frames. Properties ControlPoints A collection of points describing the bezier's frame. https://en.wikipedia.org/wiki/B%C3%A9zier_curve Declaration public List<Vector3> ControlPoints { get; set; } Property Value Type Description System.Collections.Generic.List < Vector3 > Domain The domain of the curve. Declaration [JsonIgnore] public override Domain1d Domain { get; } Property Value Type Description Domain1d Overrides BoundedCurve.Domain FrameType The frame type to use when calculating transforms along the curve. Declaration public FrameType FrameType { get; set; } Property Value Type Description FrameType Methods AccelerationAt(Double) Get the acceleration of the curve at parameter u. Declaration public Vector3 AccelerationAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 ArcLength(Double, Double) Calculate the length of the bezier between start and end parameters. Declaration public override double ArcLength(double start, double end) Parameters Type Name Description System.Double start System.Double end Returns Type Description System.Double The length of the bezier between start and end. Overrides BoundedCurve.ArcLength(Double, Double) BinormalAt(Double) Get the binormal to the curve at parameter u. Declaration public Vector3 BinormalAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 Bounds() Get the bounding box of the curve's control points. Declaration public override BBox3 Bounds() Returns Type Description BBox3 Overrides BoundedCurve.Bounds() GetSubdivisionParameters(Double, Double) Get parameters to be used to find points along the curve for visualization. Declaration public override double[] GetSubdivisionParameters(double startSetbackDistance = 0, double endSetbackDistance = 0) Parameters Type Name Description System.Double startSetbackDistance An optional setback from the start of the curve. System.Double endSetbackDistance An optional setback from the end of the curve. Returns Type Description System.Double [] A collection of parameter values. Overrides BoundedCurve.GetSubdivisionParameters(Double, Double) Length() Get a piecewise linear approximation of the length of the curve. https://en.wikipedia.org/wiki/Arc_length Declaration public override double Length() Returns Type Description System.Double Overrides BoundedCurve.Length() NormalAt(Double) Get the normal of the curve at parameter u. Declaration public Vector3 NormalAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) PointAt(Double) Get the point on the curve at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u The parameter between 0.0 and 1.0. Returns Type Description Vector3 Overrides Curve.PointAt(Double) TangentAt(Double) Get the tangent to the curve at parameter u. Declaration public Vector3 TangentAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 TransformAt(Double) Get the transform on the curve at parameter u. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter along the curve between 0.0 and 1.0. Returns Type Description Transform Overrides Curve.TransformAt(Double) Transformed(Transform) Construct a transformed copy of this Curve. Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedBezier(Transform) Construct a transformed copy of this Bezier. Declaration public Bezier TransformedBezier(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Bezier VelocityAt(Double) Get the velocity to the curve at parameter u. Declaration public Vector3 VelocityAt(double u) Parameters Type Name Description System.Double u A parameter between 0.0 and 1.0. Returns Type Description Vector3 Implements ICurve ITransformable<T> IBoundedCurve"
  },
  "api/Elements.Geometry.BooleanMode.html": {
    "href": "api/Elements.Geometry.BooleanMode.html",
    "title": "Enum BooleanMode | Hypar Docs",
    "keywords": "Enum BooleanMode Mode to apply a boolean operation Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum BooleanMode Fields Name Description Difference A and not B Intersection A and B Union A or B XOr Exclusive or  either A or B but not both."
  },
  "api/Elements.Geometry.BoundedCurve.html": {
    "href": "api/Elements.Geometry.BoundedCurve.html",
    "title": "Class BoundedCurve | Hypar Docs",
    "keywords": "Class BoundedCurve A bounded curve. Inheritance System.Object Curve BoundedCurve Bezier IndexedPolycurve TrimmedCurve<TBasis> Implements ICurve ITransformable < Curve > IBoundedCurve Inherited Members Curve.PointAt(Double) Curve.TransformAt(Double) Curve.Transformed(Transform) Curve.ParameterAtDistanceFromParameter(Double, Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public abstract class BoundedCurve : Curve, ICurve, ITransformable<Curve>, IBoundedCurve Fields DefaultMinimumChordLength The minimum chord length allowed for subdivision of the curve. A smaller MinimumChordLength results in smoother curves. For polylines and polygons this parameter will have no effect. Declaration public const double DefaultMinimumChordLength = 0.1 Field Value Type Description System.Double Properties Domain The domain of the curve. Declaration [JsonIgnore] public virtual Domain1d Domain { get; } Property Value Type Description Domain1d End The end of the curve. Declaration public virtual Vector3 End { get; protected set; } Property Value Type Description Vector3 IsClosedForRendering Should the curve be considered closed for rendering? Curves marked true will use LINE_LOOP mode for rendering. Curves marked false will use LINE_STRIP for rendering. Declaration [JsonIgnore] public virtual bool IsClosedForRendering { get; } Property Value Type Description System.Boolean Start The start of the curve. Declaration public virtual Vector3 Start { get; protected set; } Property Value Type Description Vector3 Methods ArcLength(Double, Double) Calculate the length of the curve between two parameters. Declaration public abstract double ArcLength(double start, double end) Parameters Type Name Description System.Double start System.Double end Returns Type Description System.Double Bounds() Get the bounding box for this curve. Declaration public abstract BBox3 Bounds() Returns Type Description BBox3 A bounding box for this curve. Frames(Double, Double, Double) Get a collection of Transforms which represent frames along this curve. Declaration public virtual Transform[] Frames(double startSetbackDistance = 0, double endSetbackDistance = 0, double additionalRotation = 0) Parameters Type Name Description System.Double startSetbackDistance The offset from the start of the ICurve. System.Double endSetbackDistance The offset from the end of the ICurve. System.Double additionalRotation An additional rotation of the frame at each point. Returns Type Description Transform [] A collection of Transforms. GetSubdivisionParameters(Double, Double) Get parameters to be used to find points along the curve for visualization. Declaration public abstract double[] GetSubdivisionParameters(double startSetbackDistance = 0, double endSetbackDistance = 0) Parameters Type Name Description System.Double startSetbackDistance An optional setback from the start of the curve. System.Double endSetbackDistance An optional setback from the end of the curve. Returns Type Description System.Double [] A collection of parameter values. Length() Calculate the length of the curve. Declaration public abstract double Length() Returns Type Description System.Double Mid() The mid point of the curve. Declaration public virtual Vector3 Mid() Returns Type Description Vector3 PointAtNormalized(Double) Get a point along the curve at parameter u. Declaration public Vector3 PointAtNormalized(double u) Parameters Type Name Description System.Double u A parameter along the curve between 0.0 and 1.0. Returns Type Description Vector3 A point along the curve at parameter u. ToPolyline(Int32) Create a polyline through a set of points along the curve. Declaration public virtual Polyline ToPolyline(int divisions = 10) Parameters Type Name Description System.Int32 divisions The number of divisions of the curve. Returns Type Description Polyline A polyline. TransformAtNormalized(Double) Get a transform whose XY plane is perpendicular to the curve, and whose positive Z axis points along the curve. Declaration public Transform TransformAtNormalized(double u) Parameters Type Name Description System.Double u The parameter along the curve between 0.0 and 1.0. Returns Type Description Transform A transform. Operators Implicit(BoundedCurve to ModelCurve) Convert a bounded curve to a model curve. Declaration public static implicit operator ModelCurve(BoundedCurve c) Parameters Type Name Description BoundedCurve c The bounded curve to convert. Returns Type Description ModelCurve Implements ICurve ITransformable<T> IBoundedCurve"
  },
  "api/Elements.Geometry.Box.html": {
    "href": "api/Elements.Geometry.Box.html",
    "title": "Class Box | Hypar Docs",
    "keywords": "Class Box A geometry type representing an oriented cuboid in space. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Box.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var box1 = new Box((-1, -1, -1), (1, 1, 1)); var box2 = new Box((6, 7, 8), (9, 12, 15), new Transform().Rotated(new Vector3(1, 1, 1).Unitized(), 30)); var circle = new Circle((0, 0, 0), 1); var polygon = circle.ToPolygon(20); var mappedPolygon = polygon.TransformedPolygon(Elements.Geometry.Box.TransformBetween(box1, box2)); Inheritance System.Object Box Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Box Constructors Box(BBox3, Transform) Create a new box from a bounding box. Declaration [JsonConstructor] public Box(BBox3 box = default(BBox3), Transform transform = null) Parameters Type Name Description BBox3 box The world-oriented bounding box. Transform transform If supplied, the transform indicating the box's local coordinate frame. Box(Box) Make a new box as a copy of the supplied box. Declaration public Box(Box other) Parameters Type Name Description Box other The box to copy. Box(Vector3, Vector3, Transform) Create a new box from a minimum and maximum point in world coordinates, and an optional Transform indicating the orientation frame of the box. Declaration public Box(Vector3 min, Vector3 max, Transform transform = null) Parameters Type Name Description Vector3 min The minimum point of the box, in world coordinates. Vector3 max The maximum point of the box, in world coordinates. Transform transform If supplied, the transform indicating the box's origin and orientation. Box(IEnumerable<Vector3>, Transform) Construct a box from a collection of points and a transform to specify the box's orientation. Declaration public Box(IEnumerable<Vector3> points, Transform transform) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points Transform transform Properties Bounds A BBox3 representing the extents of this box, expressed in coordinates relative to the box's transform. Declaration public BBox3 Bounds { get; set; } Property Value Type Description BBox3 Max The (0,0,0) corner of the box, in world coordinates Declaration public Vector3 Max { get; } Property Value Type Description Vector3 Min The (0,0,0) corner of the box, in world coordinates Declaration public Vector3 Min { get; } Property Value Type Description Vector3 Transform The Transform indicating the local coordinate frame of this box. Do not modify this transform directly to modify the box, instead use TransformBox(). Declaration public Transform Transform { get; set; } Property Value Type Description Transform Volume The volume of the box. Note that this value will be inaccurate if using a non-euclidean transform. Declaration [JsonIgnore] public double Volume { get; } Property Value Type Description System.Double Methods BoxToUVW() Get the transform that maps geometry from this box to a normalized, world-oriented unit cube at the origin (the UVW coordinate space of the box). Declaration public Transform BoxToUVW() Returns Type Description Transform IsValid() Check if this box has a valid transform and bounds. Declaration public bool IsValid() Returns Type Description System.Boolean PointAt(Vector3) Get a point from this box by supplying a vector specifying normalized parameters from 0 to 1. A point at (0,0,0) will be the minimum point of the box, a point at (1,1,1) will be the maximum point, and a point at (0.5,0.5,0.5) will be the center. Declaration public Vector3 PointAt(Vector3 uvw) Parameters Type Name Description Vector3 uvw The vector in the box's parametric UVW coordinate space. Returns Type Description Vector3 A point in world coordinates. PointAt(Double, Double, Double) Get a point from this bounding box by supplying normalized parameters from 0 to 1. A point at (0,0,0) will be the minimum point of the box, a point at (1,1,1) will be the maximum point, and a point at (0.5,0.5,0.5) will be the center. Declaration public Vector3 PointAt(double u, double v, double w) Parameters Type Name Description System.Double u The u parameter at which to evaluate the box. System.Double v The v parameter at which to evaluate the box. System.Double w The w parameter at which to evaluate the box. Returns Type Description Vector3 A point in world coordinates. ToModelCurves(Material) Convert a Box to a set of model curves. Declaration public List<ModelCurve> ToModelCurves(Material material = null) Parameters Type Name Description Material material An optional material to use for these curves. Returns Type Description System.Collections.Generic.List < ModelCurve > TransformAt(Double, Double, Double) Get a transform from this bounding box by supplying normalized parameters from 0 to 1. A point at (0,0,0) will be a transform at the minimum point of the bounding box, a point at (1,1,1) will be at the maximum point, and a point at (0.5,0.5,0.5) will be at the center. Declaration public Transform TransformAt(double u, double v, double w) Parameters Type Name Description System.Double u The u parameter at which to evaluate the box. System.Double v The v parameter at which to evaluate the box. System.Double w The w parameter at which to evaluate the box. Returns Type Description Transform TransformBetween(Box, Box) Get the transform that maps geometry from one box to another. Declaration public static Transform TransformBetween(Box from, Box to) Parameters Type Name Description Box from Box to Returns Type Description Transform TransformBox(Transform) Transform this box. Declaration public void TransformBox(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Transformed(Transform) Return a new box transformed by the supplied transform. Declaration public Box Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Box A transformed copy of the box. UVWAtPoint(Vector3) For a point in world coordinates, get the corresponding vector in the box's parametric UVW coordinate space. Declaration public Vector3 UVWAtPoint(Vector3 point) Parameters Type Name Description Vector3 point A point in world coordinates. Returns Type Description Vector3 A Vector3 representing the corresponding U,V,W coordinates in the box's coordinate space. UVWToBox() Get the transform that maps geometry from a normalized, world-oriented unit cube at the origin (the UVW coordinate space of the box) to this box. Declaration public Transform UVWToBox() Returns Type Description Transform Operators Implicit(BBox3 to Box) Automatically convert a Bbox3 to a Box. Declaration public static implicit operator Box(BBox3 bbox) Parameters Type Name Description BBox3 bbox A bounding box. Returns Type Description Box"
  },
  "api/Elements.Geometry.Circle.html": {
    "href": "api/Elements.Geometry.Circle.html",
    "title": "Class Circle | Hypar Docs",
    "keywords": "Class Circle A circle. Parameterization of the circle is 0 -> 2PI. Inheritance System.Object Curve Circle Implements ICurve ITransformable < Curve > IConic Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Circle : Curve, ICurve, ITransformable<Curve>, IConic Constructors Circle(Transform, Double) Construct a circle. Declaration public Circle(Transform transform, double radius = 1) Parameters Type Name Description Transform transform System.Double radius Circle(Vector3, Double) Construct a circle. Declaration [JsonConstructor] public Circle(Vector3 center, double radius = 1) Parameters Type Name Description Vector3 center The center of the circle. System.Double radius The radius of the circle. Circle(Double) Construct a circle. Declaration public Circle(double radius = 1) Parameters Type Name Description System.Double radius The radius of the circle. Properties Center The center of the circle. Declaration [JsonProperty(\"Center\", Required = Required.AllowNull)] public Vector3 Center { get; } Property Value Type Description Vector3 Radius The radius of the circle. Declaration [JsonProperty(\"Radius\", Required = Required.Always)] [Range(0, 1.7976931348623157E+308)] public double Radius { get; protected set; } Property Value Type Description System.Double Transform The coordinate system of the plane containing the circle. Declaration public Transform Transform { get; protected set; } Property Value Type Description Transform Methods ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) PointAt(Double) Return the point at parameter u on the arc. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u A parameter on the arc. Returns Type Description Vector3 A Vector3 representing the point along the arc. Overrides Curve.PointAt(Double) ToPolygon(Int32) Create a polygon through a set of points along the circle. Declaration public Polygon ToPolygon(int divisions = 10) Parameters Type Name Description System.Int32 divisions The number of divisions of the circle. Returns Type Description Polygon A polygon. TransformAt(Double) Return transform on the arc at parameter u. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u A parameter on the arc. Returns Type Description Transform A transform with its origin at u along the curve and its Z axis tangent to the curve. Overrides Curve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) Operators Implicit(Circle to Arc) Convert a circle to a circular arc. Declaration public static implicit operator Arc(Circle c) Parameters Type Name Description Circle c Returns Type Description Arc Implicit(Circle to ModelCurve) Convert a circle to a circular model curve. Declaration public static implicit operator ModelCurve(Circle c) Parameters Type Name Description Circle c The bounded curve to convert. Returns Type Description ModelCurve Implements ICurve ITransformable<T> IConic"
  },
  "api/Elements.Geometry.Color.html": {
    "href": "api/Elements.Geometry.Color.html",
    "title": "Struct Color | Hypar Docs",
    "keywords": "Struct Color A color with red, green, blue, and alpha components. Implements System.IEquatable < Color > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct Color : IEquatable<Color> Constructors Color(Double, Double, Double, Double) Create a color. Declaration [JsonConstructor] public Color(double red, double green, double blue, double alpha) Parameters Type Name Description System.Double red The red component. System.Double green The green component. System.Double blue The blue component. System.Double alpha The alpha component. Color(Color) Create an Elements Color from a System.Drawing.Color Declaration public Color(Color color) Parameters Type Name Description System.Drawing.Color color A System.Drawing.Color value. Color(String) Convert a hex code or an english name to a color. Declaration public Color(string hexOrName) Parameters Type Name Description System.String hexOrName The hex code (e.g. #F05C6D) or common color name (e.g. \"Goldenrod\") to turn into a color. (Recognized names are from the UNIX X11 named color values  see https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.colors?view=windowsdesktop-6.0 for a complete listing.) Properties Alpha The alpha component of the color between 0.0 and 1.0. Declaration [JsonProperty(\"Alpha\", Required = Required.Always)] [Range(0, 1)] public double Alpha { get; set; } Property Value Type Description System.Double Blue The blue component of the color between 0.0 and 1.0. Declaration [JsonProperty(\"Blue\", Required = Required.Always)] [Range(0, 1)] public double Blue { get; set; } Property Value Type Description System.Double Green The green component of the color between 0.0 and 1.0. Declaration [JsonProperty(\"Green\", Required = Required.Always)] [Range(0, 1)] public double Green { get; set; } Property Value Type Description System.Double Red The red component of the color between 0.0 and 1.0. Declaration [JsonProperty(\"Red\", Required = Required.Always)] [Range(0, 1)] public double Red { get; set; } Property Value Type Description System.Double Methods Equals(Color) Is this color equal to the provided color? Declaration public bool Equals(Color other) Parameters Type Name Description Color other The color to test. Returns Type Description System.Boolean Returns true if the two colors are equal, otherwise false. Equals(Object) Is this color equal to the provided color? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.ValueType.Equals(System.Object) GetHashCode() Get the hash code for this color. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() Lerp(Color, Double) Linearly interpolate between this color and the other color. Declaration public Color Lerp(Color other, double t) Parameters Type Name Description Color other The other color. System.Double t A value between 0.0 and 1.0. Returns Type Description Color LinearToSRGB(Double) Convert a linear color space component to a gamma color space value. Declaration public static double LinearToSRGB(double c) Parameters Type Name Description System.Double c The linear color component value. Returns Type Description System.Double A gamma color space component value. SRGBToLinear(Double) Convert a gamma color space component to a linear color space value. Declaration public static double SRGBToLinear(double c) Parameters Type Name Description System.Double c The gamma color component value. Returns Type Description System.Double A linear color space component value. ToArray(Boolean) Get the color's components as an array. Declaration public float[] ToArray(bool convertToLinearColorSpace = false) Parameters Type Name Description System.Boolean convertToLinearColorSpace Returns Type Description System.Single [] An array containing the color's components. ToString() Converts this color to a string. Declaration public override string ToString() Returns Type Description System.String Returns a string representation of the form \"R: r, G: g, B: b, A: a\". Overrides System.ValueType.ToString() Operators Addition(Color, Color) Add two colors. Resulting values will be clamped in the range of 0.0 to 1.0. Declaration public static Color operator +(Color a, Color b) Parameters Type Name Description Color a The first color. Color b The second color. Returns Type Description Color Equality(Color, Color) Are the two Colors equal? Declaration public static bool operator ==(Color a, Color b) Parameters Type Name Description Color a Color b Returns Type Description System.Boolean Implicit(String to Color) Automatically convert a hex code or an english name to a color. Declaration public static implicit operator Color(string hexOrName) Parameters Type Name Description System.String hexOrName The hex code (e.g. #F05C6D) or common color name (e.g. \"Goldenrod\") to turn into a color. (Recognized names are from the UNIX X11 named color values  see https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.colors?view=windowsdesktop-6.0 for a complete listing.) Returns Type Description Color Implicit((Double R, Double G, Double B, Double A) to Color) Automatically convert a tuple (R,G,B,A) to a color. Declaration public static implicit operator Color((double R, double G, double B, double A) color) Parameters Type Name Description System.ValueTuple < System.Double , System.Double , System.Double , System.Double > color An (R,G,B,A) tuple of doubles. Returns Type Description Color Implicit((Double R, Double G, Double B) to Color) Automatically convert a tuple (R,G,B) to a color. Declaration public static implicit operator Color((double R, double G, double B) color) Parameters Type Name Description System.ValueTuple < System.Double , System.Double , System.Double > color An (R,G,B) tuple of doubles. Returns Type Description Color Inequality(Color, Color) Are the two Colors equal? Declaration public static bool operator !=(Color a, Color b) Parameters Type Name Description Color a Color b Returns Type Description System.Boolean Multiply(Color, Color) Multiply two colors. Resulting values will be clamped in the range of 0.0 to 1.0. Declaration public static Color operator *(Color a, Color b) Parameters Type Name Description Color a The first color. Color b The second color. Returns Type Description Color Multiply(Double, Color) Multiply a color and a scalar. Resulting values will be clamped in the range of 0.0 to 1.0. Declaration public static Color operator *(double t, Color a) Parameters Type Name Description System.Double t The scalar. Color a The color. Returns Type Description Color Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.Colors.html": {
    "href": "api/Elements.Geometry.Colors.html",
    "title": "Class Colors | Hypar Docs",
    "keywords": "Class Colors Commonly used colors. Inheritance System.Object Colors Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class Colors Properties Aqua Aqua Declaration public static Color Aqua { get; } Property Value Type Description Color Beige Beige Declaration public static Color Beige { get; } Property Value Type Description Color Black Black Declaration public static Color Black { get; } Property Value Type Description Color Blue Blue Declaration public static Color Blue { get; } Property Value Type Description Color Brown Brown Declaration public static Color Brown { get; } Property Value Type Description Color Cobalt Cobalt Declaration public static Color Cobalt { get; } Property Value Type Description Color Coral Coral Declaration public static Color Coral { get; } Property Value Type Description Color Crimson Crimson Declaration public static Color Crimson { get; } Property Value Type Description Color Cyan Cyan Declaration public static Color Cyan { get; } Property Value Type Description Color Darkgray Dark Gray Declaration public static Color Darkgray { get; } Property Value Type Description Color Emerald Emerald Declaration public static Color Emerald { get; } Property Value Type Description Color Granite Granite Declaration public static Color Granite { get; } Property Value Type Description Color Gray Gray Declaration public static Color Gray { get; } Property Value Type Description Color Green Green Declaration public static Color Green { get; } Property Value Type Description Color Lavender Lavender Declaration public static Color Lavender { get; } Property Value Type Description Color Lime Lime Declaration public static Color Lime { get; } Property Value Type Description Color Magenta Magenta Declaration public static Color Magenta { get; } Property Value Type Description Color Maroon Maroon Declaration public static Color Maroon { get; } Property Value Type Description Color Mint Mint Declaration public static Color Mint { get; } Property Value Type Description Color Navy Navy Declaration public static Color Navy { get; } Property Value Type Description Color Olive Olive Declaration public static Color Olive { get; } Property Value Type Description Color Orange Orange Declaration public static Color Orange { get; } Property Value Type Description Color Pink Pink Declaration public static Color Pink { get; } Property Value Type Description Color Purple Purple Declaration public static Color Purple { get; } Property Value Type Description Color Red Red Declaration public static Color Red { get; } Property Value Type Description Color Sand Sand Declaration public static Color Sand { get; } Property Value Type Description Color Stone Stone Declaration public static Color Stone { get; } Property Value Type Description Color Teal Teal Declaration public static Color Teal { get; } Property Value Type Description Color White White Declaration public static Color White { get; } Property Value Type Description Color Yellow Yellow Declaration public static Color Yellow { get; } Property Value Type Description Color"
  },
  "api/Elements.Geometry.Containment.html": {
    "href": "api/Elements.Geometry.Containment.html",
    "title": "Enum Containment | Hypar Docs",
    "keywords": "Enum Containment Represents the state of containment of a point relative to an enclosing polygon, profile, or solid. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum Containment Fields Name Description CoincidesAtEdge The point lies exactly or nearly at an edge. CoincidesAtFace The point lies exactly or nearly at a face. CoincidesAtVertex The point lies exactly or nearly at a vertex. Inside The point lies entirely inside. Outside The point lies entirely outside."
  },
  "api/Elements.Geometry.Contour.html": {
    "href": "api/Elements.Geometry.Contour.html",
    "title": "Class Contour | Hypar Docs",
    "keywords": "Class Contour A continguous set of curves. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Contour.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var r = 1.0; // The reflection plane. var t = new Transform(); t.Reflect(Vector3.YAxis); var ctrlPoints = new List<Vector3>{ new Vector3(0, -r), new Vector3(1.25, 1), new Vector3(3.75, -1), new Vector3(5, -r) }; var l1 = new Bezier(ctrlPoints); var a1 = new Arc(new Vector3(5, 0), r, -90.0, 90.0); var l2 = (Bezier)l1.Transformed(t); l2.ControlPoints.Reverse(); var a2 = new Arc(new Vector3(0, 0), r, 90.0, 270.0); var contour = new Contour(new List<BoundedCurve> { l1, a1, l2, a2 }); Inheritance System.Object Contour Implements System.Collections.Generic.IEnumerable < Curve > System.Collections.IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax [Obsolete(\"Please use IndexedPolycurve instead.\")] public class Contour : IEnumerable<Curve>, IEnumerable Constructors Contour(List<BoundedCurve>) Construct a contour. Declaration public Contour(List<BoundedCurve> curves) Parameters Type Name Description System.Collections.Generic.List < BoundedCurve > curves A list of curves to create the contour. Methods GetEnumerator() Get the enumerator for the collection of curves. Declaration public IEnumerator<Curve> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < Curve > ToPolygon() Convert the contour to a polygon. Declaration public Polygon ToPolygon() Returns Type Description Polygon Explicit Interface Implementations IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable"
  },
  "api/Elements.Geometry.ConvexHull.html": {
    "href": "api/Elements.Geometry.ConvexHull.html",
    "title": "Class ConvexHull | Hypar Docs",
    "keywords": "Class ConvexHull A utility class for calculating Convex Hulls from inputs Inheritance System.Object ConvexHull Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class ConvexHull Methods FromPoints(IEnumerable<Vector3>) Calculate a polygon from the 2d convex hull of a collection of points. Adapted from https://rosettacode.org/wiki/Convex_hull#C.23 Declaration public static Polygon FromPoints(IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points A collection of points Returns Type Description Polygon A polygon representing the convex hull of the provided points. FromPointsInPlane(IEnumerable<Vector3>, Vector3) Compute the 2D convex hull of a set of 3D points in a plane. Declaration public static Polygon FromPointsInPlane(IEnumerable<Vector3> points, Vector3 planeNormal) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points A collection of points Vector3 planeNormal The normal direction of the plane in which to compute the hull. Returns Type Description Polygon A polygon representing the convex hull, projected along the normal vector to the average depth of the provided points. FromPolyline(Polyline) Calculate a polygon from the 2d convex hull of a polyline or polygon's vertices. Declaration public static Polygon FromPolyline(Polyline p) Parameters Type Name Description Polyline p A polygon Returns Type Description Polygon A polygon representing the convex hull of the provided shape. FromPolylines(IEnumerable<Polyline>) Calculate a polygon from the 2d convex hull of the vertices of a collection of polylines or polygons. Declaration public static Polygon FromPolylines(IEnumerable<Polyline> polylines) Parameters Type Name Description System.Collections.Generic.IEnumerable < Polyline > polylines A collection of polygons Returns Type Description Polygon A polygon representing the convex hull of the provided shapes. FromProfile(Profile) Calculate a polygon from the 2d convex hull of a profile. Declaration public static Polygon FromProfile(Profile p) Parameters Type Name Description Profile p A profile Returns Type Description Polygon A polygon representing the convex hull of the provided shape."
  },
  "api/Elements.Geometry.Curve.html": {
    "href": "api/Elements.Geometry.Curve.html",
    "title": "Class Curve | Hypar Docs",
    "keywords": "Class Curve The abstract base class for all curves. Inheritance System.Object Curve BoundedCurve Circle Ellipse InfiniteLine Implements ICurve ITransformable < Curve > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public abstract class Curve : ICurve, ITransformable<Curve> Methods ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public abstract double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double PointAt(Double) Get a point along the curve at parameter u. Declaration public abstract Vector3 PointAt(double u) Parameters Type Name Description System.Double u A parameter along the curve between domain.min and domain.max. Returns Type Description Vector3 A point along the curve at parameter u. TransformAt(Double) Get a transform whose XY plane is perpendicular to the curve, and whose positive Z axis points along the curve. Declaration public abstract Transform TransformAt(double u) Parameters Type Name Description System.Double u The transform at a parameter along the curve between domain.min and domain.max. Returns Type Description Transform A transform on the curve at parameter u. Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public abstract Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Implements ICurve ITransformable<T>"
  },
  "api/Elements.Geometry.Ellipse.html": {
    "href": "api/Elements.Geometry.Ellipse.html",
    "title": "Class Ellipse | Hypar Docs",
    "keywords": "Class Ellipse An ellipse. Parameterization of the curve is 0 -> 2PI. Inheritance System.Object Curve Ellipse Implements ICurve ITransformable < Curve > IConic Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Ellipse : Curve, ICurve, ITransformable<Curve>, IConic Constructors Ellipse(Transform, Double, Double) Create an ellipse. Declaration [JsonConstructor] public Ellipse(Transform transform, double majorAxis = 2, double minorAxis = 1) Parameters Type Name Description Transform transform The coordinate system of the plane containing the ellipse. System.Double majorAxis The dimension of the major axis (X) of the ellipse. System.Double minorAxis The dimension of the minor axis (Y) of the ellipse. Ellipse(Vector3, Double, Double) Create an ellipse. Declaration public Ellipse(Vector3 center, double majorAxis = 2, double minorAxis = 1) Parameters Type Name Description Vector3 center The center of the ellipse. System.Double majorAxis The dimension of the major axis (X) of the ellipse. System.Double minorAxis The dimension of the minor axis (Y) of the ellipse. Ellipse(Double, Double) Create an ellipse. Declaration public Ellipse(double majorAxis = 1, double minorAxis = 2) Parameters Type Name Description System.Double majorAxis The dimension of the major axis (X) of the ellipse. System.Double minorAxis The dimension of the minor axis (Y) o the ellipse. Properties Center The center of the ellipse. Declaration [JsonIgnore] public Vector3 Center { get; } Property Value Type Description Vector3 MajorAxis The dimension of the major axis (X) of the ellipse. Declaration public double MajorAxis { get; set; } Property Value Type Description System.Double MinorAxis The dimension of the minor axis (Y) of the ellipse. Declaration public double MinorAxis { get; set; } Property Value Type Description System.Double Transform The coordinate system of the plane containing the ellipse. Declaration public Transform Transform { get; protected set; } Property Value Type Description Transform Methods ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) PointAt(Double) Get a point along the ellipse at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u Returns Type Description Vector3 A point on the ellipse at parameter u. Overrides Curve.PointAt(Double) TransformAt(Double) Get a transform along the ellipse at parameter u. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u Returns Type Description Transform A transform on the ellipse at parameter u. Overrides Curve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) Implements ICurve ITransformable<T> IConic"
  },
  "api/Elements.Geometry.EllipticalArc.html": {
    "href": "api/Elements.Geometry.EllipticalArc.html",
    "title": "Class EllipticalArc | Hypar Docs",
    "keywords": "Class EllipticalArc An elliptical arc. Inheritance System.Object Curve BoundedCurve TrimmedCurve < Ellipse > EllipticalArc Implements ICurve ITransformable < Curve > IBoundedCurve ITrimmedCurve < Ellipse > Inherited Members TrimmedCurve<Ellipse>.BasisCurve BoundedCurve.DefaultMinimumChordLength BoundedCurve.Start BoundedCurve.End BoundedCurve.Mid() BoundedCurve.IsClosedForRendering BoundedCurve.Frames(Double, Double, Double) BoundedCurve.ToPolyline(Int32) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class EllipticalArc : TrimmedCurve<Ellipse>, ICurve, ITransformable<Curve>, IBoundedCurve, ITrimmedCurve<Ellipse> Constructors EllipticalArc(Ellipse, Double, Double) Create an elliptical arc. Declaration public EllipticalArc(Ellipse ellipse, double startAngle, double endAngle) Parameters Type Name Description Ellipse ellipse The ellipse on which this trim is based. System.Double startAngle The start angle of the trim in degrees. System.Double endAngle The end parameter of the trim in degrees. EllipticalArc(Vector3, Double, Double, Double, Double) Create an elliptical arc. Declaration [JsonConstructor] public EllipticalArc(Vector3 center, double majorAxis, double minorAxis, double startAngle, double endAngle) Parameters Type Name Description Vector3 center The center of the ellipse. System.Double majorAxis The major axis (X) of the ellipse. System.Double minorAxis The minor axis (Y) of the ellipse. System.Double startAngle The start parameter of the trim. System.Double endAngle The end parameter of the trim. Properties Domain The domain of the curve. Declaration [JsonIgnore] public override Domain1d Domain { get; } Property Value Type Description Domain1d Overrides BoundedCurve.Domain EndAngle The angle from 0.0, in degrees, at which the arc will end with respect to the positive X axis. Declaration [JsonProperty(\"EndAngle\", Required = Required.Always)] [Range(0, 360)] public double EndAngle { get; protected set; } Property Value Type Description System.Double StartAngle The angle from 0.0, in degrees, at which the arc will start with respect to the positive X axis. Declaration [JsonProperty(\"StartAngle\", Required = Required.Always)] [Range(0, 360)] public double StartAngle { get; protected set; } Property Value Type Description System.Double Methods ArcLength(Double, Double) Calculate the length of the elliptical arc between start and end parameters. Declaration public override double ArcLength(double start, double end) Parameters Type Name Description System.Double start System.Double end Returns Type Description System.Double The length of the elliptical arc between start and end. Overrides BoundedCurve.ArcLength(Double, Double) Bounds() The bounds of the elliptical arc. Declaration public override BBox3 Bounds() Returns Type Description BBox3 Overrides BoundedCurve.Bounds() GetSubdivisionParameters(Double, Double) Get parameters to be used to find points along the curve for visualization. Declaration public override double[] GetSubdivisionParameters(double startSetbackDistance = 0, double endSetbackDistance = 0) Parameters Type Name Description System.Double startSetbackDistance An optional setback from the start of the curve. System.Double endSetbackDistance An optional setback from the end of the curve. Returns Type Description System.Double [] A collection of parameter values. Overrides BoundedCurve.GetSubdivisionParameters(Double, Double) Length() Calculate the length of the elliptical arc. Declaration public override double Length() Returns Type Description System.Double The length of the elliptical arc. Overrides BoundedCurve.Length() ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) PointAt(Double) Get a point at a parameter on the elliptical arc. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u The parameter at which to find a point. Returns Type Description Vector3 A point. Overrides Curve.PointAt(Double) TransformAt(Double) Get a transform at a parameter on the elliptical arc. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter at which to find a transform. Returns Type Description Transform A transform. Overrides Curve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) Implements ICurve ITransformable<T> IBoundedCurve ITrimmedCurve<TBasis>"
  },
  "api/Elements.Geometry.EndType.html": {
    "href": "api/Elements.Geometry.EndType.html",
    "title": "Enum EndType | Hypar Docs",
    "keywords": "Enum EndType Offset end types Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum EndType Fields Name Description Butt Ends are squared off with no extension ClosedPolygon If open, ends are joined and treated as a closed polygon Square Open ends are extended by the offset distance and squared off"
  },
  "api/Elements.Geometry.FrameType.html": {
    "href": "api/Elements.Geometry.FrameType.html",
    "title": "Enum FrameType | Hypar Docs",
    "keywords": "Enum FrameType The frame type to be used for operations requiring a moving frame around the curve. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum FrameType Fields Name Description Frenet A Frenet frame. RoadLike A frame with the up axis aligned with +Z."
  },
  "api/Elements.Geometry.GraphicsBuffers.html": {
    "href": "api/Elements.Geometry.GraphicsBuffers.html",
    "title": "Class GraphicsBuffers | Hypar Docs",
    "keywords": "Class GraphicsBuffers A container for graphics data. The buffers used in this class align with webGL requirements. Inheritance System.Object GraphicsBuffers Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class GraphicsBuffers Constructors GraphicsBuffers() Construct an empty graphics buffers object. Declaration public GraphicsBuffers() Properties CMax The maximum color value as [r,g,b]. Declaration public double[] CMax { get; } Property Value Type Description System.Double [] CMin The minimum color value as [r,g,b]. Declaration public double[] CMin { get; } Property Value Type Description System.Double [] Colors A collection of sequential color values stored as sequential bytes. Declaration public List<byte> Colors { get; } Property Value Type Description System.Collections.Generic.List < System.Byte > FacetCount The number of facets represented by the buffer. Declaration public int FacetCount { get; } Property Value Type Description System.Int32 IMax The maximum index value. Declaration public ushort IMax { get; } Property Value Type Description System.UInt16 IMin The minimum index value. Declaration public ushort IMin { get; } Property Value Type Description System.UInt16 Indices A collection of indices stored as sequential bytes. Declaration public List<byte> Indices { get; } Property Value Type Description System.Collections.Generic.List < System.Byte > NMax The maximum normal of the data as [x,y,z]. Declaration public double[] NMax { get; } Property Value Type Description System.Double [] NMin The minimum normal of the data as [x,y,z]. Declaration public double[] NMin { get; } Property Value Type Description System.Double [] Normals A collection of sequential normal values stored as sequential bytes. Declaration public List<byte> Normals { get; } Property Value Type Description System.Collections.Generic.List < System.Byte > UVMax The maximum UV value as [u,v]. Declaration public double[] UVMax { get; } Property Value Type Description System.Double [] UVMin The maximum UV value as [u,v]. Declaration public double[] UVMin { get; } Property Value Type Description System.Double [] UVs A collection of UV values stored as sequential bytes. Declaration public List<byte> UVs { get; } Property Value Type Description System.Collections.Generic.List < System.Byte > VertexCount The number of vertices represented by the buffer. Declaration public int VertexCount { get; } Property Value Type Description System.Int32 Vertices A collection of vertex positions stored as sequential bytes. Declaration public List<byte> Vertices { get; } Property Value Type Description System.Collections.Generic.List < System.Byte > VMax The maximum of the axis-aligned bounding box of the data as [x,y,z]. Declaration public double[] VMax { get; } Property Value Type Description System.Double [] VMin The minimum of the axis-aligned bounding box of the data as [x,y,z]. Declaration public double[] VMin { get; } Property Value Type Description System.Double [] Methods AddIndex(UInt16) Add an index to the graphics buffers. Declaration public void AddIndex(ushort index) Parameters Type Name Description System.UInt16 index The index to add. AddIndices(IList<UInt16>) Add indices to the graphics buffers. Declaration public void AddIndices(IList<ushort> indices) Parameters Type Name Description System.Collections.Generic.IList < System.UInt16 > indices The indices to add. AddVertex(Vector3, Vector3, UV, Nullable<Color>) Add a vertex to the graphics buffers. Declaration public void AddVertex(Vector3 position, Vector3 normal, UV uv, Color? color = null) Parameters Type Name Description Vector3 position The position of the vertex. Vector3 normal The normal of the vertex. UV uv The UV of the vertex. System.Nullable < Color > color The vertex color. AddVertex(Double, Double, Double, Double, Double, Double, Double, Double, Nullable<Color>) Add a vertex to the graphics buffers. Declaration public void AddVertex(double x, double y, double z, double nx, double ny, double nz, double u, double v, Color? color) Parameters Type Name Description System.Double x System.Double y System.Double z System.Double nx System.Double ny System.Double nz System.Double u System.Double v System.Nullable < Color > color AddVertices(IList<(Vector3 position, Vector3 normal, UV uv, Nullable<Color> color)>) Add vertices to the graphics buffers. Declaration public void AddVertices(IList<(Vector3 position, Vector3 normal, UV uv, Color? color)> vertices) Parameters Type Name Description System.Collections.Generic.IList < System.ValueTuple < Vector3 , Vector3 , UV , System.Nullable < Color >>> vertices Initialize(Int32, Int32) Pre allocates the buffers according to the preallocation size. Declaration public void Initialize(int vertexCount = 100, int indexCount = 100) Parameters Type Name Description System.Int32 vertexCount How many vertices are expected. System.Int32 indexCount How many indices are likely to be used."
  },
  "api/Elements.Geometry.html": {
    "href": "api/Elements.Geometry.html",
    "title": "Namespace Elements.Geometry | Hypar Docs",
    "keywords": "Namespace Elements.Geometry Classes Arc An arc defined as a CCW rotation from the +X axis around a center between a start angle and an end angle. Bezier A Bezier curve. Parameterization of the curve is 0 -> 1. BoundedCurve A bounded curve. Box A geometry type representing an oriented cuboid in space. Circle A circle. Parameterization of the circle is 0 -> 2PI. Colors Commonly used colors. Contour A continguous set of curves. ConvexHull A utility class for calculating Convex Hulls from inputs Curve The abstract base class for all curves. Ellipse An ellipse. Parameterization of the curve is 0 -> 2PI. EllipticalArc An elliptical arc. GraphicsBuffers A container for graphics data. The buffers used in this class align with webGL requirements. IndexedPolycurve A curve composed of a collection of line and arc segments. Parameterization of the curve is 0->n where n is the number of curves. InfiniteLine An infinite line. Parameterization of the line is -infinity -> 0 (Origin) -> +infinity Line A line segment. Parameterization of the line is 0 (start) -> length (end) LineExtensions Line extension methods. LineSegmentExtensions Line segment extension methods. Matrix A column-ordered 3x4 matrix. The first 3 columns represent the X, Y, and Z axes of the coordinate system. The fourth column represents the translation of the coordinate system. Mesh A triangle mesh. Plane A cartesian plane. Polygon A closed planar polygon. Parameterization of the curve is 0->n-1 where n is the number of vertices.. Polyline A continuous set of lines. Parameterization of the curve is 0->n-1 where n is the number of vertices. Profile A polygonal perimeter with zero or more polygonal voids. ProfileExtensions Profile extension methods. Representation The representation of an element. Transform A right-handed coordinate system with +Z up. Triangle A mesh triangle. TrimmedCurve<TBasis> A trimmed curve. Vector3Extensions Extension methods for Vector3. Vertex A mesh vertex. Structs BBox3 An axis-aligned bounding box. Color A color with red, green, blue, and alpha components. Ray An infinite ray starting at origin and pointing towards direction. UV A UV coordinate. Vector3 A 3D vector. Enums BooleanMode Mode to apply a boolean operation Containment Represents the state of containment of a point relative to an enclosing polygon, profile, or solid. EndType Offset end types FrameType The frame type to be used for operations requiring a moving frame around the curve. NormalizationType Normalization type. RayIntersectionResult The possible types of ray intersection result. RelationToPlane An enumeration of relations to a plane. VoidTreatment Controls the handling of internal regions in a polygon boolean operation. WideFlangeProfileType"
  },
  "api/Elements.Geometry.IndexedPolycurve.html": {
    "href": "api/Elements.Geometry.IndexedPolycurve.html",
    "title": "Class IndexedPolycurve | Hypar Docs",
    "keywords": "Class IndexedPolycurve A curve composed of a collection of line and arc segments. Parameterization of the curve is 0->n where n is the number of curves. Inheritance System.Object Curve BoundedCurve IndexedPolycurve Polyline Implements ICurve ITransformable < Curve > IBoundedCurve System.Collections.Generic.IEnumerable < BoundedCurve > System.Collections.IEnumerable System.IEquatable < IndexedPolycurve > Inherited Members BoundedCurve.DefaultMinimumChordLength BoundedCurve.Mid() BoundedCurve.IsClosedForRendering BoundedCurve.Frames(Double, Double, Double) BoundedCurve.ToPolyline(Int32) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax [JsonObject] public class IndexedPolycurve : BoundedCurve, ICurve, ITransformable<Curve>, IBoundedCurve, IEnumerable<BoundedCurve>, IEnumerable, IEquatable<IndexedPolycurve> Constructors IndexedPolycurve() Create an indexed polycurve. Declaration public IndexedPolycurve() IndexedPolycurve(IList<Vector3>, IList<IList<Int32>>) Create an indexed polycurve. Declaration [JsonConstructor] public IndexedPolycurve(IList<Vector3> vertices, IList<IList<int>> curveIndices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices A collection of vertices. System.Collections.Generic.IList < System.Collections.Generic.IList < System.Int32 >> curveIndices A collection of collections of indices. IndexedPolycurve(IList<Vector3>, IList<IList<Int32>>, Transform, Boolean) Create an indexed polycurve. Declaration public IndexedPolycurve(IList<Vector3> vertices, IList<IList<int>> curveIndices = null, Transform transform = null, bool disableValidation = false) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices A collection of vertices. System.Collections.Generic.IList < System.Collections.Generic.IList < System.Int32 >> curveIndices A collection of collections of indices. Transform transform An optional transform to apply to each vertex. System.Boolean disableValidation IndexedPolycurve(List<BoundedCurve>, Transform) Create an indexed polycurve. Declaration public IndexedPolycurve(List<BoundedCurve> curves, Transform transform = null) Parameters Type Name Description System.Collections.Generic.List < BoundedCurve > curves A collection of bounded curves. Transform transform An optional transform to apply to the vertices. Properties CurveIndices An optional collection of collections of indices of polycurve segments. Line segments are represented with two indices. Arc segments are represented with three indices. Declaration public IList<IList<int>> CurveIndices { get; set; } Property Value Type Description System.Collections.Generic.IList < System.Collections.Generic.IList < System.Int32 >> Domain The domain of the curve. Declaration [JsonIgnore] public override Domain1d Domain { get; } Property Value Type Description Domain1d Overrides BoundedCurve.Domain End The end of the polycurve. Declaration [JsonIgnore] public override Vector3 End { get; } Property Value Type Description Vector3 Overrides BoundedCurve.End Start The start of the polycurve. Declaration [JsonIgnore] public override Vector3 Start { get; } Property Value Type Description Vector3 Overrides BoundedCurve.Start Vertices The vertices of the polygon. Declaration [JsonProperty(\"Vertices\", Required = Required.Always)] [Required] [MinLength(2)] public IList<Vector3> Vertices { get; set; } Property Value Type Description System.Collections.Generic.IList < Vector3 > Methods ArcLength(Double, Double) Calculate the length of the polycurve between two parameters. Declaration public override double ArcLength(double start, double end) Parameters Type Name Description System.Double start System.Double end Returns Type Description System.Double Overrides BoundedCurve.ArcLength(Double, Double) Bounds() Get the bounding box for this curve. Declaration public override BBox3 Bounds() Returns Type Description BBox3 Overrides BoundedCurve.Bounds() CheckCoincidenceAndThrow(IList<Vector3>) Check for coincident vertices in the supplied vertex collection. Declaration protected void CheckCoincidenceAndThrow(IList<Vector3> vertices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices Equals(IndexedPolycurve) Does this indexed polycurve equal the provided indexed polycurve? Declaration public bool Equals(IndexedPolycurve other) Parameters Type Name Description IndexedPolycurve other Returns Type Description System.Boolean True if the two curves are equal, otherwise false. GetEnumerator() Get the enumerator for this indexed polycurve. Declaration public IEnumerator<BoundedCurve> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < BoundedCurve > An enumerator of bounded curves. GetSubdivisionParameters(Double, Double) Get parameters to be used to find points along the curve for visualization. Declaration public override double[] GetSubdivisionParameters(double startSetbackDistance = 0, double endSetbackDistance = 0) Parameters Type Name Description System.Double startSetbackDistance An optional setback from the start of the curve. System.Double endSetbackDistance An optional setback from the end of the curve. Returns Type Description System.Double [] A collection of parameter values. Overrides BoundedCurve.GetSubdivisionParameters(Double, Double) Length() Calculate the length of the indexed polycurve. Declaration public override double Length() Returns Type Description System.Double Overrides BoundedCurve.Length() ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance between domain.min and domain.max. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) PointAt(Double) Get a point on the polycurve at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u A value between domain.min and domain.max. Returns Type Description Vector3 Returns a Vector3 indicating a point along the Polygon length from its start vertex. Overrides Curve.PointAt(Double) PointAtInternal(Double, out Int32) Get a point on the polycurve at parameter u. Declaration protected virtual Vector3 PointAtInternal(double u, out int curveIndex) Parameters Type Name Description System.Double u A value between domain.min and domain.max. System.Int32 curveIndex The index of the segment containing parameter u. Returns Type Description Vector3 Returns a Vector3 indicating a point along the Polygon length from its start vertex. ToPolygon() Create a polygon from this polycurve. Declaration public Polygon ToPolygon() Returns Type Description Polygon ToString() Get a string representation of this polycurve. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() TransformAt(Double) Get the transform at the specified parameter along the polycurve. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter on the Polygon between domain.min and domain.max. Returns Type Description Transform A transform with its Z axis aligned trangent to the polycurve. Overrides Curve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedPolycurve(Transform) Create new polycurve transformed by transform. Declaration public IndexedPolycurve TransformedPolycurve(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description IndexedPolycurve ValidateVertices() Clean up any duplicate vertices, and warn about any vertices that are too close to each other. Declaration protected virtual void ValidateVertices() Explicit Interface Implementations IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements ICurve ITransformable<T> IBoundedCurve System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable System.IEquatable<T>"
  },
  "api/Elements.Geometry.InfiniteLine.html": {
    "href": "api/Elements.Geometry.InfiniteLine.html",
    "title": "Class InfiniteLine | Hypar Docs",
    "keywords": "Class InfiniteLine An infinite line. Parameterization of the line is -infinity -> 0 (Origin) -> +infinity Inheritance System.Object Curve InfiniteLine Implements ICurve ITransformable < Curve > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class InfiniteLine : Curve, ICurve, ITransformable<Curve> Constructors InfiniteLine(Vector3, Vector3) Create an infinite line. Declaration public InfiniteLine(Vector3 origin, Vector3 direction) Parameters Type Name Description Vector3 origin Vector3 direction Properties Direction The direction of the line. Declaration public Vector3 Direction { get; } Property Value Type Description Vector3 Origin The origin of the line. Declaration public Vector3 Origin { get; } Property Value Type Description Vector3 Methods ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) PointAt(Double) Get the point on the line at the parameter. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u Returns Type Description Vector3 Overrides Curve.PointAt(Double) TransformAt(Double) Get a transform whose XY plane is perpendicular to the curve, and whose positive Z axis points along the curve. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter along the Line at which to calculate the Transform. Returns Type Description Transform A transform. Overrides Curve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) Implements ICurve ITransformable<T>"
  },
  "api/Elements.Geometry.Interfaces.html": {
    "href": "api/Elements.Geometry.Interfaces.html",
    "title": "Namespace Elements.Geometry.Interfaces | Hypar Docs",
    "keywords": "Namespace Elements.Geometry.Interfaces Interfaces IBoundedCurve A curve with a start and an end. Examples of bounded curves include polylines and bezier curves. IConic A conic section. ICurve An infinite curve. ITessellate ITransformable<T> An object that can return a transformed copy of itself ITrimmedCurve<TBasis> A trimmed curve."
  },
  "api/Elements.Geometry.Interfaces.IBoundedCurve.html": {
    "href": "api/Elements.Geometry.Interfaces.IBoundedCurve.html",
    "title": "Interface IBoundedCurve | Hypar Docs",
    "keywords": "Interface IBoundedCurve A curve with a start and an end. Examples of bounded curves include polylines and bezier curves. Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface IBoundedCurve Properties Domain The domain of the curve. Declaration Domain1d Domain { get; } Property Value Type Description Domain1d End The end of the curve. Declaration Vector3 End { get; } Property Value Type Description Vector3 Start The start of the curve. Declaration Vector3 Start { get; } Property Value Type Description Vector3 Methods ArcLength(Double, Double) Calculate the length of the curve between two parameters. Declaration double ArcLength(double start, double end) Parameters Type Name Description System.Double start System.Double end Returns Type Description System.Double Bounds() Get the bounding box of this curve. Declaration BBox3 Bounds() Returns Type Description BBox3 Frames(Double, Double, Double) Get a collection of Transforms which represent frames along this curve. Declaration Transform[] Frames(double startSetbackDistance = 0, double endSetbackDistance = 0, double additionalRotation = 0) Parameters Type Name Description System.Double startSetbackDistance The offset from the start of the ICurve. System.Double endSetbackDistance The offset from the end of the ICurve. System.Double additionalRotation An additional rotation of the frame at each point. Returns Type Description Transform [] A collection of Transforms. GetSubdivisionParameters(Double, Double) Get parameters to be used to find points along the curve for visualization. Declaration double[] GetSubdivisionParameters(double startSetbackDistance = 0, double endSetbackDistance = 0) Parameters Type Name Description System.Double startSetbackDistance An optional setback from the start of the curve. System.Double endSetbackDistance An optional setback from the end of the curve. Returns Type Description System.Double [] A collection of parameter values. Length() Calculate the length of the curve. Declaration double Length() Returns Type Description System.Double Mid() The mid point of the curve. Declaration Vector3 Mid() Returns Type Description Vector3 PointAtNormalized(Double) Get a point along the curve at parameter u. Declaration Vector3 PointAtNormalized(double u) Parameters Type Name Description System.Double u A parameter along the curve between 0.0 and 1.0. Returns Type Description Vector3 A point along the curve at parameter u. TransformAtNormalized(Double) Get a transform whose XY plane is perpendicular to the curve, and whose positive Z axis points along the curve. Declaration Transform TransformAtNormalized(double u) Parameters Type Name Description System.Double u The parameter along the curve between 0.0 and 1.0. Returns Type Description Transform A transform."
  },
  "api/Elements.Geometry.Interfaces.IConic.html": {
    "href": "api/Elements.Geometry.Interfaces.IConic.html",
    "title": "Interface IConic | Hypar Docs",
    "keywords": "Interface IConic A conic section. Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface IConic Properties Transform The coordinate system that defines the orientation of the conic section. Declaration Transform Transform { get; } Property Value Type Description Transform"
  },
  "api/Elements.Geometry.Interfaces.ICurve.html": {
    "href": "api/Elements.Geometry.Interfaces.ICurve.html",
    "title": "Interface ICurve | Hypar Docs",
    "keywords": "Interface ICurve An infinite curve. Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface ICurve Methods ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the specified parameter along the curve. Declaration double ParameterAtDistanceFromParameter(double distance, double parameter) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double parameter The parameter from which to measure the distance. Returns Type Description System.Double PointAt(Double) Get a point along the curve at parameter u. Declaration Vector3 PointAt(double u) Parameters Type Name Description System.Double u A parameter on the curve. Returns Type Description Vector3 The point on the curve. TransformAt(Double) Get the frame from the curve at parameter u. Declaration Transform TransformAt(double u) Parameters Type Name Description System.Double u A parameter on the curve. Returns Type Description Transform The transform of the curve at parameter u, with the transform's Z axis tangent to the curve."
  },
  "api/Elements.Geometry.Interfaces.ITessellate.html": {
    "href": "api/Elements.Geometry.Interfaces.ITessellate.html",
    "title": "Interface ITessellate | Hypar Docs",
    "keywords": "Interface ITessellate Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface ITessellate Methods Tessellate(ref Mesh, Transform, Color) Add the tessellated representation of this object to the provided Mesh. Declaration void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh The mesh to which this object's representation will be added. Transform transform An optional transform to apply to each vertex. Color color An optional color to apply to each vertex."
  },
  "api/Elements.Geometry.Interfaces.ITransformable-1.html": {
    "href": "api/Elements.Geometry.Interfaces.ITransformable-1.html",
    "title": "Interface ITransformable<T> | Hypar Docs",
    "keywords": "Interface ITransformable<T> An object that can return a transformed copy of itself Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface ITransformable<T> Type Parameters Name Description T The type of object to be transformed Methods Transformed(Transform) Create a transformed copy of this ITransformable Declaration T Transformed(Transform transform) Parameters Type Name Description Transform transform Returns Type Description T A transformed copy of the object"
  },
  "api/Elements.Geometry.Interfaces.ITrimmedCurve-1.html": {
    "href": "api/Elements.Geometry.Interfaces.ITrimmedCurve-1.html",
    "title": "Interface ITrimmedCurve<TBasis> | Hypar Docs",
    "keywords": "Interface ITrimmedCurve<TBasis> A trimmed curve. Namespace : Elements.Geometry.Interfaces Assembly : Hypar.Elements.dll Syntax public interface ITrimmedCurve<TBasis> where TBasis : ICurve Type Parameters Name Description TBasis Properties BasisCurve The basis curve for this trimmed curve. Declaration TBasis BasisCurve { get; } Property Value Type Description TBasis"
  },
  "api/Elements.Geometry.Line.html": {
    "href": "api/Elements.Geometry.Line.html",
    "title": "Class Line | Hypar Docs",
    "keywords": "Class Line A line segment. Parameterization of the line is 0 (start) -> length (end) import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Line.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(); var b = new Vector3(5, 5, 5); var l = new Line(a, b); Inheritance System.Object Curve BoundedCurve TrimmedCurve < InfiniteLine > Line Implements ICurve ITransformable < Curve > IBoundedCurve ITrimmedCurve < InfiniteLine > System.IEquatable < Line > Inherited Members TrimmedCurve<InfiniteLine>.BasisCurve BoundedCurve.DefaultMinimumChordLength BoundedCurve.Start BoundedCurve.End BoundedCurve.IsClosedForRendering BoundedCurve.Frames(Double, Double, Double) BoundedCurve.ToPolyline(Int32) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Line : TrimmedCurve<InfiniteLine>, ICurve, ITransformable<Curve>, IBoundedCurve, ITrimmedCurve<InfiniteLine>, IEquatable<Line> Constructors Line() Create a line of one unit length along the X axis. Declaration public Line() Line(InfiniteLine) Create a line from a trimmed segment of an infinite line. Declaration public Line(InfiniteLine line) Parameters Type Name Description InfiniteLine line The infinite line from which this segment is trimmed. Line(Vector3, Vector3) Create a line. Declaration [JsonConstructor] public Line(Vector3 start, Vector3 end) Parameters Type Name Description Vector3 start The start of the line. Vector3 end The end of the line. Line(Vector3, Vector3, Double) Create a line of length from a start along direction. Declaration public Line(Vector3 start, Vector3 direction, double length) Parameters Type Name Description Vector3 start Vector3 direction System.Double length Properties Domain The domain of the curve. Declaration [JsonIgnore] public override Domain1d Domain { get; } Property Value Type Description Domain1d Overrides BoundedCurve.Domain Methods ArcLength(Double, Double) Calculate the length of the line between two parameters. Declaration public override double ArcLength(double start, double end) Parameters Type Name Description System.Double start System.Double end Returns Type Description System.Double Overrides BoundedCurve.ArcLength(Double, Double) BestFit(IList<Vector3>) Return an approximate fit line through a set of points using the least squares method. Declaration public static Line BestFit(IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points to fit. Should have at least 2 distinct points. Returns Type Description Line An approximate fit line through a set of points using the least squares method. If there is less than 2 distinct points, returns null. Bounds() Get the bounding box for this line. Declaration public override BBox3 Bounds() Returns Type Description BBox3 A bounding box for this line. Overrides BoundedCurve.Bounds() Direction() A normalized vector representing the direction of the line. Declaration public Vector3 Direction() Returns Type Description Vector3 Direction(Vector3, Vector3) A normalized vector representing the direction of a line, represented by a start and end point. The start point of the line. The end point of the line. Declaration public static Vector3 Direction(Vector3 start, Vector3 end) Parameters Type Name Description Vector3 start Vector3 end Returns Type Description Vector3 DistanceTo(Line) Measure the distance between two lines. Declaration public double DistanceTo(Line other) Parameters Type Name Description Line other The line to measure the distance to. Returns Type Description System.Double DivideByLength(Double, Boolean) Divide the line into as many segments of the provided length as possible. Declaration public List<Line> DivideByLength(double l, bool removeShortSegments = false) Parameters Type Name Description System.Double l The length. System.Boolean removeShortSegments A flag indicating whether segments shorter than l should be removed. Returns Type Description System.Collections.Generic.List < Line > DivideByLengthFromCenter(Double) Divide the line into as many segments of the provided length as possible. Divisions will be centered along the line. Declaration public List<Line> DivideByLengthFromCenter(double l) Parameters Type Name Description System.Double l The length. Returns Type Description System.Collections.Generic.List < Line > DivideIntoEqualSegments(Int32) Divide the line into n equal segments. Declaration public List<Line> DivideIntoEqualSegments(int n) Parameters Type Name Description System.Int32 n The number of segments. Returns Type Description System.Collections.Generic.List < Line > Equals(Line) Is this line equal to the provided line? Declaration public bool Equals(Line other) Parameters Type Name Description Line other The target line. Returns Type Description System.Boolean True if the start and end points of the lines are equal, otherwise false. ExtendTo(Line) Extend this line to the trimming curve. Declaration public Line ExtendTo(Line line) Parameters Type Name Description Line line The curve to which to extend. Returns Type Description Line A new line, or null if these lines would never intersect if extended infinitely. ExtendTo(Polygon, Boolean, Boolean, Double) Extend this line to its (nearest, by default) intersection with a polygon. Declaration public Line ExtendTo(Polygon polygon, bool bothSides = true, bool extendToFurthest = false, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The polygon to intersect with System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. System.Double tolerance Optional  The amount of tolerance to include in the extension method. Returns Type Description Line ExtendTo(Polygon, Double, Boolean, Boolean, Double) Extend this line to its (nearest, by default) intersection with a polygon, but no further than maxDistance. Declaration public Line ExtendTo(Polygon polygon, double maxDistance, bool bothSides = true, bool extendToFurthest = false, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The polygon to intersect with System.Double maxDistance Maximum extension distance. System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. System.Double tolerance Optional  The amount of tolerance to include in the extension method. Returns Type Description Line ExtendTo(Polyline, Boolean, Boolean) Extend this line to its (nearest, by default) intersection with a polyline. Declaration public Line ExtendTo(Polyline polyline, bool bothSides = true, bool extendToFurthest = false) Parameters Type Name Description Polyline polyline The polyline to intersect with System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. Returns Type Description Line ExtendTo(Polyline, Double, Boolean, Boolean) Extend this line to its (nearest, by default) intersection with a polyline, but no further than maxDistance. Declaration public Line ExtendTo(Polyline polyline, double maxDistance, bool bothSides = true, bool extendToFurthest = false) Parameters Type Name Description Polyline polyline The polyline to intersect with System.Double maxDistance Maximum extension distance. System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. Returns Type Description Line ExtendTo(Profile, Boolean, Boolean) Extend this line to its (nearest, by default) intersection with a profile. Declaration public Line ExtendTo(Profile profile, bool bothSides = true, bool extendToFurthest = false) Parameters Type Name Description Profile profile The profile to intersect with System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. Returns Type Description Line ExtendTo(Profile, Double, Boolean, Boolean) Extend this line to its (nearest, by default) intersection with a profile, but no further than maxDistance. Declaration public Line ExtendTo(Profile profile, double maxDistance, bool bothSides = true, bool extendToFurthest = false) Parameters Type Name Description Profile profile The profile to intersect with System.Double maxDistance Maximum extension distance. System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. Returns Type Description Line ExtendTo(IEnumerable<Line>, Boolean, Boolean, Double) Extend this line to its (nearest, by default) intersection with any other line. If optional extendToFurthest is true, extends to furthest intersection with any other line. Declaration public Line ExtendTo(IEnumerable<Line> otherLines, bool bothSides = true, bool extendToFurthest = false, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Line > otherLines The other lines to intersect with System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. System.Double tolerance Optional  The amount of tolerance to include in the extension method. Returns Type Description Line ExtendTo(IEnumerable<Line>, Double, Boolean, Boolean, Double) Extend this line to its (nearest, by default) intersection with any other line, but no further than maxDistance. If optional extendToFurthest is true, extends to furthest intersection with any other line, but no further than maxDistance. If the distance to the intersection with the lines is greater than the maximum, the line will be returned unchanged. Declaration public Line ExtendTo(IEnumerable<Line> otherLines, double maxDistance, bool bothSides = true, bool extendToFurthest = false, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Line > otherLines The other lines to intersect with. System.Double maxDistance Maximum extension distance. System.Boolean bothSides Optional  if false, will only extend in the line's direction; if true will extend in both directions. System.Boolean extendToFurthest Optional  if true, will extend line as far as it will go, rather than stopping at the closest intersection. System.Double tolerance Optional  The amount of tolerance to include in the extension method. Returns Type Description Line Fillet(Line, Double) Create a fillet arc between this line and the target. Declaration public Arc Fillet(Line target, double radius) Parameters Type Name Description Line target The line with which to fillet. System.Double radius The radius of the fillet. Returns Type Description Arc An arc, or null if no fillet can be calculated. GetHashCode() Get the hash code for the line. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() GetParameterAt(Vector3) Calculate U parameter for point on line Declaration public double GetParameterAt(Vector3 point) Parameters Type Name Description Vector3 point Point on line Returns Type Description System.Double Returns U parameter for point on line GetParameterAt(Vector3, Vector3, Vector3) Calculate U parameter for point between two other points Declaration public static double GetParameterAt(Vector3 point, Vector3 start, Vector3 end) Parameters Type Name Description Vector3 point Point for which parameter is calculated Vector3 start First point Vector3 end Second point Returns Type Description System.Double Returns U parameter for point between two other points GetSubdivisionParameters(Double, Double) Get parameters to be used to find points along the curve for visualization. Declaration public override double[] GetSubdivisionParameters(double startSetbackDistance = 0, double endSetbackDistance = 0) Parameters Type Name Description System.Double startSetbackDistance An optional setback from the start of the curve. System.Double endSetbackDistance An optional setback from the end of the curve. Returns Type Description System.Double [] A collection of parameter values. Overrides BoundedCurve.GetSubdivisionParameters(Double, Double) Intersects(BBox3, out List<Vector3>, Boolean, Double) Does this line touches or intersects the provided box in 3D? Declaration public bool Intersects(BBox3 box, out List<Vector3> results, bool infinite = false, double tolerance = 1E-05) Parameters Type Name Description BBox3 box Axis aligned box to intersect. System.Collections.Generic.List < Vector3 > results Up to two intersection points. System.Boolean infinite Treat the line as infinite? System.Double tolerance An optional distance tolerance. Returns Type Description System.Boolean True if the line touches or intersects the box at least at one point, false otherwise. Intersects(Line, out Vector3, Boolean, Boolean) Does this line intersect the provided line in 3D? Declaration public bool Intersects(Line l, out Vector3 result, bool infinite = false, bool includeEnds = false) Parameters Type Name Description Line l Vector3 result System.Boolean infinite Treat the lines as infinite? System.Boolean includeEnds If the end of one line lies exactly on the other, count it as an intersection? Returns Type Description System.Boolean True if the lines intersect, false if they are fully collinear or do not intersect. Intersects(Plane, Vector3, Vector3, out Vector3, Boolean) Intersect a segment defined by two points with a plane. Declaration public static bool Intersects(Plane p, Vector3 start, Vector3 end, out Vector3 result, bool infinite = false) Parameters Type Name Description Plane p The plane. Vector3 start The start of the segment. Vector3 end The end of the segment. Vector3 result The location of intersection. System.Boolean infinite Whether the segment should instead be considered infinite. Returns Type Description System.Boolean True if an intersection is found, otherwise false. Intersects(Plane, out Vector3, Boolean) Intersect this line with the specified plane Declaration public bool Intersects(Plane p, out Vector3 result, bool infinite = false) Parameters Type Name Description Plane p The plane. Vector3 result The location of intersection. System.Boolean infinite If true, line will be treated as infinite. (False by default) Returns Type Description System.Boolean True if the line intersects the plane, false if no intersection occurs. Intersects(Vector3, Vector3, Vector3, Vector3, out Vector3, Boolean, Boolean) Do two lines intersect in 3d? Declaration public static bool Intersects(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2, out Vector3 result, bool infinite = false, bool includeEnds = false) Parameters Type Name Description Vector3 start1 Start point of the first line Vector3 end1 End point of the first line Vector3 start2 Start point of the second line Vector3 end2 End point of the second line Vector3 result System.Boolean infinite Treat the lines as infinite? System.Boolean includeEnds If the end of one line lies exactly on the other, count it as an intersection? Returns Type Description System.Boolean True if the lines intersect, false if they are fully collinear or do not intersect. Intersects2D(Line) Does this line intersect the provided line in 2D? Declaration public bool Intersects2D(Line l) Parameters Type Name Description Line l Returns Type Description System.Boolean Return true if the lines intersect, false if the lines have coincident vertices or do not intersect. Intersects2d(Vector3, Vector3, Vector3, Vector3) Does the first line intersect with the second line in 2D? Declaration public static bool Intersects2d(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2) Parameters Type Name Description Vector3 start1 Start point of the first line Vector3 end1 End point of the first line Vector3 start2 Start point of the second line Vector3 end2 End point of the second line Returns Type Description System.Boolean Return true if the lines intersect, false if the lines have coincident vertices or do not intersect. IsAlmostEqualTo(Line, Boolean, Double) Are the two lines almost equal? Declaration public bool IsAlmostEqualTo(Line other, bool directionDependent, double tolerance = 1E-05) Parameters Type Name Description Line other System.Boolean directionDependent System.Double tolerance Returns Type Description System.Boolean IsCollinear(Line, Double) Check if this line is collinear with another line. Declaration public bool IsCollinear(Line line, double tolerance = 1E-05) Parameters Type Name Description Line line Line to check. System.Double tolerance If points are within this distance of a fit line, they will be considered collinear. Returns Type Description System.Boolean IsOnPlane(Plane, Double) Checks if line lays on plane Declaration public bool IsOnPlane(Plane plane, double tolerance = 1E-05) Parameters Type Name Description Plane plane Plane to check System.Double tolerance Optional tolerance value Returns Type Description System.Boolean The result of check if line lays on plane Length() Calculate the length of the line. Declaration public override double Length() Returns Type Description System.Double Overrides BoundedCurve.Length() MergedCollinearLine(Line) Creates new line with vertices of current and joined line Declaration public Line MergedCollinearLine(Line line) Parameters Type Name Description Line line Collinear line Returns Type Description Line New line containing vertices of all merged lines Exceptions Type Condition System.ArgumentException Throws exception when lines are not collinear Mid() The mid point of the line. Declaration public override Vector3 Mid() Returns Type Description Vector3 Overrides BoundedCurve.Mid() Offset(Double, Boolean) Offset the line. The offset direction will be defined by Direction X Vector3.ZAxis. Declaration public Line Offset(double distance, bool flip) Parameters Type Name Description System.Double distance The distance to offset. System.Boolean flip Flip the offset direction. Returns Type Description Line ParameterAtDistanceFromParameter(Double, Double) Get the parameter at a distance from the start parameter along the curve. Declaration public override double ParameterAtDistanceFromParameter(double distance, double start) Parameters Type Name Description System.Double distance The distance from the start parameter. System.Double start The parameter from which to measure the distance. Returns Type Description System.Double Overrides Curve.ParameterAtDistanceFromParameter(Double, Double) PointAt(Double) Get a point along the line at parameter u. Declaration public override Vector3 PointAt(double u) Parameters Type Name Description System.Double u A parameter on the curve between 0.0 and length. Returns Type Description Vector3 A point on the curve at parameter u. Overrides Curve.PointAt(Double) PointOnLine(Vector3, Vector3, Vector3, Boolean, Double) Test if a point lies within tolerance of a given line segment. Declaration public static bool PointOnLine(Vector3 point, Vector3 start, Vector3 end, bool includeEnds = false, double tolerance = 1E-05) Parameters Type Name Description Vector3 point The point to test. Vector3 start The start point of the line segment. Vector3 end The end point of the line segment. System.Boolean includeEnds Consider a point at the endpoint as on the line. System.Double tolerance An optional distance tolerance. When true, any point within tolerance of the end points will be considered on the line. When false, points precisely at the ends of the line will not be considered on the line. Returns Type Description System.Boolean PointOnLine(Vector3, Boolean, Double) Test if a point lies within tolerance of this line segment. Declaration public bool PointOnLine(Vector3 point, bool includeEnds = false, double tolerance = 1E-05) Parameters Type Name Description Vector3 point The point to test. System.Boolean includeEnds Consider a point at the endpoint as on the line. System.Double tolerance An optional distance tolerance. When true, any point within tolerance of the end points will be considered on the line. When false, points precisely at the ends of the line will not be considered on the line. Returns Type Description System.Boolean Projected(Plane) Projects current line onto a plane Declaration public Line Projected(Plane plane) Parameters Type Name Description Plane plane Plane to project Returns Type Description Line New line on a plane Reversed() Get a new line that is the reverse of the original line. Declaration public Line Reversed() Returns Type Description Line Thicken(Double) Thicken a line by the specified amount. Declaration public Polygon Thicken(double amount) Parameters Type Name Description System.Double amount The amount to thicken the line. Returns Type Description Polygon ToString() A string representation of the line. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() TransformAt(Double) Get a transform whose XY plane is perpendicular to the curve, and whose positive Z axis points along the curve. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter along the Line, between 0.0 and 1.0, at which to calculate the Transform. Returns Type Description Transform A transform. Overrides Curve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Curve.Transformed(Transform) TransformedLine(Transform) Construct a transformed copy of this Line. Declaration public Line TransformedLine(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Line Trim(Polygon, out List<Line>, Boolean, Boolean) Trim a line with a polygon. Declaration public List<Line> Trim(Polygon polygon, out List<Line> outsideSegments, bool includeCoincidenceAtEdge = false, bool infinite = false) Parameters Type Name Description Polygon polygon The polygon to trim with. System.Collections.Generic.List < Line > outsideSegments A list of the segment(s) of the line outside of the supplied polygon. System.Boolean includeCoincidenceAtEdge Include coincidence at edge as inner segment. System.Boolean infinite Treat the line as infinite? Returns Type Description System.Collections.Generic.List < Line > A list of the segment(s) of the line within the supplied polygon. TrimTo(Line, Boolean) Trim this line to the trimming curve. Declaration public Line TrimTo(Line line, bool flip = false) Parameters Type Name Description Line line The curve to which to trim. System.Boolean flip Should the trim direction be reversed? Returns Type Description Line A new line, or null if this line does not intersect the trimming line. TryGetOverlap(Line, out Line) Check if this line overlaps with another line. Declaration public bool TryGetOverlap(Line line, out Line overlap) Parameters Type Name Description Line line Line to check. Line overlap Overlapping line or null when lines do not overlap. Returns Type Description System.Boolean Returns true when lines overlap and false when they do not. TryGetOverlap(Line, Double, out Line) Check if this line overlaps with another line. Declaration public bool TryGetOverlap(Line line, double tolerance, out Line overlap) Parameters Type Name Description Line line Line to check System.Double tolerance Tolerance for distance-based checks. Line overlap Overlapping line or null when lines do not overlap. Returns Type Description System.Boolean Returns true when lines overlap and false when they do not. Implements ICurve ITransformable<T> IBoundedCurve ITrimmedCurve<TBasis> System.IEquatable<T>"
  },
  "api/Elements.Geometry.LineExtensions.html": {
    "href": "api/Elements.Geometry.LineExtensions.html",
    "title": "Class LineExtensions | Hypar Docs",
    "keywords": "Class LineExtensions Line extension methods. Inheritance System.Object LineExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class LineExtensions Methods Offset(List<Line>, Double) Offset the lines. The resulting polygon will have acute angles. Declaration public static List<Polygon> Offset(this List<Line> lines, double distance) Parameters Type Name Description System.Collections.Generic.List < Line > lines List of lines to offset. System.Double distance The distance to offset. Returns Type Description System.Collections.Generic.List < Polygon >"
  },
  "api/Elements.Geometry.LineSegmentExtensions.html": {
    "href": "api/Elements.Geometry.LineSegmentExtensions.html",
    "title": "Class LineSegmentExtensions | Hypar Docs",
    "keywords": "Class LineSegmentExtensions Line segment extension methods. Inheritance System.Object LineSegmentExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class LineSegmentExtensions Methods Intersections(IList<Line>) Find all intersections of the provided collection of lines. Declaration public static List<Vector3> Intersections(this IList<Line> items) Parameters Type Name Description System.Collections.Generic.IList < Line > items A collection of lines. Returns Type Description System.Collections.Generic.List < Vector3 > A collection of unique intersection points."
  },
  "api/Elements.Geometry.Matrix.html": {
    "href": "api/Elements.Geometry.Matrix.html",
    "title": "Class Matrix | Hypar Docs",
    "keywords": "Class Matrix A column-ordered 3x4 matrix. The first 3 columns represent the X, Y, and Z axes of the coordinate system. The fourth column represents the translation of the coordinate system. Inheritance System.Object Matrix Implements System.IEquatable < Matrix > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Matrix : IEquatable<Matrix> Constructors Matrix() Construct a 4X3 matrix. Declaration public Matrix() Matrix(Vector3, Vector3, Vector3, Vector3) Construct a matrix from axes. Declaration public Matrix(Vector3 xAxis, Vector3 yAxis, Vector3 zAxis, Vector3 translation) Parameters Type Name Description Vector3 xAxis The X axis. Vector3 yAxis The Y axis. Vector3 zAxis The Z axis. Vector3 translation The translation. Matrix(Double[]) Construct a matrix. Declaration [JsonConstructor] public Matrix(double[] components) Parameters Type Name Description System.Double [] components The components of the matrix. Properties Components The components of the matrix. Declaration [JsonProperty(\"Components\", Required = Required.Always)] [Required] [MinLength(12)] [MaxLength(12)] public double[] Components { get; set; } Property Value Type Description System.Double [] m11 m11 Declaration [JsonIgnore] public double m11 { get; set; } Property Value Type Description System.Double m12 m12 Declaration [JsonIgnore] public double m12 { get; set; } Property Value Type Description System.Double m13 m13 Declaration [JsonIgnore] public double m13 { get; set; } Property Value Type Description System.Double m21 m21 Declaration [JsonIgnore] public double m21 { get; set; } Property Value Type Description System.Double m22 m22 Declaration [JsonIgnore] public double m22 { get; set; } Property Value Type Description System.Double m23 m23 Declaration [JsonIgnore] public double m23 { get; set; } Property Value Type Description System.Double m31 m31 Declaration [JsonIgnore] public double m31 { get; set; } Property Value Type Description System.Double m32 m32 Declaration [JsonIgnore] public double m32 { get; set; } Property Value Type Description System.Double m33 m33 Declaration [JsonIgnore] public double m33 { get; set; } Property Value Type Description System.Double Translation The translation component of the Matrix. Declaration [JsonIgnore] public Vector3 Translation { get; } Property Value Type Description Vector3 tx tx Declaration [JsonIgnore] public double tx { get; set; } Property Value Type Description System.Double ty ty Declaration [JsonIgnore] public double ty { get; set; } Property Value Type Description System.Double tz tz Declaration [JsonIgnore] public double tz { get; set; } Property Value Type Description System.Double XAxis The X axis of the Matrix. Declaration [JsonIgnore] public Vector3 XAxis { get; } Property Value Type Description Vector3 YAxis The Y axis of the Matrix. Declaration [JsonIgnore] public Vector3 YAxis { get; } Property Value Type Description Vector3 ZAxis The Z axis of the Matrix. Declaration [JsonIgnore] public Vector3 ZAxis { get; } Property Value Type Description Vector3 Methods Determinant() Compute the determinant of the 3x3 portion of the matrix. Declaration public double Determinant() Returns Type Description System.Double Equals(Matrix) Is this matrix equal to other? Declaration public bool Equals(Matrix other) Parameters Type Name Description Matrix other The transform to test. Returns Type Description System.Boolean True if the two transforms are equal, otherwise false. GetHashCode() Get the hash code for the matrix. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Inverse() Compute the inverse of the matrix. Declaration [Obsolete(\"Use Matrix.Inverted() instead.\")] public Matrix Inverse() Returns Type Description Matrix Inverted() Compute the inverse of the matrix. Declaration public Matrix Inverted() Returns Type Description Matrix SetIdentity() Set the matrix to identity. Declaration public void SetIdentity() SetTranslation(Vector3) Set the translation of the matrix. Declaration public void SetTranslation(Vector3 v) Parameters Type Name Description Vector3 v The translation vector. SetupProject(Plane) Setup the matrix to project. Declaration public void SetupProject(Plane p) Parameters Type Name Description Plane p The plane on which to project. SetupReflect(Vector3) Setup the matrix to reflect about a plane with normal n. Declaration public void SetupReflect(Vector3 n) Parameters Type Name Description Vector3 n The normal of the reflection plane. SetupRotate(Vector3, Double) Setup the matrix to perform rotation. Declaration public void SetupRotate(Vector3 axis, double theta) Parameters Type Name Description Vector3 axis The axis of rotation. System.Double theta The angle of rotation in radians. SetupRotate(Int32, Double) Setup the matrix to rotate. Declaration public void SetupRotate(int axis, double theta) Parameters Type Name Description System.Int32 axis The axis of rotation. 1-x, 2-y, 3-z System.Double theta The angle of rotation in radians. SetupScale(Vector3) Setup the matrix to scale. Declaration public void SetupScale(Vector3 s) Parameters Type Name Description Vector3 s The scale value. SetupTranslation(Vector3) Setup the matrix to translate. Declaration public void SetupTranslation(Vector3 v) Parameters Type Name Description Vector3 v The translation. ToString() Return the string representation of the matrix. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Transpose() Transpose the matrix. Declaration public Matrix Transpose() Returns Type Description Matrix ZeroTranslation() Set the translation of the matrix to zero. Declaration public void ZeroTranslation() Operators Multiply(Matrix, Matrix) Multiply two matrices. Declaration public static Matrix operator *(Matrix a, Matrix b) Parameters Type Name Description Matrix a Matrix b Returns Type Description Matrix Multiply(Vector3, Matrix) Transform the specified vector. Declaration public static Vector3 operator *(Vector3 p, Matrix m) Parameters Type Name Description Vector3 p The vector to transform. Matrix m The transformation matrix. Returns Type Description Vector3 Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.Mesh.html": {
    "href": "api/Elements.Geometry.Mesh.html",
    "title": "Class Mesh | Hypar Docs",
    "keywords": "Class Mesh A triangle mesh. Inheritance System.Object Mesh Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(MeshConverter))] public class Mesh Constructors Mesh() Construct an empty mesh. Declaration public Mesh() Mesh(Mesh) Create a new mesh from another mesh by copying vertices and triangles. Declaration public Mesh(Mesh mesh) Parameters Type Name Description Mesh mesh Mesh(IList<Vertex>, IList<Triangle>) Construct a mesh. Declaration [JsonConstructor] public Mesh(IList<Vertex> vertices, IList<Triangle> triangles) Parameters Type Name Description System.Collections.Generic.IList < Vertex > vertices The vertices of the mesh. System.Collections.Generic.IList < Triangle > triangles The triangles of the mesh. Properties BoundingBox The mesh's bounding box. Declaration public BBox3 BoundingBox { get; } Property Value Type Description BBox3 Triangles The mesh's triangles. Declaration [JsonProperty(\"Triangles\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public IList<Triangle> Triangles { get; set; } Property Value Type Description System.Collections.Generic.IList < Triangle > Vertices The mesh's vertices. Declaration [JsonProperty(\"Vertices\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public IList<Vertex> Vertices { get; set; } Property Value Type Description System.Collections.Generic.IList < Vertex > Methods AddTriangle(Triangle) Add a triangle to the mesh. Declaration public Triangle AddTriangle(Triangle t) Parameters Type Name Description Triangle t The triangle to add. Returns Type Description Triangle AddTriangle(Vertex, Vertex, Vertex) Add a triangle to the mesh. Declaration public Triangle AddTriangle(Vertex a, Vertex b, Vertex c) Parameters Type Name Description Vertex a The first vertex. Vertex b The second vertex. Vertex c The third vertex. Returns Type Description Triangle AddVertex(Vector3, UV, Vector3, Color, Boolean, Double) Add a vertex to the mesh. Declaration public Vertex AddVertex(Vector3 position, UV uv = default(UV), Vector3 normal = default(Vector3), Color color = default(Color), bool merge = false, double edgeAngle = 30) Parameters Type Name Description Vector3 position The position of the vertex. UV uv The texture coordinate of the vertex. Vector3 normal The vertex's normal. Color color The vertex's color. System.Boolean merge If true, and a vertex already exists with a position within Vector3.EPSILON, that vertex will be returned. System.Double edgeAngle If merge is true, vertices will be merged if the angle between them is less than edgeAngle. Returns Type Description Vertex The newly created vertex. AddVertex(Vertex) Add a vertex to the mesh. Declaration public Vertex AddVertex(Vertex v) Parameters Type Name Description Vertex v The vertex to add. Returns Type Description Vertex ComputeNormals() Compute the vertex normals by averaging the normals of the incident faces. Declaration public void ComputeNormals() FromSTL(String, Units.LengthUnit) Construct a mesh from an STL file. Declaration public static Mesh FromSTL(string stlPath, Units.LengthUnit unit = Units.LengthUnit.Millimeter) Parameters Type Name Description System.String stlPath The path to the STL file. Units.LengthUnit unit The length unit used in the file. Returns Type Description Mesh GetBuffers() Get all buffers required for rendering. Declaration public GraphicsBuffers GetBuffers() Returns Type Description GraphicsBuffers GetNakedBoundaries() Get the naked edges of this mesh as polylines Declaration public List<Polyline> GetNakedBoundaries() Returns Type Description System.Collections.Generic.List < Polyline > GetNakedEdges() Get the open edges of this mesh. Declaration public List<Line> GetNakedEdges() Returns Type Description System.Collections.Generic.List < Line > Intersects(Ray, out Vector3) Does the provided ray intersect this mesh mesh? Declaration public bool Intersects(Ray ray, out Vector3 intersection) Parameters Type Name Description Ray ray The Ray to intersect. Vector3 intersection The location of intersection. Returns Type Description System.Boolean True if an intersection result occurs. False if no intersection occurs. RemoveTriangle(Triangle) Removes the specified triangle from the mesh and updates the vertex-triangle relationships. Declaration public void RemoveTriangle(Triangle face) Parameters Type Name Description Triangle face The triangle to remove. Sphere(Double, Int32) A mesh sphere. Declaration public static Mesh Sphere(double radius, int divisions = 10) Parameters Type Name Description System.Double radius The radius of the sphere. System.Int32 divisions The number of tessellations of the sphere. Returns Type Description Mesh A mesh. ToString() Get a string representation of the mesh. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Volume() Calculate the volume of the mesh. This value will be inexact for open meshes. Declaration public double Volume() Returns Type Description System.Double The volume of the mesh."
  },
  "api/Elements.Geometry.NormalizationType.html": {
    "href": "api/Elements.Geometry.NormalizationType.html",
    "title": "Enum NormalizationType | Hypar Docs",
    "keywords": "Enum NormalizationType Normalization type. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum NormalizationType Fields Name Description End During normalization move end points of segments. Middle During normalization move both start and end vertices in approximately equivalent proportions. Start During normalization move start points of segments."
  },
  "api/Elements.Geometry.Plane.html": {
    "href": "api/Elements.Geometry.Plane.html",
    "title": "Class Plane | Hypar Docs",
    "keywords": "Class Plane A cartesian plane. Inheritance System.Object Plane Implements System.IEquatable < Plane > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Plane : IEquatable<Plane> Constructors Plane(Vector3, Vector3) Construct a plane. Declaration [JsonConstructor] public Plane(Vector3 origin, Vector3 normal) Parameters Type Name Description Vector3 origin The origin of the plane. Vector3 normal The normal of the plane. Plane(Vector3, Vector3, Vector3) Construct a plane by three points. The plane is constructed as a->b * b->c. Declaration public Plane(Vector3 a, Vector3 b, Vector3 c) Parameters Type Name Description Vector3 a Vector3 b Vector3 c Plane(Vector3, IList<Vector3>) Construct a plane. Only the first three points of the points array will be used. Declaration public Plane(Vector3 origin, IList<Vector3> points) Parameters Type Name Description Vector3 origin The origin of the plane. System.Collections.Generic.IList < Vector3 > points An array of vectors to be used to determine the normal of the plane. Properties Normal The normal of the plane. Declaration [JsonProperty(\"Normal\", Required = Required.AllowNull)] public Vector3 Normal { get; set; } Property Value Type Description Vector3 Origin The origin of the plane. Declaration [JsonProperty(\"Origin\", Required = Required.AllowNull)] public Vector3 Origin { get; set; } Property Value Type Description Vector3 XY The world XY Plane. Declaration public static Plane XY { get; } Property Value Type Description Plane XZ The world XZ Plane. Declaration public static Plane XZ { get; } Property Value Type Description Plane YZ The world YZ Plane. Declaration public static Plane YZ { get; } Property Value Type Description Plane Methods ClosestPoint(Vector3) Find the closest point on this plane from a given sample point. Declaration public Vector3 ClosestPoint(Vector3 point) Parameters Type Name Description Vector3 point The sample point. Returns Type Description Vector3 The closest point to the sample point on this plane. Equals(Plane) Is this plane equal to the provided plane? Declaration public bool Equals(Plane other) Parameters Type Name Description Plane other The plane to test. Returns Type Description System.Boolean Returns true if the two planes are equal, otherwise false. Intersects(Plane, Plane, out Vector3) Does this plane intersect the other two provided planes. Declaration public bool Intersects(Plane a, Plane b, out Vector3 result) Parameters Type Name Description Plane a The second plane. Plane b The third plane. Vector3 result The location of intersection. Returns Type Description System.Boolean True if an intersection exists, otherwise false. Intersects((Vector3 from, Vector3 to), out Vector3) Does this plane intersect the provided edge? Declaration public bool Intersects((Vector3 from, Vector3 to) edge, out Vector3 result) Parameters Type Name Description System.ValueTuple < Vector3 , Vector3 > edge The edge to intersect. Vector3 result The intersection. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. IsCoplanar(Plane) Is this plane coplanar with the provided plane? This method assumes that both planes have unit length normals. Declaration public bool IsCoplanar(Plane plane) Parameters Type Name Description Plane plane The plane to test. Returns Type Description System.Boolean True if the plane is coplanar, otherwise false. SignedDistanceTo(Vector3) Find the signed distance from a sample point to a plane. If positive, the point is on the \"Normal\" side of the plane, otherwise it is on the opposite side. Declaration public double SignedDistanceTo(Vector3 point) Parameters Type Name Description Vector3 point The sample point. Returns Type Description System.Double The signed distance between this plane and the sample point. Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.Polygon.html": {
    "href": "api/Elements.Geometry.Polygon.html",
    "title": "Class Polygon | Hypar Docs",
    "keywords": "Class Polygon A closed planar polygon. Parameterization of the curve is 0->n-1 where n is the number of vertices.. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Polygon.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a polygon. var star = Polygon.Star(5, 3, 5); Inheritance System.Object Curve BoundedCurve IndexedPolycurve Polyline Polygon Implements ICurve ITransformable < Curve > IBoundedCurve System.Collections.Generic.IEnumerable < BoundedCurve > System.Collections.IEnumerable System.IEquatable < IndexedPolycurve > Inherited Members Polyline.TransformAt(Double) Polyline.TransformedPolyline(Transform) Polyline.TransformSegment(Transform, Int32, Boolean, Boolean) Polyline.CreateMiterTransform(Int32, Vector3, Vector3) Polyline.OffsetOnSide(Double, Boolean) Polyline.OffsetOpen(Double) Polyline.OffsetWithAcuteAngle(Double) Polyline.SharedSegments(Polyline, Polyline, Boolean) Polyline.Split(IList<Vector3>, Boolean) Polyline.GetParameterAt(Vector3) Polyline.Intersects(Line, List<Vector3>, Boolean, Boolean) Polyline.Intersects(Polygon, List<Polyline>) Polyline.GetSubsegment(Vector3, Vector3) Polyline.ForceAngleCompliance(IEnumerable<Double>, Vector3, Double, NormalizationType) Polyline.ForceAngleCompliance(IEnumerable<Double>, Vector3, NormalizationType) IndexedPolycurve.Start IndexedPolycurve.CurveIndices IndexedPolycurve.Vertices IndexedPolycurve.Bounds() IndexedPolycurve.GetSubdivisionParameters(Double, Double) IndexedPolycurve.ArcLength(Double, Double) IndexedPolycurve.ParameterAtDistanceFromParameter(Double, Double) IndexedPolycurve.PointAt(Double) IndexedPolycurve.PointAtInternal(Double, Int32) IndexedPolycurve.TransformedPolycurve(Transform) IndexedPolycurve.Equals(IndexedPolycurve) IndexedPolycurve.ToPolygon() IndexedPolycurve.CheckCoincidenceAndThrow(IList<Vector3>) IndexedPolycurve.GetEnumerator() IndexedPolycurve.IEnumerable.GetEnumerator() BoundedCurve.DefaultMinimumChordLength BoundedCurve.Mid() BoundedCurve.ToPolyline(Int32) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Polygon : Polyline, ICurve, ITransformable<Curve>, IBoundedCurve, IEnumerable<BoundedCurve>, IEnumerable, IEquatable<IndexedPolycurve> Constructors Polygon(Vector3[]) Construct a polygon from points. This is a convenience constructor that can be used like this: new Polygon((0,0,0), (10,0,0), (10,10,0)) Declaration public Polygon(params Vector3[] vertices) Parameters Type Name Description Vector3 [] vertices The vertices of the polygon. Polygon(Boolean, Vector3[]) Construct a polygon from points. Declaration public Polygon(bool disableValidation, params Vector3[] vertices) Parameters Type Name Description System.Boolean disableValidation Should self-intersection testing be disabled? Vector3 [] vertices The vertices of the polygon. Polygon(IList<Vector3>) Construct a polygon. Declaration [JsonConstructor] public Polygon(IList<Vector3> vertices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices A collection of vertex locations. Polygon(IList<Vector3>, Boolean) Construct a polygon. Declaration public Polygon(IList<Vector3> vertices, bool disableValidation = false) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices A collection of vertex locations. System.Boolean disableValidation Should self-intersection testing be disabled? Properties Domain The domain of the curve. Declaration [JsonIgnore] public override Domain1d Domain { get; } Property Value Type Description Domain1d Overrides Polyline.Domain End The end of the polyline. Declaration [JsonIgnore] public override Vector3 End { get; } Property Value Type Description Vector3 Overrides IndexedPolycurve.End IsClosedForRendering Should the curve be considered closed for rendering? Declaration public override bool IsClosedForRendering { get; } Property Value Type Description System.Boolean Overrides BoundedCurve.IsClosedForRendering Methods Area(Boolean) Calculate the polygon's area in 3D. Declaration public double Area(bool signed = false) Parameters Type Name Description System.Boolean signed When true will return a signed area, counter-clockwise polygons will yield a positive area, while clockwise polygons will yield a negative area. Returns Type Description System.Double A double representing the signed or absolute value of this Polygon's area. Center() Calculate the center of the polygon as the average of vertices. Declaration public Vector3 Center() Returns Type Description Vector3 Centroid() Calculate the centroid of the polygon. Declaration public Vector3 Centroid() Returns Type Description Vector3 Circle(Double, Int32) Create a circle. Declaration [Obsolete(\"Please use Elements.Geometry.Circle.ToPolygon() instead.\")] public static Polygon Circle(double radius = 1, int divisions = 10) Parameters Type Name Description System.Double radius The radius of the circle. System.Int32 divisions The number of divisions of the circle. Returns Type Description Polygon A circle as a Polygon tessellated into the specified number of divisions. CollinearPointsRemoved(Double) Remove collinear points from this Polygon. Declaration public Polygon CollinearPointsRemoved(double tolerance = 1E-05) Parameters Type Name Description System.Double tolerance Returns Type Description Polygon New Polygon without collinear points. Contains(Polygon) Tests if the supplied Polygon is within this Polygon without coincident edges when compared on a shared plane. Declaration public bool Contains(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. Returns Type Description System.Boolean Returns true if every vertex of the supplied Polygon is within this Polygon when compared on a shared plane. Returns false if the supplied Polygon is not entirely within this Polygon, or if the supplied Polygon is null. Contains(Vector3) Tests if the supplied Vector3 is within this Polygon in 3D without coincidence with an edge or vertex when compared on a shared plane. Declaration public bool Contains(Vector3 point) Parameters Type Name Description Vector3 point The point to compare to this polygon. Returns Type Description System.Boolean Returns true if the supplied point is within this polygon when compared on a shared plane. Contains(Vector3, out Containment) Tests if the supplied point is within this polygon in 3D, using a 2D method. Declaration public bool Contains(Vector3 point, out Containment containment) Parameters Type Name Description Vector3 point The point to compare to this polygon. Containment containment Whether the point is inside, outside, at an edge, or at a vertex. Returns Type Description System.Boolean Returns true if the supplied point is within this polygon when compared on a shared plane. Contains3D(Polygon, out Containment) Tests if the supplied polygon is within this Polygon or coincident with an edge. Declaration public bool Contains3D(Polygon polygon, out Containment containment) Parameters Type Name Description Polygon polygon The polygon we want to know is inside this polygon. Containment containment The containment status. Returns Type Description System.Boolean Returns false if any part of the polygon is entirely outside of this polygon. Covers(Polygon) Tests if the supplied Polygon is within this Polygon with or without edge coincident vertices when compared on a shared plane. Declaration public bool Covers(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. Returns Type Description System.Boolean Returns true if every edge of the provided polygon is on or within this polygon when compared on a shared plane. Returns false if any edge of the supplied Polygon is outside this Polygon, or if the supplied Polygon is null. Covers(Vector3) Tests if the supplied Vector3 is within this Polygon or coincident with an edge when compared on the XY plane. Declaration public bool Covers(Vector3 vector) Parameters Type Name Description Vector3 vector The Vector3 to compare to this Polygon. Returns Type Description System.Boolean Returns true if the supplied Vector3 is within this Polygon or coincident with an edge when compared in the XY shared plane. Returns false if the supplied Vector3 is outside this Polygon, or if the supplied Vector3 is null. Difference(Polygon, Double) Constructs the geometric difference between this Polygon and the supplied Polygon. Declaration public IList<Polygon> Difference(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The intersecting Polygon. System.Double tolerance An optional tolerance value. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the subtraction of the supplied Polygon from this Polygon. Returns null if the area of this Polygon is entirely subtracted. Returns a list containing a representation of the perimeter of this Polygon if the two Polygons do not intersect. Difference(Polygon[]) Constructs the geometric difference between this Polygon and one or more supplied Polygons, using the default tolerance. Declaration public IList<Polygon> Difference(params Polygon[] polygons) Parameters Type Name Description Polygon [] polygons The intersecting Polygons. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the subtraction of the supplied Polygons from this Polygon. Returns null if the area of this Polygon is entirely subtracted. Returns a list containing a representation of the perimeter of this Polygon if the Polygons do not intersect. Difference(IList<Polygon>, IList<Polygon>, Double) Constructs the geometric difference between two sets of polygons. Declaration public static IList<Polygon> Difference(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the subtraction of the second set of polygons from the first set. Difference(IList<Polygon>, Double) Constructs the geometric difference between this Polygon and the supplied Polygons. Declaration public IList<Polygon> Difference(IList<Polygon> difPolys, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > difPolys The list of intersecting Polygons. System.Double tolerance An optional tolerance value. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the subtraction of the supplied Polygons from this Polygon. Returns null if the area of this Polygon is entirely subtracted. Returns a list containing a representation of the perimeter of this Polygon if the two Polygons do not intersect. Disjoint(Polygon) Tests if the supplied Polygon and this Polygon are coincident in any way when compared on a shared plane. Declaration public bool Disjoint(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. Returns Type Description System.Boolean Returns true if the supplied Polygon do not intersect or touch this Polygon when compared on a shared plane or if the supplied Polygon is null. Disjoint(Vector3) Tests if the supplied Vector3 is outside this Polygon when compared on a shared plane. Declaration public bool Disjoint(Vector3 vector) Parameters Type Name Description Vector3 vector The Vector3 to compare to this Polygon. Returns Type Description System.Boolean Returns true if the supplied Vector3 is outside this Polygon when compared on a shared plane or if the supplied Vector3 is null. Equals(Object) Is this polygon equal to the provided polygon? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) Fillet(Double) Fillet all corners on this polygon. Declaration public IndexedPolycurve Fillet(double radius) Parameters Type Name Description System.Double radius The fillet radius. Returns Type Description IndexedPolycurve A contour containing trimmed edge segments and fillets. Frames(Double, Double, Double) Get a collection of Transforms which represent frames along this curve. Declaration public override Transform[] Frames(double startSetback = 0, double endSetback = 0, double additionalRotation = 0) Parameters Type Name Description System.Double startSetback System.Double endSetback System.Double additionalRotation An additional rotation of the frame at each point. Returns Type Description Transform [] A collection of Transforms. Overrides Polyline.Frames(Double, Double, Double) FromAlignedBoundingBox2d(IEnumerable<Vector3>) Find the minimum-area rotated rectangle containing a set of points, calculated without regard for Z coordinate. Declaration public static Polygon FromAlignedBoundingBox2d(IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The points to contain within the rectangle Returns Type Description Polygon A rectangular polygon that contains all input points FromAlignedBoundingBox2d(IEnumerable<Vector3>, Vector3, Double) Find the rectangle along axis containing a set of points, calculated without regard for Z coordinate, located at the height of points minimum Z coordinate. Declaration public static Polygon FromAlignedBoundingBox2d(IEnumerable<Vector3> points, Vector3 axis, double minSideSize = 0.1) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The points to contain within the rectangle. Vector3 axis The axis along which the rectangle is built. Must be a non-zero vector. System.Double minSideSize The minimum size of a side of a polygon when all points lie on the same line and polygon cannot be constructed. Must be greater than 0. Returns Type Description Polygon GetHashCode() Get the hash code for the polygon. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Intersection(Polygon, Double) Constructs the Polygon intersections between this Polygon and the supplied Polygon. Declaration public IList<Polygon> Intersection(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The intersecting Polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the intersection of this Polygon with the supplied Polygon. Returns null if the two Polygons do not intersect. Intersection(IList<Polygon>, IList<Polygon>, Double) Constructs the Polygon intersections between two sets of polygons. Declaration public static IList<Polygon> Intersection(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the intersection of the first set of Polygons with the second set. Returns null if the Polygons do not intersect. Intersects(Plane, out List<Vector3>, Boolean, Boolean) Does this polygon intersect the provided plane? Declaration public bool Intersects(Plane plane, out List<Vector3> results, bool distinct = true, bool sort = true) Parameters Type Name Description Plane plane The intersection plane. System.Collections.Generic.List < Vector3 > results A collection of intersection results sorted along the plane. System.Boolean distinct Should the intersection results that are returned be distinct? System.Boolean sort Should the intersection results be sorted along the plane? Returns Type Description System.Boolean True if the plane intersects the polygon, otherwise false. Intersects(Polygon) Tests if the supplied Polygon shares one or more areas with this Polygon when compared on a shared plane. Declaration public bool Intersects(Polygon polygon) Parameters Type Name Description Polygon polygon The Polygon to compare with this Polygon. Returns Type Description System.Boolean Returns true if the supplied Polygon shares one or more areas with this Polygon when compared on a shared plane. Returns false if the supplied Polygon does not share an area with this Polygon or if the supplied Polygon is null. IsAlmostEqualTo(Polygon, Double, Boolean) Test if this polygon has the same vertex count and shape as another, within tolerance. Declaration public bool IsAlmostEqualTo(Polygon other, double tolerance = 1E-05, bool ignoreWinding = false) Parameters Type Name Description Polygon other The other polygon. System.Double tolerance The optional tolerance value to use. If not supplied, the global tolerance will be used. System.Boolean ignoreWinding If true, polygons with opposite winding will be considered as equal. Returns Type Description System.Boolean IsClockWise() Calculates whether this polygon is configured clockwise. This method only works for 2D polygons. For 3D polygons, you will need to transform your polygon into the XY plane, then run this method on that polygon. Declaration public bool IsClockWise() Returns Type Description System.Boolean True if this polygon is oriented clockwise. L(Double, Double, Double) Create an L. Declaration public static Polygon L(double width, double length, double thickness) Parameters Type Name Description System.Double width The width of the L. System.Double length The length of the L. System.Double thickness The thickness of the L. Returns Type Description Polygon An L shaped polygon with the origin at the outer corner of the bend in the L. Length() Calculate the length of the polygon. Declaration public override double Length() Returns Type Description System.Double Overrides Polyline.Length() Ngon(Int32, Double) Create an ngon. Declaration public static Polygon Ngon(int sides, double radius = 0.5) Parameters Type Name Description System.Int32 sides The number of side of the Polygon. System.Double radius The radius of the circle in which the Ngon is inscribed. Returns Type Description Polygon A Polygon with the specified number of sides. Normal() The normal of this polygon, according to Newell's Method. Declaration public Vector3 Normal() Returns Type Description Vector3 The unitized sum of the cross products of each pair of edges. NormalsAtVertices() Get the normal of each vertex on the polygon. Declaration protected override Vector3[] NormalsAtVertices() Returns Type Description Vector3 [] A collection of unit vectors, each corresponding to a single vertex. Overrides Polyline.NormalsAtVertices() Remarks All normals will be the same since polygons are coplanar by definition. Offset(Double, EndType, Double) Offset this polygon by the specified amount. Declaration public override Polygon[] Offset(double offset, EndType endType = EndType.ClosedPolygon, double tolerance = 1E-05) Parameters Type Name Description System.Double offset The amount to offset. EndType endType The type of closure used for the offset polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon [] A new Polygon offset by offset. Overrides Polyline.Offset(Double, EndType, Double) Plane() Compute the plane of the Polygon. Declaration public override Plane Plane() Returns Type Description Plane A Plane. Overrides Polyline.Plane() PointInternal() Find a point that is guaranteed to be internal to the polygon. Declaration public Vector3 PointInternal() Returns Type Description Vector3 Project(Plane) Project this polygon onto the plane. Declaration public Polygon Project(Plane plane) Parameters Type Name Description Plane plane The plane of the returned polygon. Returns Type Description Polygon ProjectAlong(Vector3, Plane) Project this Polygon onto a Plane along a vector. Declaration public Polygon ProjectAlong(Vector3 direction, Plane p) Parameters Type Name Description Vector3 direction The projection vector. Plane p The Plane onto which to project the Polygon. Returns Type Description Polygon A Polygon projected onto the Plane. Rectangle(Vector3, Vector3, Plane, Nullable<Vector3>) Create a rectangle. Declaration public static Polygon Rectangle(Vector3 min, Vector3 max, Plane plane, Vector3? alignment = null) Parameters Type Name Description Vector3 min The minimum coordinate. Vector3 max The maximum coordinate. Plane plane The plane to project the rectangle on. System.Nullable < Vector3 > alignment The alignment reference to construct the rectangle from. Returns Type Description Polygon A rectangular Polygon with its lower left corner projected from min and its upper right corner projected from max onto a plane with a sided alignment. Rectangle(Vector3, Vector3, Transform) Create a rectangle. Declaration public static Polygon Rectangle(Vector3 min, Vector3 max, Transform transform = null) Parameters Type Name Description Vector3 min The minimum coordinate. Vector3 max The maximum coordinate. Transform transform The transform reference to construct the rectangle from. Returns Type Description Polygon A rectangular Polygon with its lower left corner projected from min and its upper right corner projected from max onto a transform. Rectangle(Double, Double, Plane) Create a rectangle. Declaration public static Polygon Rectangle(double width, double height, Plane plane = null) Parameters Type Name Description System.Double width The width of the rectangle. System.Double height The height of the rectangle. Plane plane The plane to draw the rectangle on. Returns Type Description Polygon A rectangular Polygon centered around origin. RemoveVerticesNearCurve(Curve, out List<Vector3>, Double) Trim vertices from a polygon that lie near a given curve. Declaration public Polygon RemoveVerticesNearCurve(Curve curve, out List<Vector3> removed, double tolerance = 1E-05) Parameters Type Name Description Curve curve The curve used to trim the polygon System.Collections.Generic.List < Vector3 > removed The vertices that were removed. System.Double tolerance Optional tolerance value. Returns Type Description Polygon Reversed() Reverse the direction of a polygon. Declaration public Polygon Reversed() Returns Type Description Polygon Returns a new Polygon whose vertices are reversed. Segments() Get a collection a line segments which connect the vertices of this polyline. Declaration public override Line[] Segments() Returns Type Description Line [] A collection of Lines. Overrides Polyline.Segments() Split(Polyline[]) Split this polygon with one or more open polylines. Declaration public List<Polygon> Split(params Polyline[] polylines) Parameters Type Name Description Polyline [] polylines The polylines with which to split. Returns Type Description System.Collections.Generic.List < Polygon > Split(IEnumerable<Polyline>) Split this polygon with a collection of open polylines. Declaration public List<Polygon> Split(IEnumerable<Polyline> polylines) Parameters Type Name Description System.Collections.Generic.IEnumerable < Polyline > polylines The polylines with which to split. Returns Type Description System.Collections.Generic.List < Polygon > Split(IList<Vector3>) Insert a point into the polygon if it lies along one of the polyline's segments. Declaration public override void Split(IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points at which to split the polygon. Overrides Polyline.Split(IList<Vector3>) Star(Double, Double, Int32) Create a star. Declaration public static Polygon Star(double outerRadius, double innerRadius, int points) Parameters Type Name Description System.Double outerRadius The outer radius. System.Double innerRadius The inner radius. System.Int32 points The number of points. Returns Type Description Polygon A star shaped polygon with the specified number of points along the outer radius and their compliment along the inner radius. ToString() The string representation of the Polygon. Declaration public override string ToString() Returns Type Description System.String A string containing the string representations of this Polygon's vertices. Overrides IndexedPolycurve.ToString() ToTransform() Construct a transform in the plane of this polygon, with its Z axis along the polygon's normal. Declaration public Transform ToTransform() Returns Type Description Transform Touches(Polygon, Double) Tests if at least one point of an edge of the supplied Polygon is shared with an edge of this Polygon without the Polygons interesecting when compared on a shared plane. Declaration public bool Touches(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The Polygon to compare to this Polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Boolean Returns true if the supplied Polygon shares at least one edge point with this Polygon without the Polygons intersecting when compared on a shared plane. Returns false if the Polygons intersect, are disjoint, or if the supplied Polygon is null. Touches(Vector3, Double) Tests if the supplied Vector3 is coincident with an edge of this Polygon when compared on a shared plane. Declaration public bool Touches(Vector3 vector, double tolerance = 1E-05) Parameters Type Name Description Vector3 vector The Vector3 to compare to this Polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Boolean Returns true if the supplied Vector3 coincides with an edge of this Polygon when compared on a shared plane. Returns false if the supplied Vector3 is not coincident with an edge of this Polygon, or if the supplied Vector3 is null. Transform(Transform) Transform this polygon in place. Declaration public void Transform(Transform t) Parameters Type Name Description Transform t The transform. Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides Polyline.Transformed(Transform) TransformedPolygon(Transform) Construct a transformed copy of this Polygon. Declaration public Polygon TransformedPolygon(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Polygon TransformSegment(Transform, Int32) Transform a specified segment of this polygon in place. Declaration public void TransformSegment(Transform t, int i) Parameters Type Name Description Transform t The transform. If it is not within the polygon plane, then an exception will be thrown. System.Int32 i The segment to transform. If it does not exist, then no work will be done. Trimmed(Plane, Boolean) Trim the polygon with a plane. Everything on the \"back\" side of the plane will be trimmed. Declaration public List<Polygon> Trimmed(Plane plane, bool flip = false) Parameters Type Name Description Plane plane The trimming plane. System.Boolean flip Should the plane be flipped? Returns Type Description System.Collections.Generic.List < Polygon > A collection of new polygons, trimmed by the plane, or null if no trimming occurred. TrimmedTo(IList<Polygon>, LocalClassification) Trim the polygon with a collection of polygons that intersect it in 3d. Portions of the intersected polygon on the \"outside\" (normal-facing side) of the trimming polygons will remain. Portions inside the trimming polygons will be discarded. Declaration public List<Polygon> TrimmedTo(IList<Polygon> polygons, LocalClassification inOut = LocalClassification.Outside) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The trimming polygons. LocalClassification inOut A classification indicating which trim area should be returned. Returns Type Description System.Collections.Generic.List < Polygon > A collection of polygons resulting from the trim or null if no trim occurred. TrimmedTo(IList<Polygon>, out List<Vector3>, out List<(Vector3 from, Vector3 to, Nullable<Int32> index)>, LocalClassification) Trim the polygon with a collection of polygons that intersect it in 3d. Portions of the intersected polygon on the \"outside\" (normal-facing side) of the trimming polygons will remain. Portions inside the trimming polygons will be discarded. Declaration public List<Polygon> TrimmedTo(IList<Polygon> polygons, out List<Vector3> intersections, out List<(Vector3 from, Vector3 to, int? index)> trimEdges, LocalClassification inOut = LocalClassification.Outside) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The trimming polygons. System.Collections.Generic.List < Vector3 > intersections A collection of intersection locations. System.Collections.Generic.List < System.ValueTuple < Vector3 , Vector3 , System.Nullable < System.Int32 >>> trimEdges A collection of vertex pairs representing all edges in the timming graph. LocalClassification inOut A classification indicating which trim area should be returned. Returns Type Description System.Collections.Generic.List < Polygon > A collection of polygons resulting from the trim or null if no trim occurred. U(Double, Double, Double) Create a U. Declaration public static Polygon U(double width, double length, double thickness) Parameters Type Name Description System.Double width The width of the U. System.Double length The length of the U. System.Double thickness The thickness of the U. Returns Type Description Polygon A U shaped polygon with the origin at the center of the inside bend of the U. Union(Polygon, Double) Constructs the geometric union between this Polygon and the supplied Polygon. Declaration public Polygon Union(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The Polygon to be combined with this Polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon Returns a single Polygon from a successful union. Returns null if a union cannot be performed on the two Polygons. Union(Polygon[]) Constructs the geometric union between this Polygon and one or more supplied polygons, using the default tolerance. Declaration public Polygon Union(params Polygon[] polygons) Parameters Type Name Description Polygon [] polygons The Polygons to be combined with this Polygon. Returns Type Description Polygon Returns a single Polygon from a successful union. Returns null if a union cannot be performed on the complete list of Polygons. Union(IList<Polygon>, IList<Polygon>, Double) Constructs the geometric union of two sets of polygons. Declaration [Obsolete(\"Please use UnionAll, which takes a single list of polygons.\")] public static IList<Polygon> Union(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the union of both sets of polygons. Union(IList<Polygon>, Double) Constructs the geometric union between this Polygon and the supplied list of Polygons. Declaration public Polygon Union(IList<Polygon> polygons, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The list of Polygons to be combined with this Polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon Returns a single Polygon from a successful union. Returns null if a union cannot be performed on the complete list of Polygons. UnionAll(Polygon[]) Constructs the geometric union of a set of polygons, using default tolerance. Declaration public static IList<Polygon> UnionAll(params Polygon[] polygons) Parameters Type Name Description Polygon [] polygons The polygons to union Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the union of all polygons. UnionAll(IList<Polygon>, Double) Constructs the geometric union of a set of polygons. Declaration public static IList<Polygon> UnionAll(IList<Polygon> polygons, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The polygons to union System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the union of all polygons. ValidateVertices() Validate that this Polygon's vertices are coplanar, clean up any duplicate vertices, and fix any overlapping edges. Declaration protected override void ValidateVertices() Overrides IndexedPolycurve.ValidateVertices() XOR(Polygon, Double) Returns Polygons representing the symmetric difference between this Polygon and the supplied Polygon. Declaration public IList<Polygon> XOR(Polygon polygon, double tolerance = 1E-05) Parameters Type Name Description Polygon polygon The intersecting polygon. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the symmetric difference of this Polygon and the supplied Polygon. Returns a representation of this Polygon and the supplied Polygon if the Polygons do not intersect. XOR(IList<Polygon>, IList<Polygon>, Double) Returns Polygons representing the symmetric difference between two sets of polygons. Declaration public static IList<Polygon> XOR(IList<Polygon> firstSet, IList<Polygon> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Polygon > firstSet First set of polygons System.Collections.Generic.IList < Polygon > secondSet Second set of polygons System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.IList < Polygon > Returns a list of Polygons representing the symmetric difference of these two sets of polygons. Returns a representation of all polygons if they do not intersect. Operators Implicit(Polygon to Element) Implicitly convert a Polygon to a ModelCurve Element. Declaration public static implicit operator Element(Polygon c) Parameters Type Name Description Polygon c The curve to convert. Returns Type Description Element Implicit(Polygon to Profile) Implicitly convert a polygon to a profile. Declaration public static implicit operator Profile(Polygon p) Parameters Type Name Description Polygon p The polygon to convert. Returns Type Description Profile Implements ICurve ITransformable<T> IBoundedCurve System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable System.IEquatable<T>"
  },
  "api/Elements.Geometry.Polyline.html": {
    "href": "api/Elements.Geometry.Polyline.html",
    "title": "Class Polyline | Hypar Docs",
    "keywords": "Class Polyline A continuous set of lines. Parameterization of the curve is 0->n-1 where n is the number of vertices. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Polyline.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(); var b = new Vector3(10, 10); var c = new Vector3(20, 5); var d = new Vector3(25, 10); var pline = new Polyline(new[] { a, b, c, d }); var offset = pline.Offset(1, EndType.Square); Inheritance System.Object Curve BoundedCurve IndexedPolycurve Polyline Polygon Implements ICurve ITransformable < Curve > IBoundedCurve System.Collections.Generic.IEnumerable < BoundedCurve > System.Collections.IEnumerable System.IEquatable < IndexedPolycurve > Inherited Members IndexedPolycurve.Start IndexedPolycurve.End IndexedPolycurve.CurveIndices IndexedPolycurve.Vertices IndexedPolycurve.Bounds() IndexedPolycurve.GetSubdivisionParameters(Double, Double) IndexedPolycurve.ArcLength(Double, Double) IndexedPolycurve.ParameterAtDistanceFromParameter(Double, Double) IndexedPolycurve.PointAt(Double) IndexedPolycurve.PointAtInternal(Double, Int32) IndexedPolycurve.TransformedPolycurve(Transform) IndexedPolycurve.Equals(IndexedPolycurve) IndexedPolycurve.ToString() IndexedPolycurve.ToPolygon() IndexedPolycurve.ValidateVertices() IndexedPolycurve.CheckCoincidenceAndThrow(IList<Vector3>) IndexedPolycurve.GetEnumerator() IndexedPolycurve.IEnumerable.GetEnumerator() BoundedCurve.DefaultMinimumChordLength BoundedCurve.Mid() BoundedCurve.IsClosedForRendering BoundedCurve.ToPolyline(Int32) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Polyline : IndexedPolycurve, ICurve, ITransformable<Curve>, IBoundedCurve, IEnumerable<BoundedCurve>, IEnumerable, IEquatable<IndexedPolycurve> Constructors Polyline(Vector3[]) Construct a polyline from points. This is a convenience constructor that can be used like this: new Polyline((0,0,0), (10,0,0), (10,10,0)) Declaration public Polyline(params Vector3[] vertices) Parameters Type Name Description Vector3 [] vertices The vertices of the polyline. Polyline(Boolean, Vector3[]) Construct a polyline from points. This is a convenience constructor that can be used like this: new Polyline((0,0,0), (10,0,0), (10,10,0)) Declaration public Polyline(bool disableValidation, params Vector3[] vertices) Parameters Type Name Description System.Boolean disableValidation Should self intersection testing be disabled? Vector3 [] vertices The vertices of the polyline. Polyline(IList<Vector3>) Construct a polyline. Declaration [JsonConstructor] public Polyline(IList<Vector3> vertices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices A collection of vertex locations. Polyline(IList<Vector3>, Boolean) Construct a polyline. Declaration public Polyline(IList<Vector3> vertices, bool disableValidation = false) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices A collection of vertex locations. System.Boolean disableValidation Should self intersection testing be disabled? Properties Domain The domain of the curve. Declaration [JsonIgnore] public override Domain1d Domain { get; } Property Value Type Description Domain1d Overrides IndexedPolycurve.Domain Methods CreateMiterTransform(Int32, Vector3, Vector3) Generates a transform that expresses the plane of a miter join at a point on the curve. Declaration protected Transform CreateMiterTransform(int i, Vector3 a, Vector3 up) Parameters Type Name Description System.Int32 i Vector3 a Vector3 up Returns Type Description Transform Fillet(Double) Fillet all corners on this polygon. Declaration public IndexedPolycurve Fillet(double radius) Parameters Type Name Description System.Double radius The fillet radius. Returns Type Description IndexedPolycurve A contour containing trimmed edge segments and fillets. ForceAngleCompliance(IEnumerable<Double>, Vector3, NormalizationType) Make the polyline correspond to the supported angles by moving the vertices slightly. The result polyline will have only allowed angles, but vertices positions can be changed. Declaration public Polyline ForceAngleCompliance(IEnumerable<double> supportedAngles, Vector3 referenceVector, NormalizationType pathType = NormalizationType.Start) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > supportedAngles List of supported angles that the returned polyline can have. Supported angles must be between 0 and 90. Vector3 referenceVector Vector to align first segment of polyline with. NormalizationType pathType The path type. For each 3 consecutive points A, B, C to make angle ABC be one of allowed angles: NormalizationType.Start: move B vertex NormalizationType.Middle: move both B and C vertices in approximately equivalent proportions NormalizationType.End : move C vertex Returns Type Description Polyline The result polyline that has only allowed angles. ForceAngleCompliance(IEnumerable<Double>, Vector3, out Double, NormalizationType) Make the polyline correspond to the supported angles by moving the vertices slightly. The result polyline will have only allowed angles, but vertices positions can be changed. The first vertex is never moved. Declaration public Polyline ForceAngleCompliance(IEnumerable<double> supportedAngles, Vector3 referenceVector, out double furthestDistancePointsMoved, NormalizationType pathType = NormalizationType.Start) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > supportedAngles List of supported angles that the returned polyline can have. Supported angles must be between 0 and 90. Vector3 referenceVector Vector to align first segment of polyline with. System.Double furthestDistancePointsMoved The furthest distance that any point moved. NormalizationType pathType The path type. For each 3 consecutive points A, B, C to make angle ABC be one of allowed angles: NormalizationType.Start: move B vertex NormalizationType.Middle: move both B and C vertices in approximately equivalent proportions NormalizationType.End : move C vertex Returns Type Description Polyline The result polyline that has only allowed angles. Frames(Double, Double, Double) Get a collection of Transforms which represent frames along this curve. Declaration public override Transform[] Frames(double startSetbackDistance = 0, double endSetbackDistance = 0, double additionalRotation = 0) Parameters Type Name Description System.Double startSetbackDistance The offset from the start of the ICurve. System.Double endSetbackDistance The offset from the end of the ICurve. System.Double additionalRotation An additional rotation of the frame at each point. Returns Type Description Transform [] A collection of Transforms. Overrides BoundedCurve.Frames(Double, Double, Double) GetParameterAt(Vector3) Find the parameter corresponding to a point along a polyline. Declaration public double GetParameterAt(Vector3 point) Parameters Type Name Description Vector3 point A point. Returns Type Description System.Double A parameter for the point along a polyline if the point is on the polyline. Otherwise, -1. GetSubsegment(Vector3, Vector3) Get new polyline between two points Declaration public Polyline GetSubsegment(Vector3 start, Vector3 end) Parameters Type Name Description Vector3 start Start point Vector3 end End point Returns Type Description Polyline New polyline or null if any of points is not on polyline Intersects(Line, out List<Vector3>, Boolean, Boolean) Check if polyline intersects with line Declaration public bool Intersects(Line line, out List<Vector3> intersections, bool infinite = false, bool includeEnds = false) Parameters Type Name Description Line line Line to check System.Collections.Generic.List < Vector3 > intersections Intersections between polyline and line System.Boolean infinite Threat the line as infinite? System.Boolean includeEnds If the end of line lies exactly on the vertex of polyline, count it as an intersection? Returns Type Description System.Boolean True if line intersects with polyline, false if they do not intersect Intersects(Polygon, out List<Polyline>) Checks if polyline intersects with polygon Declaration public bool Intersects(Polygon polygon, out List<Polyline> sharedSegments) Parameters Type Name Description Polygon polygon Polygon to check System.Collections.Generic.List < Polyline > sharedSegments List of shared subsegments Returns Type Description System.Boolean Result of check if polyline and polygon intersects Length() Calculate the length of the polygon. Declaration public override double Length() Returns Type Description System.Double Overrides IndexedPolycurve.Length() NormalsAtVertices() Get the normal of each vertex on the polyline. Declaration protected virtual Vector3[] NormalsAtVertices() Returns Type Description Vector3 [] A collection of unit vectors, each corresponding to a single vertex. Offset(Double, EndType, Double) Offset this polyline by the specified amount. Declaration public virtual Polygon[] Offset(double offset, EndType endType, double tolerance = 1E-05) Parameters Type Name Description System.Double offset The amount to offset. EndType endType The closure type to use on the offset polygon. System.Double tolerance An optional tolerance. Returns Type Description Polygon [] A new closed Polygon offset in all directions by offset from the polyline. OffsetOnSide(Double, Boolean) Offset this polyline by the specified amount, only on one side. Declaration public Polygon[] OffsetOnSide(double offset, bool flip) Parameters Type Name Description System.Double offset The amount to offset. System.Boolean flip Offset on the opposite of the default side. The default is to draw on the +X side of a polyline that goes up the +Y axis. Returns Type Description Polygon [] An array of polygons that are extruded from each segment of the polyline. Remarks This blunts sharp corners to keep widths close to the target. OffsetOpen(Double) A nave control-point-only 2D open offset. This algorithm does not do any self-intersection checking. Declaration public Polyline OffsetOpen(double offset) Parameters Type Name Description System.Double offset The offset distance. Returns Type Description Polyline A new polyline with the same number of control points. OffsetWithAcuteAngle(Double) Offset this polyline by the specified amount. The resulting polygon will have acute angles. Declaration public Polygon[] OffsetWithAcuteAngle(double offset) Parameters Type Name Description System.Double offset The amount to offset. Returns Type Description Polygon [] Remarks This blunts sharp corners to keep widths close to the target. Plane() Compute the Plane defined by the first three non-collinear vertices of the Polygon. Declaration public virtual Plane Plane() Returns Type Description Plane A Plane. Project(Plane) Project this polyline onto the plane. Declaration public Polyline Project(Plane plane) Parameters Type Name Description Plane plane The plane of the returned polyline. Returns Type Description Polyline Reversed() Reverse the direction of a polyline. Declaration public Polyline Reversed() Returns Type Description Polyline Returns a new polyline with opposite winding. Segments() Get a collection a line segments which connect the vertices of this polyline. Declaration public virtual Line[] Segments() Returns Type Description Line [] A collection of Lines. SharedSegments(Polyline, Polyline, Boolean) Identify any shared segments between two polylines. Declaration public static List<(int indexOnA, int indexOnB)> SharedSegments(Polyline a, Polyline b, bool isClosed = false) Parameters Type Name Description Polyline a The first polyline to compare. Polyline b The second polyline to compare. System.Boolean isClosed Flag as closed to include segment between first and last vertex. Returns Type Description System.Collections.Generic.List < System.ValueTuple < System.Int32 , System.Int32 >> Returns a list of tuples of indices for the segments that match in each polyline. Split(IList<Vector3>) Insert a point into the polyline if it lies along one of the polyline's segments. Declaration public virtual void Split(IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points at which to split the polyline. Split(IList<Vector3>, Boolean) Insert a point into the polyline if it lies along one of the polyline's segments. Declaration protected void Split(IList<Vector3> points, bool closed = false) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points at which to split the polyline. System.Boolean closed Is the polyline closed? TransformAt(Double) Get the transform at the specified parameter along the polyline. Declaration public override Transform TransformAt(double u) Parameters Type Name Description System.Double u The parameter on the polygon between 0.0 and length. Returns Type Description Transform A transform with its Z axis aligned trangent to the polyline. Overrides IndexedPolycurve.TransformAt(Double) Transformed(Transform) Create a transformed copy of this curve. Use of non-affine transforms (i.e. scale) will result in unpredictable results for curve methods such as Length(). Declaration public override Curve Transformed(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Curve Overrides IndexedPolycurve.Transformed(Transform) TransformedPolyline(Transform) Construct a transformed copy of this Polyline. Declaration public Polyline TransformedPolyline(Transform transform) Parameters Type Name Description Transform transform The transform to apply. Returns Type Description Polyline TransformSegment(Transform, Int32, Boolean, Boolean) Transform a specified segment of this polyline in place. Declaration public void TransformSegment(Transform t, int i, bool isClosed = false, bool isPlanar = false) Parameters Type Name Description Transform t The transform. If it is not within the polygon plane, then an exception will be thrown. System.Int32 i The segment to transform. If it does not exist, then no work will be done. System.Boolean isClosed If set to true, the segment between the start end end point will be considered a valid target. System.Boolean isPlanar If set to true, an exception will be thrown if the resultant shape is no longer planar. Implements ICurve ITransformable<T> IBoundedCurve System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable System.IEquatable<T>"
  },
  "api/Elements.Geometry.Profile.html": {
    "href": "api/Elements.Geometry.Profile.html",
    "title": "Class Profile | Hypar Docs",
    "keywords": "Class Profile A polygonal perimeter with zero or more polygonal voids. Inheritance System.Object Element Profile HSSPipeProfile ParametricProfile RHSProfile WideFlangeProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Profile : Element, INotifyPropertyChanged, IEquatable<Profile> Constructors Profile(Polygon) Construct a profile. Declaration public Profile(Polygon perimeter) Parameters Type Name Description Polygon perimeter The perimeter of the profile. Profile(Polygon, Polygon) Construct a profile. Declaration public Profile(Polygon perimeter, Polygon void) Parameters Type Name Description Polygon perimeter The perimeter of the profile. Polygon void A void in the profile. Profile(Polygon, IList<Polygon>, Guid, String) Create a profile. Declaration [JsonConstructor] public Profile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The perimeter of the profile. System.Collections.Generic.IList < Polygon > voids A collection of voids in the profile. System.Guid id The id of the profile. System.String name The name of the profile. Profile(IList<Polygon>) Construct a profile from a collection of polygons. If the collection contains more than one polygon, the first polygon will be used as the perimeter and any remaining polygons will be used as voids. Declaration public Profile(IList<Polygon> polygons) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The polygons bounding this profile. Profile(String) Default constructor for profile. Declaration protected Profile(string name) Parameters Type Name Description System.String name Properties Perimeter The perimeter of the profile. Declaration [JsonProperty(\"Perimeter\", Required = Required.AllowNull)] public Polygon Perimeter { get; set; } Property Value Type Description Polygon Voids A collection of Polygons representing voids in the profile. Declaration [JsonProperty(\"Voids\", Required = Required.AllowNull)] public IList<Polygon> Voids { get; set; } Property Value Type Description System.Collections.Generic.IList < Polygon > Methods Area() The area of the profile. Declaration public double Area() Returns Type Description System.Double Contains(Vector3) Tests if a point is contained within this profile. Returns false for points that are outside of the profile, within voids, or coincident at edges or vertices. Declaration public bool Contains(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Boolean Contains(Vector3, out Containment) Tests if a point is contained within this profile. Returns false for points that are outside of the profile (or within voids). Declaration public bool Contains(Vector3 point, out Containment containment) Parameters Type Name Description Vector3 point The position to test. Containment containment Whether the point is inside, outside, at an edge, or at a vertex. Returns Type Description System.Boolean True if the point is within the profile. CreateFromPolygons(IEnumerable<Polygon>, Double) Create a collection of profiles from a collection of polygons. Inner polygons will be treated as voids in alternating fashion. Declaration public static List<Profile> CreateFromPolygons(IEnumerable<Polygon> polygons, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Polygon > polygons The polygons to sort into profiles System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Perform a difference operation on two sets of profiles. Declaration public static List<Profile> Difference(IEnumerable<Profile> firstSet, IEnumerable<Profile> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > firstSet The profiles to subtract from. System.Collections.Generic.IEnumerable < Profile > secondSet The profiles to subtract with. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > A new list of profiles comprising the first set minus the second set. Equals(Profile) Is this profile equal to the provided profile? Declaration public bool Equals(Profile other) Parameters Type Name Description Profile other The other profile. Returns Type Description System.Boolean Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Constructs the intersections between two sets of profiles. Declaration public static List<Profile> Intersection(IEnumerable<Profile> firstSet, IEnumerable<Profile> secondSet, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > firstSet The first set of profiles to intersect with. System.Collections.Generic.IEnumerable < Profile > secondSet The second set of profiles to intersect with. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > A new list of profiles comprising the overlap between the first set and the second set. Offset(IEnumerable<Profile>, Double, Double) Offset profiles by a given distance. Declaration public static List<Profile> Offset(IEnumerable<Profile> profiles, double distance, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > profiles The profiles to offset. System.Double distance The offset distance. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > A collection of resulting profiles. Offset(Double, Double) Offset this profile by a given distance. Declaration public List<Profile> Offset(double distance, double tolerance = 1E-05) Parameters Type Name Description System.Double distance The offset distance. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > OrientVoids() Ensure that voids run in an opposite winding direction to the perimeter of the profile. Be sure to call this if you modify the Profile's Voids array directly. Declaration public void OrientVoids() Project(Plane) Project this profile onto the plane. Declaration public Profile Project(Plane plane) Parameters Type Name Description Plane plane The plane of the returned profile. Returns Type Description Profile Reversed() Get a new profile which is the reverse of this profile. Declaration public Profile Reversed() Returns Type Description Profile Scale(Double) Return a new profile that is this profile scaled about the origin by the desired amount. Declaration public Profile Scale(double amount) Parameters Type Name Description System.Double amount Returns Type Description Profile Segments() Get all segments from a profile's perimeter and internal voids. Declaration public List<Line> Segments() Returns Type Description System.Collections.Generic.List < Line > Split(IEnumerable<Profile>, Polyline, Double) Split a set of profiles with a collection of open polylines. Declaration public static List<Profile> Split(IEnumerable<Profile> profiles, Polyline splitLine, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > profiles The profiles to split Polyline splitLine The polyline defining the splits. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Split a set of profiles with a collection of open polylines. Declaration public static List<Profile> Split(IEnumerable<Profile> profiles, IEnumerable<Polyline> splitLines, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > profiles The profiles to split System.Collections.Generic.IEnumerable < Polyline > splitLines The polylines defining the splits. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > Transform(Transform) Transform this profile in place. Declaration public void Transform(Transform t) Parameters Type Name Description Transform t The transform. Transformed(Transform) A transformed copy of this profile. Declaration public Profile Transformed(Transform transform) Parameters Type Name Description Transform transform The transform. Returns Type Description Profile Union(Profile, Double) Perform a union operation, returning a new profile that is the union of the current profile with the other profile The profile with which to create a union. An optional tolerance. Declaration public Profile Union(Profile profile, double tolerance = 1E-05) Parameters Type Name Description Profile profile System.Double tolerance Returns Type Description Profile UnionAll(IEnumerable<Profile>, Double) Perform a union operation on a set of multiple profiles. Declaration public static List<Profile> UnionAll(IEnumerable<Profile> profiles, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > profiles The profiles with which to create a union. System.Double tolerance An optional tolerance. Returns Type Description System.Collections.Generic.List < Profile > A new list of profiles comprising the union of all input profiles. Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.ProfileExtensions.html": {
    "href": "api/Elements.Geometry.ProfileExtensions.html",
    "title": "Class ProfileExtensions | Hypar Docs",
    "keywords": "Class ProfileExtensions Profile extension methods. Inheritance System.Object ProfileExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class ProfileExtensions Methods Cleaned(IEnumerable<Profile>, Double) For a given collection of profiles, make sure vertices within tolerance of each other are at the same location. This is especially useful for profiles that need to be edited in the Hypar interface via an override.  Note: this is not a highly precise routine, and the shapes of the input profiles may be slightly distorted as a result. Declaration public static List<Profile> Cleaned(this IEnumerable<Profile> profiles, double tolerance = 0.01) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > profiles The profiles to clean. System.Double tolerance Below this distance, similar points will be merged. Returns Type Description System.Collections.Generic.List < Profile > A cleaned list of profiles. PropagateAdditionalProperties(IEnumerable<Profile>, Profile) Copy the \"additional properties\" metadata from one profile to another set of profiles. Declaration public static void PropagateAdditionalProperties(this IEnumerable<Profile> profiles, Profile source) Parameters Type Name Description System.Collections.Generic.IEnumerable < Profile > profiles The target profiles receiving the new data. Profile source The source profiles from which the additional properties will be copied."
  },
  "api/Elements.Geometry.Profiles.CProfile.html": {
    "href": "api/Elements.Geometry.Profiles.CProfile.html",
    "title": "Class CProfile | Hypar Docs",
    "keywords": "Class CProfile Inheritance System.Object Element Profile ParametricProfile CProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members ParametricProfile.PerimeterVectorExpressions ParametricProfile.VoidVectorExpressions ParametricProfile.SetGeometryAsync() ParametricProfile.SetPropertiesFromProfileData(Dictionary<String, Double>, String) Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class CProfile : ParametricProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors CProfile() Declaration public CProfile() CProfile(Polygon, IList<Polygon>, Guid, String) Declaration [JsonConstructor] public CProfile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Fields A Declaration public double A Field Value Type Description System.Double b_t Declaration public double b_t Field Value Type Description System.Double bf Declaration public double bf Field Value Type Description System.Double bfdet Declaration public double bfdet Field Value Type Description System.Double Cw Declaration public double Cw Field Value Type Description System.Double d Declaration public double d Field Value Type Description System.Double ddet Declaration public double ddet Field Value Type Description System.Double eo Declaration public double eo Field Value Type Description System.Double H Declaration public double H Field Value Type Description System.Double h_tw Declaration public double h_tw Field Value Type Description System.Double ho Declaration public double ho Field Value Type Description System.Double Ix Declaration public double Ix Field Value Type Description System.Double Iy Declaration public double Iy Field Value Type Description System.Double J Declaration public double J Field Value Type Description System.Double kdes Declaration public double kdes Field Value Type Description System.Double kdet Declaration public double kdet Field Value Type Description System.Double PA Declaration public double PA Field Value Type Description System.Double PA2 Declaration public double PA2 Field Value Type Description System.Double PB Declaration public double PB Field Value Type Description System.Double PC Declaration public double PC Field Value Type Description System.Double PD Declaration public double PD Field Value Type Description System.Double Qf Declaration public double Qf Field Value Type Description System.Double Qw Declaration public double Qw Field Value Type Description System.Double ro Declaration public double ro Field Value Type Description System.Double rts Declaration public double rts Field Value Type Description System.Double rx Declaration public double rx Field Value Type Description System.Double ry Declaration public double ry Field Value Type Description System.Double Sw1 Declaration public double Sw1 Field Value Type Description System.Double Sw2 Declaration public double Sw2 Field Value Type Description System.Double Sw3 Declaration public double Sw3 Field Value Type Description System.Double Sx Declaration public double Sx Field Value Type Description System.Double Sy Declaration public double Sy Field Value Type Description System.Double T Declaration public double T Field Value Type Description System.Double tf Declaration public double tf Field Value Type Description System.Double tfdet Declaration public double tfdet Field Value Type Description System.Double tw Declaration public double tw Field Value Type Description System.Double twdet Declaration public double twdet Field Value Type Description System.Double twdet_2 Declaration public double twdet_2 Field Value Type Description System.Double W Declaration public double W Field Value Type Description System.Double WGi Declaration public double WGi Field Value Type Description System.Double Wno Declaration public double Wno Field Value Type Description System.Double x Declaration public double x Field Value Type Description System.Double xp Declaration public double xp Field Value Type Description System.Double Zx Declaration public double Zx Field Value Type Description System.Double Zy Declaration public double Zy Field Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.CProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.CProfileFactory.html",
    "title": "Class CProfileFactory | Hypar Docs",
    "keywords": "Class CProfileFactory A factory for creation C profiles. Inheritance System.Object ParametricProfileFactory < CProfileType , CProfile > CProfileFactory Inherited Members ParametricProfileFactory<CProfileType, CProfile>.AllProfilesAsync() ParametricProfileFactory<CProfileType, CProfile>.GetProfileByNameAsync(String) ParametricProfileFactory<CProfileType, CProfile>.GetProfileByTypeAsync(CProfileType) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class CProfileFactory : ParametricProfileFactory<CProfileType, CProfile> Constructors CProfileFactory() Create an C profile factory. Declaration public CProfileFactory()"
  },
  "api/Elements.Geometry.Profiles.CProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.CProfileType.html",
    "title": "Enum CProfileType | Hypar Docs",
    "keywords": "Enum CProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum CProfileType Fields Name Description C10X15_3 C10X20 C10X25 C10X30 C12X20_7 C12X25 C12X30 C15X33_9 C15X40 C15X50 C3X3_5 C3X4_1 C3X5 C3X6 C4X4_5 C4X5_4 C4X6_25 C4X7_25 C5X6_7 C5X9 C6X10_5 C6X13 C6X8_2 C7X12_25 C7X14_75 C7X9_8 C8X11_5 C8X13_75 C8X18_75 C9X13_4 C9X15 C9X20"
  },
  "api/Elements.Geometry.Profiles.HorizontalAlignment.html": {
    "href": "api/Elements.Geometry.Profiles.HorizontalAlignment.html",
    "title": "Enum HorizontalAlignment | Hypar Docs",
    "keywords": "Enum HorizontalAlignment The horizontal alignment of a profile. Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum HorizontalAlignment Fields Name Description Center Align the profile along its center. Left Align the profile along its left edge. Right Align the profile along its right edge."
  },
  "api/Elements.Geometry.Profiles.HSSPipeProfile.html": {
    "href": "api/Elements.Geometry.Profiles.HSSPipeProfile.html",
    "title": "Class HSSPipeProfile | Hypar Docs",
    "keywords": "Class HSSPipeProfile A hollow structural steel profile. Inheritance System.Object Element Profile HSSPipeProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class HSSPipeProfile : Profile, INotifyPropertyChanged, IEquatable<Profile> Constructors HSSPipeProfile(String, Guid, Double, Double, Double) Construct a hollow structural steel profile. Declaration [JsonConstructor] public HSSPipeProfile(string name, Guid id, double outerDiam, double innerDiam, double t) Parameters Type Name Description System.String name System.Guid id System.Double outerDiam System.Double innerDiam System.Double t Properties A Declaration [JsonIgnore] public double A { get; } Property Value Type Description System.Double I Declaration [JsonIgnore] public double I { get; } Property Value Type Description System.Double InnerDiam Declaration public double InnerDiam { get; } Property Value Type Description System.Double J Declaration [JsonIgnore] public double J { get; } Property Value Type Description System.Double OuterDiam Declaration public double OuterDiam { get; } Property Value Type Description System.Double r Declaration [JsonIgnore] public double r { get; } Property Value Type Description System.Double S Declaration [JsonIgnore] public double S { get; } Property Value Type Description System.Double t Declaration public double t { get; } Property Value Type Description System.Double wt Declaration [JsonIgnore] public double wt { get; } Property Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.HSSPipeProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.HSSPipeProfileFactory.html",
    "title": "Class HSSPipeProfileFactory | Hypar Docs",
    "keywords": "Class HSSPipeProfileFactory A singleton class which serves every HSS pipe section as defined by AISC. Inheritance System.Object ProfileFactoryBase < HSSPipeProfileType , HSSPipeProfile > HSSPipeProfileFactory Inherited Members ProfileFactoryBase<HSSPipeProfileType, HSSPipeProfile>._profileData ProfileFactoryBase<HSSPipeProfileType, HSSPipeProfile>.GetProfileByName(String) ProfileFactoryBase<HSSPipeProfileType, HSSPipeProfile>.GetProfileByType(HSSPipeProfileType) ProfileFactoryBase<HSSPipeProfileType, HSSPipeProfile>.AllProfiles() ProfileFactoryBase<HSSPipeProfileType, HSSPipeProfile>.CreateProfile(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public sealed class HSSPipeProfileFactory : ProfileFactoryBase<HSSPipeProfileType, HSSPipeProfile> Constructors HSSPipeProfileFactory() Construct a hollow structural steel profile factory. Declaration public HSSPipeProfileFactory() Methods CreateProfile(Int32) Declaration protected override HSSPipeProfile CreateProfile(int typeIndex) Parameters Type Name Description System.Int32 typeIndex Returns Type Description HSSPipeProfile Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.HSSPipeProfileType, Elements.Geometry.Profiles.HSSPipeProfile>.CreateProfile(System.Int32) GetProfileByName(String) Get a profile by name. Declaration public override HSSPipeProfile GetProfileByName(string name) Parameters Type Name Description System.String name The name of the profile. Returns Type Description HSSPipeProfile A hollow structural steel profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.HSSPipeProfileType, Elements.Geometry.Profiles.HSSPipeProfile>.GetProfileByName(System.String) GetProfileByType(HSSPipeProfileType) Get a profile by type. Declaration public override HSSPipeProfile GetProfileByType(HSSPipeProfileType type) Parameters Type Name Description HSSPipeProfileType type The type of the profile. Returns Type Description HSSPipeProfile A hollow structural steel profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.HSSPipeProfileType, Elements.Geometry.Profiles.HSSPipeProfile>.GetProfileByType(Elements.Geometry.Profiles.HSSPipeProfileType)"
  },
  "api/Elements.Geometry.Profiles.HSSPipeProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.HSSPipeProfileType.html",
    "title": "Enum HSSPipeProfileType | Hypar Docs",
    "keywords": "Enum HSSPipeProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum HSSPipeProfileType Fields Name Description HSS1_660x0_140 HSS1_900x0_145 HSS10_000x0_188 HSS10_000x0_250 HSS10_000x0_312 HSS10_000x0_375 HSS10_000x0_500 HSS10_000x0_625 HSS10_750x0_250 HSS10_750x0_500 HSS11_250x0_188 HSS11_250x0_250 HSS11_250x0_312 HSS11_250x0_375 HSS11_250x0_500 HSS11_250x0_625 HSS12_500x0_188 HSS12_500x0_250 HSS12_500x0_312 HSS12_500x0_375 HSS12_500x0_500 HSS12_500x0_625 HSS12_750x0_250 HSS12_750x0_375 HSS12_750x0_500 HSS14_000x0_312 HSS14_000x0_375 HSS14_000x0_500 HSS16_000x0_312 HSS16_000x0_375 HSS16_000x0_438 HSS16_000x0_500 HSS18_000x0_375 HSS18_000x0_500 HSS2_375x0_125 HSS2_375x0_154 HSS2_375x0_188 HSS2_375x0_218 HSS2_375x0_250 HSS2_500x0_125 HSS2_500x0_188 HSS2_500x0_250 HSS2_875x0_125 HSS2_875x0_188 HSS2_875x0_203 HSS2_875x0_250 HSS20_000x0_375 HSS20_000x0_500 HSS3_000x0_120 HSS3_000x0_134 HSS3_000x0_152 HSS3_000x0_188 HSS3_000x0_203 HSS3_000x0_216 HSS3_000x0_250 HSS3_000x0_300 HSS3_500x0_125 HSS3_500x0_188 HSS3_500x0_203 HSS3_500x0_216 HSS3_500x0_250 HSS3_500x0_300 HSS3_500x0_313 HSS4_000x0_125 HSS4_000x0_188 HSS4_000x0_220 HSS4_000x0_226 HSS4_000x0_237 HSS4_000x0_250 HSS4_000x0_313 HSS4_000x0_337 HSS4_500x0_125 HSS4_500x0_188 HSS4_500x0_237 HSS4_500x0_337 HSS5_000x0_125 HSS5_000x0_188 HSS5_000x0_250 HSS5_000x0_258 HSS5_000x0_312 HSS5_000x0_375 HSS5_000x0_500 HSS5_500x0_258 HSS5_500x0_375 HSS5_500x0_500 HSS5_563x0_134 HSS5_563x0_188 HSS5_563x0_258 HSS5_563x0_375 HSS6_000x0_125 HSS6_000x0_188 HSS6_000x0_250 HSS6_000x0_280 HSS6_000x0_312 HSS6_000x0_375 HSS6_000x0_500 HSS6_125x0_188 HSS6_125x0_250 HSS6_125x0_312 HSS6_125x0_375 HSS6_125x0_500 HSS6_625x0_125 HSS6_625x0_188 HSS6_625x0_250 HSS6_625x0_280 HSS6_625x0_312 HSS6_625x0_375 HSS6_625x0_432 HSS6_625x0_500 HSS6_875x0_188 HSS6_875x0_250 HSS6_875x0_312 HSS6_875x0_375 HSS6_875x0_500 HSS7_000x0_125 HSS7_000x0_188 HSS7_000x0_250 HSS7_000x0_312 HSS7_000x0_375 HSS7_000x0_500 HSS7_500x0_188 HSS7_500x0_250 HSS7_500x0_312 HSS7_500x0_375 HSS7_500x0_500 HSS7_625x0_125 HSS8_625x0_188 HSS8_625x0_250 HSS8_625x0_322 HSS8_625x0_375 HSS8_625x0_500 HSS8_750x0_188 HSS8_750x0_250 HSS8_750x0_312 HSS8_750x0_375 HSS8_750x0_500 HSS9_625x0_188 HSS9_625x0_250 HSS9_625x0_312 HSS9_625x0_375 HSS9_625x0_500"
  },
  "api/Elements.Geometry.Profiles.HSSProfile.html": {
    "href": "api/Elements.Geometry.Profiles.HSSProfile.html",
    "title": "Class HSSProfile | Hypar Docs",
    "keywords": "Class HSSProfile Inheritance System.Object Element Profile ParametricProfile HSSProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members ParametricProfile.PerimeterVectorExpressions ParametricProfile.VoidVectorExpressions ParametricProfile.SetGeometryAsync() ParametricProfile.SetPropertiesFromProfileData(Dictionary<String, Double>, String) Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class HSSProfile : ParametricProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors HSSProfile() Declaration public HSSProfile() HSSProfile(Polygon, IList<Polygon>, Guid, String) Declaration [JsonConstructor] public HSSProfile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Fields A Declaration public double A Field Value Type Description System.Double b Declaration public double b Field Value Type Description System.Double B Declaration public double B Field Value Type Description System.Double b_tdes Declaration public double b_tdes Field Value Type Description System.Double C Declaration public double C Field Value Type Description System.Double h Declaration public double h Field Value Type Description System.Double h_tdes Declaration public double h_tdes Field Value Type Description System.Double Ht Declaration public double Ht Field Value Type Description System.Double Ix Declaration public double Ix Field Value Type Description System.Double Iy Declaration public double Iy Field Value Type Description System.Double J Declaration public double J Field Value Type Description System.Double rx Declaration public double rx Field Value Type Description System.Double ry Declaration public double ry Field Value Type Description System.Double Sx Declaration public double Sx Field Value Type Description System.Double Sy Declaration public double Sy Field Value Type Description System.Double tdes Declaration public double tdes Field Value Type Description System.Double tnom Declaration public double tnom Field Value Type Description System.Double W Declaration public double W Field Value Type Description System.Double Zx Declaration public double Zx Field Value Type Description System.Double Zy Declaration public double Zy Field Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.HSSProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.HSSProfileFactory.html",
    "title": "Class HSSProfileFactory | Hypar Docs",
    "keywords": "Class HSSProfileFactory A factory for creation L profiles. Inheritance System.Object ParametricProfileFactory < HSSProfileType , HSSProfile > HSSProfileFactory Inherited Members ParametricProfileFactory<HSSProfileType, HSSProfile>.AllProfilesAsync() ParametricProfileFactory<HSSProfileType, HSSProfile>.GetProfileByNameAsync(String) ParametricProfileFactory<HSSProfileType, HSSProfile>.GetProfileByTypeAsync(HSSProfileType) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class HSSProfileFactory : ParametricProfileFactory<HSSProfileType, HSSProfile> Constructors HSSProfileFactory() Create an C profile factory. Declaration public HSSProfileFactory()"
  },
  "api/Elements.Geometry.Profiles.HSSProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.HSSProfileType.html",
    "title": "Enum HSSProfileType | Hypar Docs",
    "keywords": "Enum HSSProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum HSSProfileType Fields Name Description HSS10X10X1_2 HSS10X10X1_4 HSS10X10X3_16 HSS10X10X3_4 HSS10X10X3_8 HSS10X10X5_16 HSS10X10X5_8 HSS10X2X1_4 HSS10X2X1_8 HSS10X2X3_16 HSS10X2X3_8 HSS10X2X5_16 HSS10X3__1_2X1_2 HSS10X3__1_2X1_4 HSS10X3__1_2X1_8 HSS10X3__1_2X3_16 HSS10X3__1_2X3_8 HSS10X3__1_2X5_16 HSS10X3X1_4 HSS10X3X1_8 HSS10X3X3_16 HSS10X3X3_8 HSS10X3X5_16 HSS10X4X1_2 HSS10X4X1_4 HSS10X4X1_8 HSS10X4X3_16 HSS10X4X3_8 HSS10X4X5_16 HSS10X4X5_8 HSS10X5X1_4 HSS10X5X3_16 HSS10X5X3_8 HSS10X5X5_16 HSS10X6X1_2 HSS10X6X1_4 HSS10X6X3_16 HSS10X6X3_8 HSS10X6X5_16 HSS10X6X5_8 HSS10X8X1_2 HSS10X8X1_4 HSS10X8X3_16 HSS10X8X3_8 HSS10X8X5_16 HSS10X8X5_8 HSS12X10X1_2 HSS12X10X1_4 HSS12X10X3_8 HSS12X10X5_16 HSS12X12X1_2 HSS12X12X1_4 HSS12X12X3_16 HSS12X12X3_4 HSS12X12X3_8 HSS12X12X5_16 HSS12X12X5_8 HSS12X2X1_4 HSS12X2X3_16 HSS12X2X5_16 HSS12X3__1_2X3_8 HSS12X3__1_2X5_16 HSS12X3X1_4 HSS12X3X3_16 HSS12X3X5_16 HSS12X4X1_2 HSS12X4X1_4 HSS12X4X3_16 HSS12X4X3_8 HSS12X4X5_16 HSS12X4X5_8 HSS12X6X1_2 HSS12X6X1_4 HSS12X6X3_16 HSS12X6X3_8 HSS12X6X5_16 HSS12X6X5_8 HSS12X8X1_2 HSS12X8X1_4 HSS12X8X3_16 HSS12X8X3_8 HSS12X8X5_16 HSS12X8X5_8 HSS14X10X1_2 HSS14X10X1_4 HSS14X10X3_8 HSS14X10X5_16 HSS14X10X5_8 HSS14X14X1_2 HSS14X14X3_4 HSS14X14X3_8 HSS14X14X5_16 HSS14X14X5_8 HSS14X14X7_8 HSS14X4X1_2 HSS14X4X1_4 HSS14X4X3_16 HSS14X4X3_8 HSS14X4X5_16 HSS14X4X5_8 HSS14X6X1_2 HSS14X6X1_4 HSS14X6X3_16 HSS14X6X3_8 HSS14X6X5_16 HSS14X6X5_8 HSS16X12X1_2 HSS16X12X3_4 HSS16X12X3_8 HSS16X12X5_16 HSS16X12X5_8 HSS16X16X1_2 HSS16X16X3_4 HSS16X16X3_8 HSS16X16X5_16 HSS16X16X5_8 HSS16X16X7_8 HSS16X4X1_2 HSS16X4X1_4 HSS16X4X3_16 HSS16X4X3_8 HSS16X4X5_16 HSS16X4X5_8 HSS16X8X1_2 HSS16X8X1_4 HSS16X8X3_8 HSS16X8X5_16 HSS16X8X5_8 HSS18X18X1_2 HSS18X18X3_4 HSS18X18X5_8 HSS18X18X7_8 HSS18X6X1_2 HSS18X6X1_4 HSS18X6X3_8 HSS18X6X5_16 HSS18X6X5_8 HSS2__1_2X1__1_2X1_4 HSS2__1_2X1__1_2X1_8 HSS2__1_2X1__1_2X3_16 HSS2__1_2X1X1_8 HSS2__1_2X1X3_16 HSS2__1_2X2__1_2X1_4 HSS2__1_2X2__1_2X1_8 HSS2__1_2X2__1_2X3_16 HSS2__1_2X2__1_2X5_16 HSS2__1_2X2X1_4 HSS2__1_2X2X1_8 HSS2__1_2X2X3_16 HSS2__1_4X2__1_4X1_4 HSS2__1_4X2__1_4X1_8 HSS2__1_4X2__1_4X3_16 HSS2__1_4X2X1_8 HSS2__1_4X2X3_16 HSS20X12X1_2 HSS20X12X3_4 HSS20X12X3_8 HSS20X12X5_16 HSS20X12X5_8 HSS20X20X1_2 HSS20X20X3_4 HSS20X20X5_8 HSS20X20X7_8 HSS20X4X1_2 HSS20X4X1_4 HSS20X4X3_8 HSS20X4X5_16 HSS20X8X1_2 HSS20X8X3_8 HSS20X8X5_16 HSS20X8X5_8 HSS22X22X3_4 HSS22X22X7_8 HSS24X12X1_2 HSS24X12X3_4 HSS24X12X5_8 HSS2X1__1_2X1_8 HSS2X1__1_2X3_16 HSS2X1X1_8 HSS2X1X3_16 HSS2X2X1_4 HSS2X2X1_8 HSS2X2X3_16 HSS3__1_2X1__1_2X1_4 HSS3__1_2X1__1_2X1_8 HSS3__1_2X1__1_2X3_16 HSS3__1_2X2__1_2X1_4 HSS3__1_2X2__1_2X1_8 HSS3__1_2X2__1_2X3_16 HSS3__1_2X2__1_2X3_8 HSS3__1_2X2__1_2X5_16 HSS3__1_2X2X1_4 HSS3__1_2X2X1_8 HSS3__1_2X2X3_16 HSS3__1_2X3__1_2X1_4 HSS3__1_2X3__1_2X1_8 HSS3__1_2X3__1_2X3_16 HSS3__1_2X3__1_2X3_8 HSS3__1_2X3__1_2X5_16 HSS3X1__1_2X1_4 HSS3X1__1_2X1_8 HSS3X1__1_2X3_16 HSS3X1X1_8 HSS3X1X3_16 HSS3X2__1_2X1_4 HSS3X2__1_2X1_8 HSS3X2__1_2X3_16 HSS3X2__1_2X5_16 HSS3X2X1_4 HSS3X2X1_8 HSS3X2X3_16 HSS3X2X5_16 HSS3X3X1_4 HSS3X3X1_8 HSS3X3X3_16 HSS3X3X3_8 HSS3X3X5_16 HSS4__1_2X4__1_2X1_2 HSS4__1_2X4__1_2X1_4 HSS4__1_2X4__1_2X1_8 HSS4__1_2X4__1_2X3_16 HSS4__1_2X4__1_2X3_8 HSS4__1_2X4__1_2X5_16 HSS4X2__1_2X1_4 HSS4X2__1_2X1_8 HSS4X2__1_2X3_16 HSS4X2__1_2X3_8 HSS4X2__1_2X5_16 HSS4X2X1_4 HSS4X2X1_8 HSS4X2X3_16 HSS4X2X3_8 HSS4X2X5_16 HSS4X3X1_4 HSS4X3X1_8 HSS4X3X3_16 HSS4X3X3_8 HSS4X3X5_16 HSS4X4X1_2 HSS4X4X1_4 HSS4X4X1_8 HSS4X4X3_16 HSS4X4X3_8 HSS4X4X5_16 HSS5__1_2X5__1_2X1_4 HSS5__1_2X5__1_2X1_8 HSS5__1_2X5__1_2X3_16 HSS5__1_2X5__1_2X3_8 HSS5__1_2X5__1_2X5_16 HSS5X2__1_2X1_4 HSS5X2__1_2X1_8 HSS5X2__1_2X3_16 HSS5X2X1_4 HSS5X2X1_8 HSS5X2X3_16 HSS5X2X3_8 HSS5X2X5_16 HSS5X3X1_2 HSS5X3X1_4 HSS5X3X1_8 HSS5X3X3_16 HSS5X3X3_8 HSS5X3X5_16 HSS5X4X1_2 HSS5X4X1_4 HSS5X4X1_8 HSS5X4X3_16 HSS5X4X3_8 HSS5X4X5_16 HSS5X5X1_2 HSS5X5X1_4 HSS5X5X1_8 HSS5X5X3_16 HSS5X5X3_8 HSS5X5X5_16 HSS6X2X1_4 HSS6X2X1_8 HSS6X2X3_16 HSS6X2X3_8 HSS6X2X5_16 HSS6X3X1_2 HSS6X3X1_4 HSS6X3X1_8 HSS6X3X3_16 HSS6X3X3_8 HSS6X3X5_16 HSS6X4X1_2 HSS6X4X1_4 HSS6X4X1_8 HSS6X4X3_16 HSS6X4X3_8 HSS6X4X5_16 HSS6X5X1_2 HSS6X5X1_4 HSS6X5X1_8 HSS6X5X3_16 HSS6X5X3_8 HSS6X5X5_16 HSS6X6X1_2 HSS6X6X1_4 HSS6X6X1_8 HSS6X6X3_16 HSS6X6X3_8 HSS6X6X5_16 HSS6X6X5_8 HSS7X2X1_4 HSS7X2X1_8 HSS7X2X3_16 HSS7X3X1_2 HSS7X3X1_4 HSS7X3X1_8 HSS7X3X3_16 HSS7X3X3_8 HSS7X3X5_16 HSS7X4X1_2 HSS7X4X1_4 HSS7X4X1_8 HSS7X4X3_16 HSS7X4X3_8 HSS7X4X5_16 HSS7X5X1_2 HSS7X5X1_4 HSS7X5X1_8 HSS7X5X3_16 HSS7X5X3_8 HSS7X5X5_16 HSS7X7X1_2 HSS7X7X1_4 HSS7X7X1_8 HSS7X7X3_16 HSS7X7X3_8 HSS7X7X5_16 HSS7X7X5_8 HSS8X2X1_4 HSS8X2X1_8 HSS8X2X3_16 HSS8X2X3_8 HSS8X2X5_16 HSS8X3X1_2 HSS8X3X1_4 HSS8X3X1_8 HSS8X3X3_16 HSS8X3X3_8 HSS8X3X5_16 HSS8X4X1_2 HSS8X4X1_4 HSS8X4X1_8 HSS8X4X3_16 HSS8X4X3_8 HSS8X4X5_16 HSS8X4X5_8 HSS8X6X1_2 HSS8X6X1_4 HSS8X6X3_16 HSS8X6X3_8 HSS8X6X5_16 HSS8X6X5_8 HSS8X8X1_2 HSS8X8X1_4 HSS8X8X1_8 HSS8X8X3_16 HSS8X8X3_8 HSS8X8X5_16 HSS8X8X5_8 HSS9X3X1_2 HSS9X3X1_4 HSS9X3X3_16 HSS9X3X3_8 HSS9X3X5_16 HSS9X5X1_2 HSS9X5X1_4 HSS9X5X3_16 HSS9X5X3_8 HSS9X5X5_16 HSS9X5X5_8 HSS9X7X1_2 HSS9X7X1_4 HSS9X7X3_16 HSS9X7X3_8 HSS9X7X5_16 HSS9X7X5_8 HSS9X9X1_2 HSS9X9X1_4 HSS9X9X1_8 HSS9X9X3_16 HSS9X9X3_8 HSS9X9X5_16 HSS9X9X5_8"
  },
  "api/Elements.Geometry.Profiles.html": {
    "href": "api/Elements.Geometry.Profiles.html",
    "title": "Namespace Elements.Geometry.Profiles | Hypar Docs",
    "keywords": "Namespace Elements.Geometry.Profiles Classes CProfile CProfileFactory A factory for creation C profiles. HSSPipeProfile A hollow structural steel profile. HSSPipeProfileFactory A singleton class which serves every HSS pipe section as defined by AISC. HSSProfile HSSProfileFactory A factory for creation L profiles. LProfile LProfileFactory A factory for creation L profiles. MCProfile MCProfileFactory A factory for creation MC profiles. ParametricProfile A profile whose vertex locations are defined by a parametric expression. ParametricProfileFactory<TProfileType, TProfile> A profile factory which creates parametric profiles. ProfileFactoryBase<TProfileType, TProfile> Base class for profile factories. RHSProfile A rectangular hollow section profile. RHSProfileFactory A profile factory for rectangular hollow steel profiles. SHSProfile A square hollow section profile. SHSProfileFactory A singleton class which serves every HSS pipe section as defined by AISC. STProfile STProfileFactory A factory for creation L profiles. VectorExpression A collection of expressions describing the X, Y, and Z coordinates of a vertex. WideFlangeProfile A wide flange profile. WideFlangeProfileFactory A profile factory for wide flange profiles. WProfile WProfileFactory A factory for creation W profiles. WTProfile WTProfileFactory A factory for creation WT profiles. Enums CProfileType HorizontalAlignment The horizontal alignment of a profile. HSSPipeProfileType HSSProfileType LProfileType MCProfileType RHSProfileType SHSProfileType STProfileType VerticalAlignment The vertical alignment of a profile. WProfileType WTProfileType"
  },
  "api/Elements.Geometry.Profiles.LProfile.html": {
    "href": "api/Elements.Geometry.Profiles.LProfile.html",
    "title": "Class LProfile | Hypar Docs",
    "keywords": "Class LProfile Inheritance System.Object Element Profile ParametricProfile LProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members ParametricProfile.PerimeterVectorExpressions ParametricProfile.VoidVectorExpressions ParametricProfile.SetGeometryAsync() ParametricProfile.SetPropertiesFromProfileData(Dictionary<String, Double>, String) Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class LProfile : ParametricProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors LProfile() Declaration public LProfile() LProfile(Polygon, IList<Polygon>, Guid, String) Declaration [JsonConstructor] public LProfile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Fields A Declaration public double A Field Value Type Description System.Double b Declaration public double b Field Value Type Description System.Double b_t Declaration public double b_t Field Value Type Description System.Double Cw Declaration public double Cw Field Value Type Description System.Double d Declaration public double d Field Value Type Description System.Double H Declaration public double H Field Value Type Description System.Double Iw Declaration public double Iw Field Value Type Description System.Double Ix Declaration public double Ix Field Value Type Description System.Double Iy Declaration public double Iy Field Value Type Description System.Double Iz Declaration public double Iz Field Value Type Description System.Double J Declaration public double J Field Value Type Description System.Double kdes Declaration public double kdes Field Value Type Description System.Double kdet Declaration public double kdet Field Value Type Description System.Double PA Declaration public double PA Field Value Type Description System.Double PA2 Declaration public double PA2 Field Value Type Description System.Double PB Declaration public double PB Field Value Type Description System.Double ro Declaration public double ro Field Value Type Description System.Double rx Declaration public double rx Field Value Type Description System.Double ry Declaration public double ry Field Value Type Description System.Double rz Declaration public double rz Field Value Type Description System.Double SwA Declaration public double SwA Field Value Type Description System.Double SwB Declaration public double SwB Field Value Type Description System.Double SwC Declaration public double SwC Field Value Type Description System.Double Sx Declaration public double Sx Field Value Type Description System.Double Sy Declaration public double Sy Field Value Type Description System.Double Sz Declaration public double Sz Field Value Type Description System.Double SzA Declaration public double SzA Field Value Type Description System.Double SzB Declaration public double SzB Field Value Type Description System.Double SzC Declaration public double SzC Field Value Type Description System.Double t Declaration public double t Field Value Type Description System.Double tan_ Declaration public double tan_ Field Value Type Description System.Double W Declaration public double W Field Value Type Description System.Double wA Declaration public double wA Field Value Type Description System.Double wB Declaration public double wB Field Value Type Description System.Double wC Declaration public double wC Field Value Type Description System.Double x Declaration public double x Field Value Type Description System.Double xp Declaration public double xp Field Value Type Description System.Double y Declaration public double y Field Value Type Description System.Double yp Declaration public double yp Field Value Type Description System.Double zA Declaration public double zA Field Value Type Description System.Double zB Declaration public double zB Field Value Type Description System.Double zC Declaration public double zC Field Value Type Description System.Double Zx Declaration public double Zx Field Value Type Description System.Double Zy Declaration public double Zy Field Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.LProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.LProfileFactory.html",
    "title": "Class LProfileFactory | Hypar Docs",
    "keywords": "Class LProfileFactory A factory for creation L profiles. Inheritance System.Object ParametricProfileFactory < LProfileType , LProfile > LProfileFactory Inherited Members ParametricProfileFactory<LProfileType, LProfile>.AllProfilesAsync() ParametricProfileFactory<LProfileType, LProfile>.GetProfileByNameAsync(String) ParametricProfileFactory<LProfileType, LProfile>.GetProfileByTypeAsync(LProfileType) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class LProfileFactory : ParametricProfileFactory<LProfileType, LProfile> Constructors LProfileFactory() Create an L profile factory. Declaration public LProfileFactory()"
  },
  "api/Elements.Geometry.Profiles.LProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.LProfileType.html",
    "title": "Enum LProfileType | Hypar Docs",
    "keywords": "Enum LProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum LProfileType Fields Name Description L10X10X1 L10X10X1__1_4 L10X10X1__1_8 L10X10X1__3_8 L10X10X3_4 L10X10X7_8 L12X12X1 L12X12X1__1_4 L12X12X1__1_8 L12X12X1__3_8 L2__1_2X1__1_2X1_4 L2__1_2X1__1_2X3_16 L2__1_2X2__1_2X1_2 L2__1_2X2__1_2X1_4 L2__1_2X2__1_2X3_16 L2__1_2X2__1_2X3_8 L2__1_2X2__1_2X5_16 L2__1_2X2X1_4 L2__1_2X2X3_16 L2__1_2X2X3_8 L2__1_2X2X5_16 L2X2X1_4 L2X2X1_8 L2X2X3_16 L2X2X3_8 L2X2X5_16 L3__1_2X2__1_2X1_2 L3__1_2X2__1_2X1_4 L3__1_2X2__1_2X3_8 L3__1_2X2__1_2X5_16 L3__1_2X3__1_2X1_2 L3__1_2X3__1_2X1_4 L3__1_2X3__1_2X3_8 L3__1_2X3__1_2X5_16 L3__1_2X3__1_2X7_16 L3__1_2X3X1_2 L3__1_2X3X1_4 L3__1_2X3X3_8 L3__1_2X3X5_16 L3__1_2X3X7_16 L3X2__1_2X1_2 L3X2__1_2X1_4 L3X2__1_2X3_16 L3X2__1_2X3_8 L3X2__1_2X5_16 L3X2__1_2X7_16 L3X2X1_2 L3X2X1_4 L3X2X3_16 L3X2X3_8 L3X2X5_16 L3X3X1_2 L3X3X1_4 L3X3X3_16 L3X3X3_8 L3X3X5_16 L3X3X7_16 L4X3__1_2X1_2 L4X3__1_2X1_4 L4X3__1_2X3_8 L4X3__1_2X5_16 L4X3X1_2 L4X3X1_4 L4X3X3_8 L4X3X5_16 L4X3X5_8 L4X4X1_2 L4X4X1_4 L4X4X3_4 L4X4X3_8 L4X4X5_16 L4X4X5_8 L4X4X7_16 L5X3__1_2X1_2 L5X3__1_2X1_4 L5X3__1_2X3_4 L5X3__1_2X3_8 L5X3__1_2X5_16 L5X3__1_2X5_8 L5X3X1_2 L5X3X1_4 L5X3X3_8 L5X3X5_16 L5X3X7_16 L5X5X1_2 L5X5X3_4 L5X5X3_8 L5X5X5_16 L5X5X5_8 L5X5X7_16 L5X5X7_8 L6X3__1_2X1_2 L6X3__1_2X3_8 L6X3__1_2X5_16 L6X4X1_2 L6X4X3_4 L6X4X3_8 L6X4X5_16 L6X4X5_8 L6X4X7_16 L6X4X7_8 L6X4X9_16 L6X6X1 L6X6X1_2 L6X6X3_4 L6X6X3_8 L6X6X5_16 L6X6X5_8 L6X6X7_16 L6X6X7_8 L6X6X9_16 L7X4X1_2 L7X4X3_4 L7X4X3_8 L7X4X5_8 L7X4X7_16 L8X4X1 L8X4X1_2 L8X4X3_4 L8X4X5_8 L8X4X7_16 L8X4X7_8 L8X4X9_16 L8X6X1 L8X6X1_2 L8X6X3_4 L8X6X5_8 L8X6X7_16 L8X6X7_8 L8X6X9_16 L8X8X1 L8X8X1__1_8 L8X8X1_2 L8X8X3_4 L8X8X5_8 L8X8X7_8 L8X8X9_16"
  },
  "api/Elements.Geometry.Profiles.MCProfile.html": {
    "href": "api/Elements.Geometry.Profiles.MCProfile.html",
    "title": "Class MCProfile | Hypar Docs",
    "keywords": "Class MCProfile Inheritance System.Object Element Profile ParametricProfile MCProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members ParametricProfile.PerimeterVectorExpressions ParametricProfile.VoidVectorExpressions ParametricProfile.SetGeometryAsync() ParametricProfile.SetPropertiesFromProfileData(Dictionary<String, Double>, String) Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class MCProfile : ParametricProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors MCProfile() Declaration public MCProfile() MCProfile(Polygon, IList<Polygon>, Guid, String) Declaration [JsonConstructor] public MCProfile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Fields A Declaration public double A Field Value Type Description System.Double b_t Declaration public double b_t Field Value Type Description System.Double bf Declaration public double bf Field Value Type Description System.Double bfdet Declaration public double bfdet Field Value Type Description System.Double Cw Declaration public double Cw Field Value Type Description System.Double d Declaration public double d Field Value Type Description System.Double ddet Declaration public double ddet Field Value Type Description System.Double eo Declaration public double eo Field Value Type Description System.Double H Declaration public double H Field Value Type Description System.Double h_tw Declaration public double h_tw Field Value Type Description System.Double ho Declaration public double ho Field Value Type Description System.Double Ix Declaration public double Ix Field Value Type Description System.Double Iy Declaration public double Iy Field Value Type Description System.Double J Declaration public double J Field Value Type Description System.Double k1 Declaration public double k1 Field Value Type Description System.Double kdes Declaration public double kdes Field Value Type Description System.Double kdet Declaration public double kdet Field Value Type Description System.Double PA Declaration public double PA Field Value Type Description System.Double PB Declaration public double PB Field Value Type Description System.Double PC Declaration public double PC Field Value Type Description System.Double PD Declaration public double PD Field Value Type Description System.Double Qf Declaration public double Qf Field Value Type Description System.Double Qw Declaration public double Qw Field Value Type Description System.Double ro Declaration public double ro Field Value Type Description System.Double rts Declaration public double rts Field Value Type Description System.Double rx Declaration public double rx Field Value Type Description System.Double ry Declaration public double ry Field Value Type Description System.Double Sw1 Declaration public double Sw1 Field Value Type Description System.Double Sw2 Declaration public double Sw2 Field Value Type Description System.Double Sw3 Declaration public double Sw3 Field Value Type Description System.Double Sx Declaration public double Sx Field Value Type Description System.Double Sy Declaration public double Sy Field Value Type Description System.Double T Declaration public double T Field Value Type Description System.Double tf Declaration public double tf Field Value Type Description System.Double tfdet Declaration public double tfdet Field Value Type Description System.Double tw Declaration public double tw Field Value Type Description System.Double twdet Declaration public double twdet Field Value Type Description System.Double twdet_2 Declaration public double twdet_2 Field Value Type Description System.Double W Declaration public double W Field Value Type Description System.Double WGi Declaration public double WGi Field Value Type Description System.Double Wno Declaration public double Wno Field Value Type Description System.Double x Declaration public double x Field Value Type Description System.Double xp Declaration public double xp Field Value Type Description System.Double Zx Declaration public double Zx Field Value Type Description System.Double Zy Declaration public double Zy Field Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.MCProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.MCProfileFactory.html",
    "title": "Class MCProfileFactory | Hypar Docs",
    "keywords": "Class MCProfileFactory A factory for creation MC profiles. Inheritance System.Object ParametricProfileFactory < MCProfileType , MCProfile > MCProfileFactory Inherited Members ParametricProfileFactory<MCProfileType, MCProfile>.AllProfilesAsync() ParametricProfileFactory<MCProfileType, MCProfile>.GetProfileByNameAsync(String) ParametricProfileFactory<MCProfileType, MCProfile>.GetProfileByTypeAsync(MCProfileType) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class MCProfileFactory : ParametricProfileFactory<MCProfileType, MCProfile> Constructors MCProfileFactory() Create an MC profile factory. Declaration public MCProfileFactory()"
  },
  "api/Elements.Geometry.Profiles.MCProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.MCProfileType.html",
    "title": "Enum MCProfileType | Hypar Docs",
    "keywords": "Enum MCProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum MCProfileType Fields Name Description MC10X22 MC10X25 MC10X28_5 MC10X33_6 MC10X41_1 MC10X6_5 MC10X8_4 MC12X10_6 MC12X14_3 MC12X31 MC12X35 MC12X40 MC12X45 MC12X50 MC13X31_8 MC13X35 MC13X40 MC13X50 MC18X42_7 MC18X45_8 MC18X51_9 MC18X58 MC3X7_1 MC4X13_8 MC6X12 MC6X15_1 MC6X15_3 MC6X16_3 MC6X18 MC6X6_5 MC6X7 MC7X19_1 MC7X22_7 MC8X18_7 MC8X20 MC8X21_4 MC8X22_8 MC8X8_5 MC9X23_9 MC9X25_4"
  },
  "api/Elements.Geometry.Profiles.ParametricProfile.html": {
    "href": "api/Elements.Geometry.Profiles.ParametricProfile.html",
    "title": "Class ParametricProfile | Hypar Docs",
    "keywords": "Class ParametricProfile A profile whose vertex locations are defined by a parametric expression. Inheritance System.Object Element Profile ParametricProfile CProfile HSSProfile LProfile MCProfile STProfile WProfile WTProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class ParametricProfile : Profile, INotifyPropertyChanged, IEquatable<Profile> Constructors ParametricProfile(List<VectorExpression>, List<List<VectorExpression>>, Polygon, IList<Polygon>, Guid, String) Create a parametric profile. Declaration [JsonConstructor] public ParametricProfile(List<VectorExpression> perimeterVectorExpressions, List<List<VectorExpression>> voidVectorExpressions = null, Polygon perimeter = null, IList<Polygon> voids = null, Guid id = default(Guid), string name = null) Parameters Type Name Description System.Collections.Generic.List < VectorExpression > perimeterVectorExpressions System.Collections.Generic.List < System.Collections.Generic.List < VectorExpression >> voidVectorExpressions Polygon perimeter The perimeter of the profile. System.Collections.Generic.IList < Polygon > voids The voids of the profile. System.Guid id The unique identifier of the profile. System.String name The name of the profile. Properties PerimeterVectorExpressions A collection of vector expressions. Declaration public List<VectorExpression> PerimeterVectorExpressions { get; } Property Value Type Description System.Collections.Generic.List < VectorExpression > VoidVectorExpressions A collection of vector expressions. Declaration public List<List<VectorExpression>> VoidVectorExpressions { get; } Property Value Type Description System.Collections.Generic.List < System.Collections.Generic.List < VectorExpression >> Methods SetGeometryAsync() Create the geometry of the parametric profile. Declaration public async Task SetGeometryAsync() Returns Type Description System.Threading.Tasks.Task SetPropertiesFromProfileData(Dictionary<String, Double>, String) Set the properties or public member values of this profile instance to the values contained in the supplied dictionary. Declaration public void SetPropertiesFromProfileData(Dictionary<string, double> profileData, string name) Parameters Type Name Description System.Collections.Generic.Dictionary < System.String , System.Double > profileData A dictionary of property values. System.String name The name of the profile. Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.ParametricProfileFactory-2.html": {
    "href": "api/Elements.Geometry.Profiles.ParametricProfileFactory-2.html",
    "title": "Class ParametricProfileFactory<TProfileType, TProfile> | Hypar Docs",
    "keywords": "Class ParametricProfileFactory<TProfileType, TProfile> A profile factory which creates parametric profiles. Inheritance System.Object ParametricProfileFactory<TProfileType, TProfile> CProfileFactory HSSProfileFactory LProfileFactory MCProfileFactory STProfileFactory WProfileFactory WTProfileFactory Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class ParametricProfileFactory<TProfileType, TProfile> where TProfileType : Enum where TProfile : ParametricProfile Type Parameters Name Description TProfileType TProfile Constructors ParametricProfileFactory(String, Double) Create a parametric profile factory by reading from a csv. Declaration public ParametricProfileFactory(string csvPath, double conversion) Parameters Type Name Description System.String csvPath The path of the csv. This can be an absolute path, a path relative to the current working directory, or a path relative to the location of the type's assembly. System.Double conversion The conversion factor applied to values in the catalogue. Methods AllProfilesAsync() Get all profiles. Declaration public async Task<IEnumerable<TProfile>> AllProfilesAsync() Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IEnumerable <TProfile>> GetProfileByNameAsync(String) Get a profile by name. Declaration public async Task<TProfile> GetProfileByNameAsync(string name) Parameters Type Name Description System.String name The name of the profile. Returns Type Description System.Threading.Tasks.Task <TProfile> GetProfileByTypeAsync(TProfileType) Get a profile by type. Declaration public async Task<TProfile> GetProfileByTypeAsync(TProfileType type) Parameters Type Name Description TProfileType type Returns Type Description System.Threading.Tasks.Task <TProfile>"
  },
  "api/Elements.Geometry.Profiles.ProfileFactoryBase-2.html": {
    "href": "api/Elements.Geometry.Profiles.ProfileFactoryBase-2.html",
    "title": "Class ProfileFactoryBase<TProfileType, TProfile> | Hypar Docs",
    "keywords": "Class ProfileFactoryBase<TProfileType, TProfile> Base class for profile factories. Inheritance System.Object ProfileFactoryBase<TProfileType, TProfile> HSSPipeProfileFactory RHSProfileFactory SHSProfileFactory WideFlangeProfileFactory Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public abstract class ProfileFactoryBase<TProfileType, TProfile> Type Parameters Name Description TProfileType TProfile Constructors ProfileFactoryBase(String) Construct a profile factory. Declaration public ProfileFactoryBase(string data) Parameters Type Name Description System.String data A comma separated data value representing the properties of the profiles. Fields _profileData A collection of profile data. Declaration protected List<string[]> _profileData Field Value Type Description System.Collections.Generic.List < System.String []> Methods AllProfiles() Get all profiles. Declaration public IEnumerable<TProfile> AllProfiles() Returns Type Description System.Collections.Generic.IEnumerable <TProfile> CreateProfile(Int32) Create a profile. Declaration protected virtual TProfile CreateProfile(int typeIndex) Parameters Type Name Description System.Int32 typeIndex Returns Type Description TProfile GetProfileByName(String) Get a profile by name. Declaration public abstract TProfile GetProfileByName(string name) Parameters Type Name Description System.String name Returns Type Description TProfile GetProfileByType(TProfileType) Get a profile by type. Declaration public abstract TProfile GetProfileByType(TProfileType type) Parameters Type Name Description TProfileType type Returns Type Description TProfile"
  },
  "api/Elements.Geometry.Profiles.RHSProfile.html": {
    "href": "api/Elements.Geometry.Profiles.RHSProfile.html",
    "title": "Class RHSProfile | Hypar Docs",
    "keywords": "Class RHSProfile A rectangular hollow section profile. Inheritance System.Object Element Profile RHSProfile SHSProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class RHSProfile : Profile, INotifyPropertyChanged, IEquatable<Profile> Constructors RHSProfile(String, Guid, Double, Double, Double) Construct a rectangular hollow section profile. Declaration [JsonConstructor] public RHSProfile(string name, Guid id, double a, double b, double t) Parameters Type Name Description System.String name System.Guid id System.Double a System.Double b System.Double t Properties A Declaration public double A { get; } Property Value Type Description System.Double B Declaration public double B { get; } Property Value Type Description System.Double ix Declaration [JsonIgnore] public double ix { get; } Property Value Type Description System.Double Ix Declaration [JsonIgnore] public double Ix { get; } Property Value Type Description System.Double iy Declaration [JsonIgnore] public double iy { get; } Property Value Type Description System.Double Iy Declaration [JsonIgnore] public double Iy { get; } Property Value Type Description System.Double J Declaration [JsonIgnore] public double J { get; } Property Value Type Description System.Double M Declaration [JsonIgnore] public double M { get; } Property Value Type Description System.Double nl Declaration [JsonIgnore] public double nl { get; } Property Value Type Description System.Double sa Declaration [JsonIgnore] public double sa { get; } Property Value Type Description System.Double t Declaration public double t { get; } Property Value Type Description System.Double ti Declaration [JsonIgnore] public double ti { get; } Property Value Type Description System.Double tm Declaration [JsonIgnore] public double tm { get; } Property Value Type Description System.Double Zpx Declaration [JsonIgnore] public double Zpx { get; } Property Value Type Description System.Double Zpy Declaration [JsonIgnore] public double Zpy { get; } Property Value Type Description System.Double Zx Declaration [JsonIgnore] public double Zx { get; } Property Value Type Description System.Double Zy Declaration [JsonIgnore] public double Zy { get; } Property Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.RHSProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.RHSProfileFactory.html",
    "title": "Class RHSProfileFactory | Hypar Docs",
    "keywords": "Class RHSProfileFactory A profile factory for rectangular hollow steel profiles. Inheritance System.Object ProfileFactoryBase < RHSProfileType , RHSProfile > RHSProfileFactory Inherited Members ProfileFactoryBase<RHSProfileType, RHSProfile>._profileData ProfileFactoryBase<RHSProfileType, RHSProfile>.GetProfileByName(String) ProfileFactoryBase<RHSProfileType, RHSProfile>.GetProfileByType(RHSProfileType) ProfileFactoryBase<RHSProfileType, RHSProfile>.AllProfiles() ProfileFactoryBase<RHSProfileType, RHSProfile>.CreateProfile(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public sealed class RHSProfileFactory : ProfileFactoryBase<RHSProfileType, RHSProfile> Constructors RHSProfileFactory() Declaration public RHSProfileFactory() Methods CreateProfile(Int32) Declaration protected override RHSProfile CreateProfile(int typeIndex) Parameters Type Name Description System.Int32 typeIndex Returns Type Description RHSProfile Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.RHSProfileType, Elements.Geometry.Profiles.RHSProfile>.CreateProfile(System.Int32) GetProfileByName(String) Get a profile by name. Declaration public override RHSProfile GetProfileByName(string name) Parameters Type Name Description System.String name The name of the profile. Returns Type Description RHSProfile A rectangular hollow section profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.RHSProfileType, Elements.Geometry.Profiles.RHSProfile>.GetProfileByName(System.String) GetProfileByType(RHSProfileType) Get a profile by type. Declaration public override RHSProfile GetProfileByType(RHSProfileType type) Parameters Type Name Description RHSProfileType type The type of the profile. Returns Type Description RHSProfile A rectangular hollow section profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.RHSProfileType, Elements.Geometry.Profiles.RHSProfile>.GetProfileByType(Elements.Geometry.Profiles.RHSProfileType)"
  },
  "api/Elements.Geometry.Profiles.RHSProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.RHSProfileType.html",
    "title": "Enum RHSProfileType | Hypar Docs",
    "keywords": "Enum RHSProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum RHSProfileType Fields Name Description RHS100x40x1_6 RHS100x40x2 RHS100x40x2_3 RHS100x40x2_5 RHS100x40x3 RHS100x40x3_2 RHS100x40x4 RHS100x40x4_5 RHS100x50x1_6 RHS100x50x2 RHS100x50x2_3 RHS100x50x2_5 RHS100x50x3 RHS100x50x3_2 RHS100x50x4 RHS100x50x4_5 RHS100x50x5 RHS100x50x6 RHS125x40x1_6 RHS125x40x2 RHS125x40x2_3 RHS125x40x2_5 RHS125x40x3 RHS125x40x3_2 RHS125x40x4 RHS125x40x4_5 RHS125x50x1_6 RHS125x50x2 RHS125x50x2_3 RHS125x50x2_5 RHS125x50x3 RHS125x50x3_2 RHS125x50x4 RHS125x50x4_5 RHS125x50x5 RHS125x50x6 RHS125x75x1_6 RHS125x75x2 RHS125x75x2_3 RHS125x75x2_5 RHS125x75x3 RHS125x75x3_2 RHS125x75x4 RHS125x75x4_5 RHS125x75x5 RHS125x75x6 RHS125x75x6_3 RHS125x75x8 RHS125x75x9 RHS150x100x10 RHS150x100x12 RHS150x100x2_3 RHS150x100x2_5 RHS150x100x3 RHS150x100x3_2 RHS150x100x4 RHS150x100x4_5 RHS150x100x5 RHS150x100x6 RHS150x100x6_3 RHS150x100x8 RHS150x100x9 RHS150x50x2_3 RHS150x50x2_5 RHS150x50x3 RHS150x50x3_2 RHS150x50x4 RHS150x50x4_5 RHS150x50x5 RHS150x50x6 RHS150x75x3 RHS150x75x3_2 RHS150x75x4 RHS150x75x4_5 RHS150x75x5 RHS150x75x6 RHS150x75x6_3 RHS150x75x8 RHS150x75x9 RHS150x80x3 RHS150x80x3_2 RHS150x80x4 RHS150x80x4_5 RHS150x80x5 RHS150x80x6 RHS175x125x10 RHS175x125x12 RHS175x125x4_5 RHS175x125x5 RHS175x125x6 RHS175x125x6_3 RHS175x125x8 RHS175x125x9 RHS200x100x10 RHS200x100x12 RHS200x100x12_5 RHS200x100x3_2 RHS200x100x4 RHS200x100x4_5 RHS200x100x5 RHS200x100x6 RHS200x100x6_3 RHS200x100x8 RHS200x100x9 RHS200x150x10 RHS200x150x12 RHS200x150x12_5 RHS200x150x4_5 RHS200x150x5 RHS200x150x6 RHS200x150x6_3 RHS200x150x8 RHS200x150x9 RHS225x175x4_5 RHS225x175x5 RHS225x175x6 RHS250x100x10 RHS250x100x12 RHS250x100x4_5 RHS250x100x5 RHS250x100x6 RHS250x100x6_3 RHS250x100x8 RHS250x100x9 RHS250x150x10 RHS250x150x12 RHS250x150x12_5 RHS250x150x4_5 RHS250x150x5 RHS250x150x6 RHS250x150x6_3 RHS250x150x8 RHS250x150x9 RHS250x200x10 RHS250x200x12 RHS250x200x12_5 RHS250x200x6 RHS250x200x6_3 RHS250x200x8 RHS250x200x9 RHS300x100x4_5 RHS300x100x5 RHS300x100x6 RHS300x100x6_3 RHS300x100x8 RHS300x100x9 RHS300x150x10 RHS300x150x12 RHS300x150x12_5 RHS300x150x6 RHS300x150x6_3 RHS300x150x8 RHS300x150x9 RHS300x200x10 RHS300x200x12 RHS300x200x12_5 RHS300x200x16 RHS300x200x6 RHS300x200x6_3 RHS300x200x8 RHS300x200x9 RHS350x150x10 RHS350x150x12 RHS350x150x12_5 RHS350x150x6 RHS350x150x6_3 RHS350x150x8 RHS350x150x9 RHS350x250x10 RHS350x250x12 RHS350x250x12_5 RHS350x250x16 RHS350x250x6 RHS350x250x6_3 RHS350x250x8 RHS350x250x9 RHS400x200x10 RHS400x200x12 RHS400x200x12_5 RHS400x200x6 RHS400x200x6_3 RHS400x200x8 RHS400x200x9 RHS400x300x10 RHS400x300x12 RHS400x300x12_5 RHS400x300x16 RHS400x300x9 RHS500x300x12 RHS500x300x12_5 RHS500x300x16 RHS500x300x19 RHS600x300x12 RHS600x300x12_5 RHS600x300x16 RHS600x300x19 RHS600x300x22 RHS60x30x1_6 RHS60x30x2 RHS60x30x2_3 RHS60x30x2_5 RHS60x30x3 RHS60x30x3_2 RHS60x30x4 RHS60x30x4_5 RHS60x40x1_6 RHS60x40x2 RHS60x40x2_3 RHS60x40x2_5 RHS60x40x3 RHS60x40x3_2 RHS60x40x4 RHS60x40x4_5 RHS70x40x1_6 RHS70x40x2 RHS70x40x2_3 RHS70x40x2_5 RHS70x40x3 RHS70x40x3_2 RHS70x40x4 RHS70x40x4_5 RHS75x45x1_6 RHS75x45x2 RHS75x45x2_3 RHS75x45x2_5 RHS75x45x3 RHS75x45x3_2 RHS75x45x4 RHS75x45x4_5 RHS75x45x5 RHS75x45x6 RHS75x50x2_3 RHS75x50x2_5 RHS75x50x3 RHS75x50x3_2 RHS75x50x4 RHS75x50x4_5 RHS75x50x5 RHS75x50x6"
  },
  "api/Elements.Geometry.Profiles.SHSProfile.html": {
    "href": "api/Elements.Geometry.Profiles.SHSProfile.html",
    "title": "Class SHSProfile | Hypar Docs",
    "keywords": "Class SHSProfile A square hollow section profile. Inheritance System.Object Element Profile RHSProfile SHSProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members RHSProfile.A RHSProfile.B RHSProfile.t RHSProfile.M RHSProfile.Ix RHSProfile.Iy RHSProfile.ix RHSProfile.iy RHSProfile.Zx RHSProfile.Zy RHSProfile.Zpx RHSProfile.Zpy RHSProfile.ti RHSProfile.tm RHSProfile.sa RHSProfile.nl RHSProfile.J Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class SHSProfile : RHSProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors SHSProfile(String, Guid, Double, Double, Double) Construct an square hollow section profile. Declaration [JsonConstructor] public SHSProfile(string name, Guid id, double a, double b, double t) Parameters Type Name Description System.String name System.Guid id System.Double a System.Double b System.Double t Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.SHSProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.SHSProfileFactory.html",
    "title": "Class SHSProfileFactory | Hypar Docs",
    "keywords": "Class SHSProfileFactory A singleton class which serves every HSS pipe section as defined by AISC. Inheritance System.Object ProfileFactoryBase < SHSProfileType , SHSProfile > SHSProfileFactory Inherited Members ProfileFactoryBase<SHSProfileType, SHSProfile>._profileData ProfileFactoryBase<SHSProfileType, SHSProfile>.GetProfileByName(String) ProfileFactoryBase<SHSProfileType, SHSProfile>.GetProfileByType(SHSProfileType) ProfileFactoryBase<SHSProfileType, SHSProfile>.AllProfiles() ProfileFactoryBase<SHSProfileType, SHSProfile>.CreateProfile(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public sealed class SHSProfileFactory : ProfileFactoryBase<SHSProfileType, SHSProfile> Constructors SHSProfileFactory() Declaration public SHSProfileFactory() Methods CreateProfile(Int32) Declaration protected override SHSProfile CreateProfile(int typeIndex) Parameters Type Name Description System.Int32 typeIndex Returns Type Description SHSProfile Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.SHSProfileType, Elements.Geometry.Profiles.SHSProfile>.CreateProfile(System.Int32) GetProfileByName(String) Get a profile by name. Declaration public override SHSProfile GetProfileByName(string name) Parameters Type Name Description System.String name The name of the profile. Returns Type Description SHSProfile A rectangular hollow section profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.SHSProfileType, Elements.Geometry.Profiles.SHSProfile>.GetProfileByName(System.String) GetProfileByType(SHSProfileType) Get a profile by type. Declaration public override SHSProfile GetProfileByType(SHSProfileType type) Parameters Type Name Description SHSProfileType type The type of the profile. Returns Type Description SHSProfile A rectangular hollow section profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.Profiles.SHSProfileType, Elements.Geometry.Profiles.SHSProfile>.GetProfileByType(Elements.Geometry.Profiles.SHSProfileType)"
  },
  "api/Elements.Geometry.Profiles.SHSProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.SHSProfileType.html",
    "title": "Enum SHSProfileType | Hypar Docs",
    "keywords": "Enum SHSProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum SHSProfileType Fields Name Description SHS100xs00x1_6 SHS100xs00x10 SHS100xs00x12 SHS100xs00x2 SHS100xs00x2_3 SHS100xs00x2_5 SHS100xs00x3 SHS100xs00x3_2 SHS100xs00x4 SHS100xs00x4_5 SHS100xs00x5 SHS100xs00x6 SHS100xs00x6_3 SHS100xs00x8 SHS100xs00x9 SHS120xs00x10 SHS120xs00x12 SHS120xs00x6 SHS120xs00x6_3 SHS120xs00x8 SHS120xs00x9 SHS125xs00x10 SHS125xs00x12 SHS125xs00x12_5 SHS125xs00x2_3 SHS125xs00x2_5 SHS125xs00x3 SHS125xs00x3_2 SHS125xs00x4 SHS125xs00x4_5 SHS125xs00x5 SHS125xs00x6 SHS125xs00x6_3 SHS125xs00x8 SHS125xs00x9 SHS150xs00x10 SHS150xs00x12 SHS150xs00x12_5 SHS150xs00x3_2 SHS150xs00x4 SHS150xs00x4_5 SHS150xs00x5 SHS150xs00x6 SHS150xs00x6_3 SHS150xs00x8 SHS150xs00x9 SHS175xs00x10 SHS175xs00x12 SHS175xs00x12_5 SHS175xs00x4_5 SHS175xs00x5 SHS175xs00x6 SHS175xs00x6_3 SHS175xs00x8 SHS175xs00x9 SHS200xs00x10 SHS200xs00x12 SHS200xs00x12_5 SHS200xs00x16 SHS200xs00x4_5 SHS200xs00x5 SHS200xs00x6 SHS200xs00x6_3 SHS200xs00x8 SHS200xs00x9 SHS250xs00x10 SHS250xs00x12 SHS250xs00x12_5 SHS250xs00x16 SHS250xs00x19 SHS250xs00x6 SHS250xs00x6_3 SHS250xs00x8 SHS250xs00x9 SHS300xs00x10 SHS300xs00x12 SHS300xs00x12_5 SHS300xs00x16 SHS300xs00x19 SHS300xs00x6 SHS300xs00x6_3 SHS300xs00x8 SHS300xs00x9 SHS350xs00x10 SHS350xs00x12 SHS350xs00x12_5 SHS350xs00x16 SHS350xs00x19 SHS350xs00x22 SHS350xs00x9 SHS400xs00x10 SHS400xs00x12 SHS400xs00x12_5 SHS400xs00x16 SHS400xs00x19 SHS400xs00x22 SHS400xs00x9 SHS450xs00x10 SHS450xs00x12 SHS450xs00x12_5 SHS450xs00x16 SHS450xs00x19 SHS450xs00x22 SHS450xs00x9 SHS500xs00x10 SHS500xs00x12 SHS500xs00x12_5 SHS500xs00x16 SHS500xs00x19 SHS500xs00x22 SHS500xs00x9 SHS50xs00x1_6 SHS50xs00x2 SHS50xs00x2_3 SHS50xs00x2_5 SHS50xs00x3 SHS50xs00x3_2 SHS50xs00x4 SHS50xs00x4_5 SHS50xs00x5 SHS50xs00x6 SHS550xs00x12 SHS550xs00x12_5 SHS550xs00x16 SHS550xs00x19 SHS550xs00x22 SHS60xs00x1_6 SHS60xs00x2 SHS60xs00x2_3 SHS60xs00x2_5 SHS60xs00x3 SHS60xs00x3_2 SHS60xs00x4 SHS60xs00x4_5 SHS60xs00x5 SHS60xs00x6 SHS75xs00x1_6 SHS75xs00x2 SHS75xs00x2_3 SHS75xs00x2_5 SHS75xs00x3 SHS75xs00x3_2 SHS75xs00x4 SHS75xs00x4_5 SHS75xs00x5 SHS75xs00x6 SHS75xs00x6_3 SHS75xs00x8 SHS80xs00x1_6 SHS80xs00x2 SHS80xs00x2_3 SHS80xs00x2_5 SHS80xs00x3 SHS80xs00x3_2 SHS80xs00x4 SHS80xs00x4_5 SHS80xs00x5 SHS80xs00x6 SHS80xs00x6_3 SHS80xs00x8 SHS90xs00x2_3 SHS90xs00x2_5 SHS90xs00x3 SHS90xs00x3_2 SHS90xs00x4 SHS90xs00x4_5 SHS90xs00x5 SHS90xs00x6 SHS90xs00x6_3"
  },
  "api/Elements.Geometry.Profiles.STProfile.html": {
    "href": "api/Elements.Geometry.Profiles.STProfile.html",
    "title": "Class STProfile | Hypar Docs",
    "keywords": "Class STProfile Inheritance System.Object Element Profile ParametricProfile STProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members ParametricProfile.PerimeterVectorExpressions ParametricProfile.VoidVectorExpressions ParametricProfile.SetGeometryAsync() ParametricProfile.SetPropertiesFromProfileData(Dictionary<String, Double>, String) Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class STProfile : ParametricProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors STProfile() Declaration public STProfile() STProfile(Polygon, IList<Polygon>, Guid, String) Declaration [JsonConstructor] public STProfile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Fields A Declaration public double A Field Value Type Description System.Double bf Declaration public double bf Field Value Type Description System.Double bf_2tf Declaration public double bf_2tf Field Value Type Description System.Double bfdet Declaration public double bfdet Field Value Type Description System.Double Cw Declaration public double Cw Field Value Type Description System.Double d Declaration public double d Field Value Type Description System.Double D_t Declaration public double D_t Field Value Type Description System.Double ddet Declaration public double ddet Field Value Type Description System.Double H Declaration public double H Field Value Type Description System.Double Ix Declaration public double Ix Field Value Type Description System.Double Iy Declaration public double Iy Field Value Type Description System.Double J Declaration public double J Field Value Type Description System.Double kdes Declaration public double kdes Field Value Type Description System.Double kdet Declaration public double kdet Field Value Type Description System.Double ro Declaration public double ro Field Value Type Description System.Double rx Declaration public double rx Field Value Type Description System.Double ry Declaration public double ry Field Value Type Description System.Double Sx Declaration public double Sx Field Value Type Description System.Double Sy Declaration public double Sy Field Value Type Description System.Double tf Declaration public double tf Field Value Type Description System.Double tfdet Declaration public double tfdet Field Value Type Description System.Double tw Declaration public double tw Field Value Type Description System.Double twdet Declaration public double twdet Field Value Type Description System.Double twdet_2 Declaration public double twdet_2 Field Value Type Description System.Double W Declaration public double W Field Value Type Description System.Double WGi Declaration public double WGi Field Value Type Description System.Double y Declaration public double y Field Value Type Description System.Double yp Declaration public double yp Field Value Type Description System.Double Zx Declaration public double Zx Field Value Type Description System.Double Zy Declaration public double Zy Field Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.STProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.STProfileFactory.html",
    "title": "Class STProfileFactory | Hypar Docs",
    "keywords": "Class STProfileFactory A factory for creation L profiles. Inheritance System.Object ParametricProfileFactory < STProfileType , STProfile > STProfileFactory Inherited Members ParametricProfileFactory<STProfileType, STProfile>.AllProfilesAsync() ParametricProfileFactory<STProfileType, STProfile>.GetProfileByNameAsync(String) ParametricProfileFactory<STProfileType, STProfile>.GetProfileByTypeAsync(STProfileType) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class STProfileFactory : ParametricProfileFactory<STProfileType, STProfile> Constructors STProfileFactory() Create an ST profile factory. Declaration public STProfileFactory()"
  },
  "api/Elements.Geometry.Profiles.STProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.STProfileType.html",
    "title": "Enum STProfileType | Hypar Docs",
    "keywords": "Enum STProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum STProfileType Fields Name Description ST1_5X2_85 ST1_5X3_75 ST10X33 ST10X37_5 ST10X43 ST10X48 ST12X40 ST12X45 ST12X50 ST12X53 ST12X60_5 ST2_5X5 ST2X3_85 ST2X4_75 ST3X6_25 ST3X8_6 ST4X11_5 ST4X9_2 ST5X12_7 ST5X17_5 ST6X15_9 ST6X17_5 ST6X20_4 ST6X25 ST7_5X21_45 ST7_5X25 ST9X27_35 ST9X35"
  },
  "api/Elements.Geometry.Profiles.VectorExpression.html": {
    "href": "api/Elements.Geometry.Profiles.VectorExpression.html",
    "title": "Class VectorExpression | Hypar Docs",
    "keywords": "Class VectorExpression A collection of expressions describing the X, Y, and Z coordinates of a vertex. Inheritance System.Object VectorExpression Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class VectorExpression Constructors VectorExpression(String, String, String) Create a vector expression. Declaration [JsonConstructor] public VectorExpression(string x = null, string y = null, string z = null) Parameters Type Name Description System.String x The expression of the X coordinate of the vector. System.String y The expression of the Y coordinate of the vector. System.String z The expression of the Z coordinate of the vector. Properties X The expression of the X coordinate of the vector. Declaration public string X { get; set; } Property Value Type Description System.String Y The expression of the Y coordinate of the vector. Declaration public string Y { get; set; } Property Value Type Description System.String Z The expression of the Z coordinate of the vector. Declaration public string Z { get; set; } Property Value Type Description System.String"
  },
  "api/Elements.Geometry.Profiles.VerticalAlignment.html": {
    "href": "api/Elements.Geometry.Profiles.VerticalAlignment.html",
    "title": "Enum VerticalAlignment | Hypar Docs",
    "keywords": "Enum VerticalAlignment The vertical alignment of a profile. Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum VerticalAlignment Fields Name Description Bottom Align the profile along its bottom. Center Align the profile along its center. Top Align the profile along its top."
  },
  "api/Elements.Geometry.Profiles.WideFlangeProfile.html": {
    "href": "api/Elements.Geometry.Profiles.WideFlangeProfile.html",
    "title": "Class WideFlangeProfile | Hypar Docs",
    "keywords": "Class WideFlangeProfile A wide flange profile. Inheritance System.Object Element Profile WideFlangeProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class WideFlangeProfile : Profile, INotifyPropertyChanged, IEquatable<Profile> Constructors WideFlangeProfile(String) Declaration public WideFlangeProfile(string name) Parameters Type Name Description System.String name WideFlangeProfile(String, Guid, Double, Double, Double, Double, VerticalAlignment, HorizontalAlignment, Double, Double) Construct a wide flange section. Declaration [JsonConstructor] public WideFlangeProfile(string name, Guid id, double bf = 0.1, double d = 0.05, double tf = 0.005, double tw = 0.005, VerticalAlignment verticalAlignment = VerticalAlignment.Center, HorizontalAlignment horizontalAlignment = HorizontalAlignment.Center, double verticalOffset = 0, double horizontalOffset = 0) Parameters Type Name Description System.String name System.Guid id System.Double bf System.Double d System.Double tf System.Double tw VerticalAlignment verticalAlignment HorizontalAlignment horizontalAlignment System.Double verticalOffset System.Double horizontalOffset Properties A Declaration [JsonIgnore] public double A { get; } Property Value Type Description System.Double bf Declaration public double bf { get; } Property Value Type Description System.Double Cw Declaration [JsonIgnore] public double Cw { get; } Property Value Type Description System.Double d Declaration public double d { get; } Property Value Type Description System.Double dAf Declaration [JsonIgnore] public double dAf { get; } Property Value Type Description System.Double gage Declaration [JsonIgnore] public string gage { get; } Property Value Type Description System.String Ix Declaration [JsonIgnore] public double Ix { get; } Property Value Type Description System.Double Iy Declaration [JsonIgnore] public double Iy { get; } Property Value Type Description System.Double J Declaration [JsonIgnore] public double J { get; } Property Value Type Description System.Double k Declaration [JsonIgnore] public double k { get; } Property Value Type Description System.Double k1 Declaration [JsonIgnore] public double k1 { get; } Property Value Type Description System.Double Qf Declaration [JsonIgnore] public double Qf { get; } Property Value Type Description System.Double Qw Declaration [JsonIgnore] public double Qw { get; } Property Value Type Description System.Double rt Declaration [JsonIgnore] public double rt { get; } Property Value Type Description System.Double rx Declaration [JsonIgnore] public double rx { get; } Property Value Type Description System.Double ry Declaration [JsonIgnore] public double ry { get; } Property Value Type Description System.Double Sw Declaration [JsonIgnore] public double Sw { get; } Property Value Type Description System.Double Sx Declaration [JsonIgnore] public double Sx { get; } Property Value Type Description System.Double Sy Declaration [JsonIgnore] public double Sy { get; } Property Value Type Description System.Double T Declaration [JsonIgnore] public string T { get; } Property Value Type Description System.String tf Declaration public double tf { get; } Property Value Type Description System.Double tw Declaration public double tw { get; } Property Value Type Description System.Double Wno Declaration [JsonIgnore] public double Wno { get; } Property Value Type Description System.Double Zx Declaration [JsonIgnore] public double Zx { get; } Property Value Type Description System.Double Zy Declaration [JsonIgnore] public double Zy { get; } Property Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.WideFlangeProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.WideFlangeProfileFactory.html",
    "title": "Class WideFlangeProfileFactory | Hypar Docs",
    "keywords": "Class WideFlangeProfileFactory A profile factory for wide flange profiles. Inheritance System.Object ProfileFactoryBase < WideFlangeProfileType , WideFlangeProfile > WideFlangeProfileFactory Inherited Members ProfileFactoryBase<WideFlangeProfileType, WideFlangeProfile>._profileData ProfileFactoryBase<WideFlangeProfileType, WideFlangeProfile>.GetProfileByName(String) ProfileFactoryBase<WideFlangeProfileType, WideFlangeProfile>.GetProfileByType(WideFlangeProfileType) ProfileFactoryBase<WideFlangeProfileType, WideFlangeProfile>.AllProfiles() ProfileFactoryBase<WideFlangeProfileType, WideFlangeProfile>.CreateProfile(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public sealed class WideFlangeProfileFactory : ProfileFactoryBase<WideFlangeProfileType, WideFlangeProfile> Constructors WideFlangeProfileFactory() Construct a wide flange profile factory. Declaration public WideFlangeProfileFactory() Methods CreateProfile(Int32) Declaration protected override WideFlangeProfile CreateProfile(int typeIndex) Parameters Type Name Description System.Int32 typeIndex Returns Type Description WideFlangeProfile Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.WideFlangeProfileType, Elements.Geometry.Profiles.WideFlangeProfile>.CreateProfile(System.Int32) GetProfileByName(String) Get a profile by name. Declaration public override WideFlangeProfile GetProfileByName(string name) Parameters Type Name Description System.String name The name of the profile. Returns Type Description WideFlangeProfile A wide flange profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.WideFlangeProfileType, Elements.Geometry.Profiles.WideFlangeProfile>.GetProfileByName(System.String) GetProfileByType(WideFlangeProfileType) Get a profile by type. Declaration public override WideFlangeProfile GetProfileByType(WideFlangeProfileType type) Parameters Type Name Description WideFlangeProfileType type The type of the profile. Returns Type Description WideFlangeProfile A wide flange profile. Overrides Elements.Geometry.Profiles.ProfileFactoryBase<Elements.Geometry.WideFlangeProfileType, Elements.Geometry.Profiles.WideFlangeProfile>.GetProfileByType(Elements.Geometry.WideFlangeProfileType)"
  },
  "api/Elements.Geometry.Profiles.WProfile.html": {
    "href": "api/Elements.Geometry.Profiles.WProfile.html",
    "title": "Class WProfile | Hypar Docs",
    "keywords": "Class WProfile Inheritance System.Object Element Profile ParametricProfile WProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members ParametricProfile.PerimeterVectorExpressions ParametricProfile.VoidVectorExpressions ParametricProfile.SetGeometryAsync() ParametricProfile.SetPropertiesFromProfileData(Dictionary<String, Double>, String) Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class WProfile : ParametricProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors WProfile() Declaration public WProfile() WProfile(Polygon, IList<Polygon>, Guid, String) Declaration [JsonConstructor] public WProfile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Fields A Declaration public double A Field Value Type Description System.Double bf Declaration public double bf Field Value Type Description System.Double bf_2tf Declaration public double bf_2tf Field Value Type Description System.Double bfdet Declaration public double bfdet Field Value Type Description System.Double Cw Declaration public double Cw Field Value Type Description System.Double d Declaration public double d Field Value Type Description System.Double ddet Declaration public double ddet Field Value Type Description System.Double h_tw Declaration public double h_tw Field Value Type Description System.Double ho Declaration public double ho Field Value Type Description System.Double Ix Declaration public double Ix Field Value Type Description System.Double Iy Declaration public double Iy Field Value Type Description System.Double J Declaration public double J Field Value Type Description System.Double k1 Declaration public double k1 Field Value Type Description System.Double kdes Declaration public double kdes Field Value Type Description System.Double kdet Declaration public double kdet Field Value Type Description System.Double PA Declaration public double PA Field Value Type Description System.Double PB Declaration public double PB Field Value Type Description System.Double PC Declaration public double PC Field Value Type Description System.Double PD Declaration public double PD Field Value Type Description System.Double Qf Declaration public double Qf Field Value Type Description System.Double Qw Declaration public double Qw Field Value Type Description System.Double rts Declaration public double rts Field Value Type Description System.Double rx Declaration public double rx Field Value Type Description System.Double ry Declaration public double ry Field Value Type Description System.Double Sw1 Declaration public double Sw1 Field Value Type Description System.Double Sx Declaration public double Sx Field Value Type Description System.Double Sy Declaration public double Sy Field Value Type Description System.Double T Declaration public double T Field Value Type Description System.Double tf Declaration public double tf Field Value Type Description System.Double tfdet Declaration public double tfdet Field Value Type Description System.Double tw Declaration public double tw Field Value Type Description System.Double twdet Declaration public double twdet Field Value Type Description System.Double twdet_2 Declaration public double twdet_2 Field Value Type Description System.Double W Declaration public double W Field Value Type Description System.Double WGi Declaration public double WGi Field Value Type Description System.Double Wno Declaration public double Wno Field Value Type Description System.Double Zx Declaration public double Zx Field Value Type Description System.Double Zy Declaration public double Zy Field Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.WProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.WProfileFactory.html",
    "title": "Class WProfileFactory | Hypar Docs",
    "keywords": "Class WProfileFactory A factory for creation W profiles. Inheritance System.Object ParametricProfileFactory < WProfileType , WProfile > WProfileFactory Inherited Members ParametricProfileFactory<WProfileType, WProfile>.AllProfilesAsync() ParametricProfileFactory<WProfileType, WProfile>.GetProfileByNameAsync(String) ParametricProfileFactory<WProfileType, WProfile>.GetProfileByTypeAsync(WProfileType) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class WProfileFactory : ParametricProfileFactory<WProfileType, WProfile> Constructors WProfileFactory() Create an L profile factory. Declaration public WProfileFactory()"
  },
  "api/Elements.Geometry.Profiles.WProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.WProfileType.html",
    "title": "Enum WProfileType | Hypar Docs",
    "keywords": "Enum WProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum WProfileType Fields Name Description W10X100 W10X112 W10X12 W10X15 W10X17 W10X19 W10X22 W10X26 W10X30 W10X33 W10X39 W10X45 W10X49 W10X54 W10X60 W10X68 W10X77 W10X88 W12X106 W12X120 W12X136 W12X14 W12X152 W12X16 W12X170 W12X19 W12X190 W12X210 W12X22 W12X230 W12X252 W12X26 W12X279 W12X30 W12X305 W12X336 W12X35 W12X40 W12X45 W12X50 W12X53 W12X58 W12X65 W12X72 W12X79 W12X87 W12X96 W14X109 W14X120 W14X132 W14X145 W14X159 W14X176 W14X193 W14X211 W14X22 W14X233 W14X257 W14X26 W14X283 W14X30 W14X311 W14X34 W14X342 W14X370 W14X38 W14X398 W14X426 W14X43 W14X455 W14X48 W14X500 W14X53 W14X550 W14X605 W14X61 W14X665 W14X68 W14X730 W14X74 W14X808 W14X82 W14X873 W14X90 W14X99 W16X100 W16X26 W16X31 W16X36 W16X40 W16X45 W16X50 W16X57 W16X67 W16X77 W16X89 W18X106 W18X119 W18X130 W18X143 W18X158 W18X175 W18X192 W18X211 W18X234 W18X258 W18X283 W18X311 W18X35 W18X40 W18X46 W18X50 W18X55 W18X60 W18X65 W18X71 W18X76 W18X86 W18X97 W21X101 W21X111 W21X122 W21X132 W21X147 W21X166 W21X182 W21X201 W21X223 W21X248 W21X275 W21X44 W21X48 W21X50 W21X55 W21X57 W21X62 W21X68 W21X73 W21X83 W21X93 W24X103 W24X104 W24X117 W24X131 W24X146 W24X162 W24X176 W24X192 W24X207 W24X229 W24X250 W24X279 W24X306 W24X335 W24X370 W24X55 W24X62 W24X68 W24X76 W24X84 W24X94 W27X102 W27X114 W27X129 W27X146 W27X161 W27X178 W27X194 W27X217 W27X235 W27X258 W27X281 W27X307 W27X336 W27X368 W27X539 W27X84 W27X94 W30X108 W30X116 W30X124 W30X132 W30X148 W30X173 W30X191 W30X211 W30X235 W30X261 W30X292 W30X326 W30X357 W30X391 W30X90 W30X99 W33X118 W33X130 W33X141 W33X152 W33X169 W33X201 W33X221 W33X241 W33X263 W33X291 W33X318 W33X354 W33X387 W36X135 W36X150 W36X160 W36X170 W36X182 W36X194 W36X210 W36X231 W36X232 W36X247 W36X256 W36X262 W36X282 W36X302 W36X330 W36X361 W36X395 W36X441 W36X487 W36X529 W36X652 W36X723 W36X802 W36X853 W36X925 W40X149 W40X167 W40X183 W40X199 W40X211 W40X215 W40X235 W40X249 W40X264 W40X277 W40X278 W40X294 W40X297 W40X324 W40X327 W40X331 W40X362 W40X372 W40X392 W40X397 W40X431 W40X503 W40X593 W40X655 W44X230 W44X262 W44X290 W44X335 W4X13 W5X16 W5X19 W6X12 W6X15 W6X16 W6X20 W6X25 W6X8_5 W6X9 W8X10 W8X13 W8X15 W8X18 W8X21 W8X24 W8X28 W8X31 W8X35 W8X40 W8X48 W8X58 W8X67"
  },
  "api/Elements.Geometry.Profiles.WTProfile.html": {
    "href": "api/Elements.Geometry.Profiles.WTProfile.html",
    "title": "Class WTProfile | Hypar Docs",
    "keywords": "Class WTProfile Inheritance System.Object Element Profile ParametricProfile WTProfile Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable < Profile > Inherited Members ParametricProfile.PerimeterVectorExpressions ParametricProfile.VoidVectorExpressions ParametricProfile.SetGeometryAsync() ParametricProfile.SetPropertiesFromProfileData(Dictionary<String, Double>, String) Profile.Perimeter Profile.Voids Profile.Transformed(Transform) Profile.Reversed() Profile.Area() Profile.Transform(Transform) Profile.Scale(Double) Profile.Project(Plane) Profile.Union(Profile, Double) Profile.OrientVoids() Profile.Equals(Profile) Profile.Contains(Vector3) Profile.Contains(Vector3, Containment) Profile.UnionAll(IEnumerable<Profile>, Double) Profile.Difference(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Intersection(IEnumerable<Profile>, IEnumerable<Profile>, Double) Profile.Split(IEnumerable<Profile>, IEnumerable<Polyline>, Double) Profile.Split(IEnumerable<Profile>, Polyline, Double) Profile.Offset(Double, Double) Profile.Offset(IEnumerable<Profile>, Double, Double) Profile.CreateFromPolygons(IEnumerable<Polygon>, Double) Profile.Segments() Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class WTProfile : ParametricProfile, INotifyPropertyChanged, IEquatable<Profile> Constructors WTProfile() Declaration public WTProfile() WTProfile(Polygon, IList<Polygon>, Guid, String) Declaration [JsonConstructor] public WTProfile(Polygon perimeter, IList<Polygon> voids, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Guid id System.String name Fields A Declaration public double A Field Value Type Description System.Double bf Declaration public double bf Field Value Type Description System.Double bf_2tf Declaration public double bf_2tf Field Value Type Description System.Double bfdet Declaration public double bfdet Field Value Type Description System.Double Cw Declaration public double Cw Field Value Type Description System.Double d Declaration public double d Field Value Type Description System.Double D_t Declaration public double D_t Field Value Type Description System.Double ddet Declaration public double ddet Field Value Type Description System.Double H Declaration public double H Field Value Type Description System.Double Ix Declaration public double Ix Field Value Type Description System.Double Iy Declaration public double Iy Field Value Type Description System.Double J Declaration public double J Field Value Type Description System.Double kdes Declaration public double kdes Field Value Type Description System.Double kdet Declaration public double kdet Field Value Type Description System.Double PA Declaration public double PA Field Value Type Description System.Double PB Declaration public double PB Field Value Type Description System.Double PC Declaration public double PC Field Value Type Description System.Double PD Declaration public double PD Field Value Type Description System.Double ro Declaration public double ro Field Value Type Description System.Double rx Declaration public double rx Field Value Type Description System.Double ry Declaration public double ry Field Value Type Description System.Double Sx Declaration public double Sx Field Value Type Description System.Double Sy Declaration public double Sy Field Value Type Description System.Double tf Declaration public double tf Field Value Type Description System.Double tfdet Declaration public double tfdet Field Value Type Description System.Double tw Declaration public double tw Field Value Type Description System.Double twdet Declaration public double twdet Field Value Type Description System.Double twdet_2 Declaration public double twdet_2 Field Value Type Description System.Double W Declaration public double W Field Value Type Description System.Double WGi Declaration public double WGi Field Value Type Description System.Double y Declaration public double y Field Value Type Description System.Double yp Declaration public double yp Field Value Type Description System.Double Zx Declaration public double Zx Field Value Type Description System.Double Zy Declaration public double Zy Field Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged System.IEquatable<T> Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String) ModelCurveExtensions.ToModelCurves(Profile, Transform, Material)"
  },
  "api/Elements.Geometry.Profiles.WTProfileFactory.html": {
    "href": "api/Elements.Geometry.Profiles.WTProfileFactory.html",
    "title": "Class WTProfileFactory | Hypar Docs",
    "keywords": "Class WTProfileFactory A factory for creation WT profiles. Inheritance System.Object ParametricProfileFactory < WTProfileType , WTProfile > WTProfileFactory Inherited Members ParametricProfileFactory<WTProfileType, WTProfile>.AllProfilesAsync() ParametricProfileFactory<WTProfileType, WTProfile>.GetProfileByNameAsync(String) ParametricProfileFactory<WTProfileType, WTProfile>.GetProfileByTypeAsync(WTProfileType) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public class WTProfileFactory : ParametricProfileFactory<WTProfileType, WTProfile> Constructors WTProfileFactory() Create an WT profile factory. Declaration public WTProfileFactory()"
  },
  "api/Elements.Geometry.Profiles.WTProfileType.html": {
    "href": "api/Elements.Geometry.Profiles.WTProfileType.html",
    "title": "Enum WTProfileType | Hypar Docs",
    "keywords": "Enum WTProfileType Namespace : Elements.Geometry.Profiles Assembly : Hypar.Elements.dll Syntax public enum WTProfileType Fields Name Description WT10_5X100_5 WT10_5X111_5 WT10_5X124 WT10_5X137_5 WT10_5X22 WT10_5X24 WT10_5X25 WT10_5X27_5 WT10_5X28_5 WT10_5X31 WT10_5X34 WT10_5X36_5 WT10_5X41_5 WT10_5X46_5 WT10_5X50_5 WT10_5X55_5 WT10_5X61 WT10_5X66 WT10_5X73_5 WT10_5X83 WT10_5X91 WT12X103_5 WT12X114_5 WT12X125 WT12X139_5 WT12X153 WT12X167_5 WT12X185 WT12X27_5 WT12X31 WT12X34 WT12X38 WT12X42 WT12X47 WT12X51_5 WT12X52 WT12X58_5 WT12X65_5 WT12X73 WT12X81 WT12X88 WT12X96 WT13_5X108_5 WT13_5X117_5 WT13_5X129 WT13_5X140_5 WT13_5X153_5 WT13_5X168 WT13_5X184 WT13_5X269_5 WT13_5X42 WT13_5X47 WT13_5X51 WT13_5X57 WT13_5X64_5 WT13_5X73 WT13_5X80_5 WT13_5X89 WT13_5X97 WT15X105_5 WT15X117_5 WT15X130_5 WT15X146 WT15X163 WT15X178_5 WT15X195_5 WT15X45 WT15X49_5 WT15X54 WT15X58 WT15X62 WT15X66 WT15X74 WT15X86_5 WT15X95_5 WT16_5X100_5 WT16_5X110_5 WT16_5X120_5 WT16_5X131_5 WT16_5X145_5 WT16_5X159 WT16_5X177 WT16_5X193_5 WT16_5X59 WT16_5X65 WT16_5X70_5 WT16_5X76 WT16_5X84_5 WT18X105 WT18X115_5 WT18X116 WT18X123_5 WT18X128 WT18X131 WT18X141 WT18X151 WT18X165 WT18X180_5 WT18X197_5 WT18X220_5 WT18X243_5 WT18X264_5 WT18X326 WT18X361_5 WT18X401 WT18X426_5 WT18X462_5 WT18X67_5 WT18X75 WT18X80 WT18X85 WT18X91 WT18X97 WT2_5X8 WT2_5X9_5 WT20X105_5 WT20X107_5 WT20X117_5 WT20X124_5 WT20X132 WT20X138_5 WT20X139 WT20X147 WT20X148_5 WT20X162 WT20X163_5 WT20X165_5 WT20X181 WT20X186 WT20X196 WT20X198_5 WT20X215_5 WT20X251_5 WT20X296_5 WT20X327_5 WT20X74_5 WT20X83_5 WT20X91_5 WT20X99_5 WT22X115 WT22X131 WT22X145 WT22X167_5 WT2X6_5 WT3X10 WT3X12_5 WT3X4_25 WT3X4_5 WT3X6 WT3X7_5 WT3X8 WT4X10_5 WT4X12 WT4X14 WT4X15_5 WT4X17_5 WT4X20 WT4X24 WT4X29 WT4X33_5 WT4X5 WT4X6_5 WT4X7_5 WT4X9 WT5X11 WT5X13 WT5X15 WT5X16_5 WT5X19_5 WT5X22_5 WT5X24_5 WT5X27 WT5X30 WT5X34 WT5X38_5 WT5X44 WT5X50 WT5X56 WT5X6 WT5X7_5 WT5X8_5 WT5X9_5 WT6X105 WT6X11 WT6X115 WT6X126 WT6X13 WT6X139_5 WT6X15 WT6X152_5 WT6X168 WT6X17_5 WT6X20 WT6X22_5 WT6X25 WT6X26_5 WT6X29 WT6X32_5 WT6X36 WT6X39_5 WT6X43_5 WT6X48 WT6X53 WT6X60 WT6X68 WT6X7 WT6X76 WT6X8 WT6X85 WT6X9_5 WT6X95 WT7X105_5 WT7X11 WT7X116_5 WT7X128_5 WT7X13 WT7X141_5 WT7X15 WT7X155_5 WT7X17 WT7X171 WT7X185 WT7X19 WT7X199 WT7X21_5 WT7X213 WT7X227_5 WT7X24 WT7X250 WT7X26_5 WT7X275 WT7X30_5 WT7X302_5 WT7X332_5 WT7X34 WT7X365 WT7X37 WT7X404 WT7X41 WT7X436_5 WT7X45 WT7X49_5 WT7X54_5 WT7X60 WT7X66 WT7X72_5 WT7X79_5 WT7X88 WT7X96_5 WT8X13 WT8X15_5 WT8X18 WT8X20 WT8X22_5 WT8X25 WT8X28_5 WT8X33_5 WT8X38_5 WT8X44_5 WT8X50 WT9X105_5 WT9X117 WT9X129 WT9X141_5 WT9X155_5 WT9X17_5 WT9X20 WT9X23 WT9X25 WT9X27_5 WT9X30 WT9X32_5 WT9X35_5 WT9X38 WT9X43 WT9X48_5 WT9X53 WT9X59_5 WT9X65 WT9X71_5 WT9X79 WT9X87_5 WT9X96"
  },
  "api/Elements.Geometry.Ray.html": {
    "href": "api/Elements.Geometry.Ray.html",
    "title": "Struct Ray | Hypar Docs",
    "keywords": "Struct Ray An infinite ray starting at origin and pointing towards direction. Implements System.IEquatable < Ray > Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct Ray : IEquatable<Ray> Constructors Ray(Vector3, Vector3) Construct a ray. Declaration public Ray(Vector3 origin, Vector3 direction) Parameters Type Name Description Vector3 origin The origin of the ray. Vector3 direction The direction of the ray. Properties Direction The direction of the ray. Declaration public Vector3 Direction { get; set; } Property Value Type Description Vector3 Origin The origin of the ray. Declaration public Vector3 Origin { get; set; } Property Value Type Description Vector3 Methods Equals(Ray) Is this ray equal to the provided ray? Declaration public bool Equals(Ray other) Parameters Type Name Description Ray other The ray to test. Returns Type Description System.Boolean Returns true if the two rays are equal, otherwise false. Intersects(GeometricElement, out List<Vector3>) Does this ray intersect with the provided GeometricElement? Only GeometricElements with Solid Representations are currently supported, and voids will be ignored. Declaration public bool Intersects(GeometricElement element, out List<Vector3> result) Parameters Type Name Description GeometricElement element The element to intersect with. System.Collections.Generic.List < Vector3 > result The list of intersection results. Returns Type Description System.Boolean Intersects(Line, out Vector3) Does this ray intersect the provided line? Declaration public bool Intersects(Line line, out Vector3 result) Parameters Type Name Description Line line The line to intersect. Vector3 result The location of intersection. Returns Type Description System.Boolean True if the rays intersect, otherwise false. Intersects(Mesh, out Vector3) Does this ray intersect the provided mesh? Declaration public bool Intersects(Mesh mesh, out Vector3 result) Parameters Type Name Description Mesh mesh The Mesh. Vector3 result The location of intersection. Returns Type Description System.Boolean True if an intersection result occurs. False if no intersection occurs. Intersects(Plane, out Vector3) Does this ray intersect the provided plane? Declaration public bool Intersects(Plane plane, out Vector3 result) Parameters Type Name Description Plane plane The Plane to intersect with. Vector3 result The intersection result. Returns Type Description System.Boolean True if an intersection occurs, otherwise false  this can occur if the ray is very close to parallel to the plane. If true, check the intersection result for the location of the intersection. Intersects(Plane, out Vector3, out Double) Does this ray intersect the provided plane? Declaration public bool Intersects(Plane plane, out Vector3 result, out double t) Parameters Type Name Description Plane plane The Plane to intersect with. Vector3 result The intersection result. System.Double t Returns Type Description System.Boolean True if an intersection occurs, otherwise false  this can occur if the ray is very close to parallel to the plane. If true, check the intersection result for the location of the intersection. Intersects(Polygon, out Vector3, out Containment) Does this ray intersect the provided polygon area? Declaration public bool Intersects(Polygon polygon, out Vector3 result, out Containment containment) Parameters Type Name Description Polygon polygon The Polygon to intersect with. Vector3 result The intersection result. Containment containment An enumeration detailing the type of intersection if one occurs. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. If true, check the intersection result for the location of the intersection. Intersects(Ray, out Vector3, out RayIntersectionResult, Boolean) Does this ray intersect the provided ray? Declaration public bool Intersects(Ray ray, out Vector3 result, out RayIntersectionResult intersectionResult, bool ignoreRayDirection = false) Parameters Type Name Description Ray ray The ray to intersect. Vector3 result The location of intersection. RayIntersectionResult intersectionResult An enumeration of possible ray intersection result types. System.Boolean ignoreRayDirection If true, the direction of the rays will be ignored. Returns Type Description System.Boolean True if the rays intersect, otherwise false. Intersects(Ray, out Vector3, Boolean) Does this ray intersect the provided ray? Declaration public bool Intersects(Ray ray, out Vector3 result, bool ignoreRayDirection = false) Parameters Type Name Description Ray ray The ray to intersect. Vector3 result The location of intersection. System.Boolean ignoreRayDirection If true, the direction of the rays will be ignored Returns Type Description System.Boolean True if the rays intersect, otherwise false. Intersects(SolidOperation, out List<Vector3>) Does this ray intersect with the provided SolidOperation? Declaration public bool Intersects(SolidOperation solidOp, out List<Vector3> result) Parameters Type Name Description SolidOperation solidOp The SolidOperation to intersect with. System.Collections.Generic.List < Vector3 > result The list of intersection results, ordered by distance from the ray origin. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. If true, check the intersection result for the location of the intersection. Intersects(Triangle, out Vector3) https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm Declaration public bool Intersects(Triangle tri, out Vector3 result) Parameters Type Name Description Triangle tri The triangle to intersect. Vector3 result The intersection result. Returns Type Description System.Boolean True if an intersection occurs, otherwise false. If true, check the intersection result for the type and location of intersection. Intersects(Vector3, Vector3, out Vector3) Does this ray intersect a line segment defined by start and end? Declaration public bool Intersects(Vector3 start, Vector3 end, out Vector3 result) Parameters Type Name Description Vector3 start The start of the line segment. Vector3 end The end of the line segment. Vector3 result The location of the intersection. Returns Type Description System.Boolean True if the ray intersects, otherwise false. Intersects(Vector3, Vector3, out Vector3, out RayIntersectionResult) Does this ray intersect a line segment defined by start and end? Declaration public bool Intersects(Vector3 start, Vector3 end, out Vector3 result, out RayIntersectionResult intersectionResult) Parameters Type Name Description Vector3 start The start of the line segment. Vector3 end The end of the line segment. Vector3 result The location of the intersection. RayIntersectionResult intersectionResult The nature of the ray intersection. Returns Type Description System.Boolean True if the ray intersects, otherwise false. Intersects(Topography, out Vector3) Does this ray intersect the provided topography? Declaration public bool Intersects(Topography topo, out Vector3 result) Parameters Type Name Description Topography topo The topography. Vector3 result The location of intersection. Returns Type Description System.Boolean True if an intersection result occurs. False if no intersection occurs. NearbyPoints(IEnumerable<Vector3>, Double) Find points in the collection that are within the provided distance of this ray. Declaration public Vector3[] NearbyPoints(IEnumerable<Vector3> points, double distance) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The collection of points to search System.Double distance The maximum distance from the ray. Returns Type Description Vector3 [] Points that are within the given distance of the ray. Implements System.IEquatable<T>"
  },
  "api/Elements.Geometry.RayIntersectionResult.html": {
    "href": "api/Elements.Geometry.RayIntersectionResult.html",
    "title": "Enum RayIntersectionResult | Hypar Docs",
    "keywords": "Enum RayIntersectionResult The possible types of ray intersection result. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum RayIntersectionResult Fields Name Description Coincident The rays are coincident. Intersect The rays intersect. None The rays do not intersect. Parallel The rays are parallel."
  },
  "api/Elements.Geometry.RelationToPlane.html": {
    "href": "api/Elements.Geometry.RelationToPlane.html",
    "title": "Enum RelationToPlane | Hypar Docs",
    "keywords": "Enum RelationToPlane An enumeration of relations to a plane. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum RelationToPlane Fields Name Description Above On the normal-facing side of the plane. Below On the non-normal-facing side of the plane. Intersects Intersects None None"
  },
  "api/Elements.Geometry.Representation.html": {
    "href": "api/Elements.Geometry.Representation.html",
    "title": "Class Representation | Hypar Docs",
    "keywords": "Class Representation The representation of an element. Inheritance System.Object Representation Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Representation Constructors Representation(SolidOperation[]) Construct a Representation from SolidOperations. This is a convenience constructor that can be used like this: new Representation(new Extrude(...)) Declaration public Representation(params SolidOperation[] solidOperations) Parameters Type Name Description SolidOperation [] solidOperations The solid operations composing this representation. Representation(IList<SolidOperation>) Construct a representation. Declaration [JsonConstructor] public Representation(IList<SolidOperation> solidOperations) Parameters Type Name Description System.Collections.Generic.IList < SolidOperation > solidOperations A collection of solid operations. Properties SolidOperations A collection of solid operations. Declaration [JsonProperty(\"SolidOperations\", Required = Required.Always)] [Required] public IList<SolidOperation> SolidOperations { get; set; } Property Value Type Description System.Collections.Generic.IList < SolidOperation > Operators Implicit(SolidOperation to Representation) Automatically convert a single solid operation into a representation containing that operation. Declaration public static implicit operator Representation(SolidOperation solidOperation) Parameters Type Name Description SolidOperation solidOperation The solid operation composing this Representation. Returns Type Description Representation"
  },
  "api/Elements.Geometry.Solids.ConstructedSolid.html": {
    "href": "api/Elements.Geometry.Solids.ConstructedSolid.html",
    "title": "Class ConstructedSolid | Hypar Docs",
    "keywords": "Class ConstructedSolid Create a custom SolidOperation from imported geometry. Inheritance System.Object SolidOperation ConstructedSolid Inherited Members SolidOperation.LocalTransform SolidOperation.Solid SolidOperation.IsVoid SolidOperation.PropertyChanged SolidOperation.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class ConstructedSolid : SolidOperation Constructors ConstructedSolid(Solid, Boolean) Create an import solid. Declaration public ConstructedSolid(Solid solid, bool isVoid = false) Parameters Type Name Description Solid solid The solid which was imported. System.Boolean isVoid Is the operation a void?"
  },
  "api/Elements.Geometry.Solids.Edge.html": {
    "href": "api/Elements.Geometry.Solids.Edge.html",
    "title": "Class Edge | Hypar Docs",
    "keywords": "Class Edge A Solid Edge. Inheritance System.Object Edge Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Edge Constructors Edge(Int64, Vertex, Vertex) Construct an Edge Declaration public Edge(long id, Vertex from, Vertex to) Parameters Type Name Description System.Int64 id Vertex from The start Vertex of the Edge. Vertex to The end Vertex of the Edge. Properties Id The Id of the Edge. Declaration public long Id { get; } Property Value Type Description System.Int64 Left The Left edge. Declaration public HalfEdge Left { get; } Property Value Type Description HalfEdge Right The Right edge. Declaration public HalfEdge Right { get; } Property Value Type Description HalfEdge Methods ToString() Get the string representation of the Edge. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Solids.Extrude.html": {
    "href": "api/Elements.Geometry.Solids.Extrude.html",
    "title": "Class Extrude | Hypar Docs",
    "keywords": "Class Extrude An extrusion of a profile, in a direction, to a height. Inheritance System.Object SolidOperation Extrude Implements System.ComponentModel.INotifyPropertyChanged Inherited Members SolidOperation.LocalTransform SolidOperation.Solid SolidOperation.IsVoid SolidOperation.PropertyChanged SolidOperation.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Extrude : SolidOperation, INotifyPropertyChanged Constructors Extrude(Profile, Double, Vector3, Boolean, Boolean) Construct an extrusion. Declaration [JsonConstructor] public Extrude(Profile profile, double height, Vector3 direction, bool isVoid = false, bool reverseWinding = false) Parameters Type Name Description Profile profile The profile to extrude. System.Double height The height/length of the extrusion. Vector3 direction The direction of the extrusion. System.Boolean isVoid If true, the extrusion is a \"void\" in a group of solid operations, subtracted from other solids. System.Boolean reverseWinding True if the extrusion should be flipped inside out, with face normals facing in instead of out. Use with caution if using with other solid operations in a representation  boolean results may be unexpected. Properties Direction The direction in which to extrude. Declaration [JsonProperty(\"Direction\", Required = Required.AllowNull)] public Vector3 Direction { get; set; } Property Value Type Description Vector3 Height The height of the extrusion. Declaration [JsonProperty(\"Height\", Required = Required.Always)] [Range(0, 1.7976931348623157E+308)] public double Height { get; set; } Property Value Type Description System.Double Profile The id of the profile to extrude. Declaration [JsonProperty(\"Profile\", Required = Required.AllowNull)] public Profile Profile { get; set; } Property Value Type Description Profile ReverseWinding Is the extrusion's profile reversed relative to its extrusion vector, resulting in inward-facing face normals? Declaration [JsonProperty(\"Reverse Winding\")] public bool ReverseWinding { get; set; } Property Value Type Description System.Boolean Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Geometry.Solids.Face.html": {
    "href": "api/Elements.Geometry.Solids.Face.html",
    "title": "Class Face | Hypar Docs",
    "keywords": "Class Face A Solid Face. Inheritance System.Object Face Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Face Properties Id The Id of the Face. Declaration public uint Id { get; } Property Value Type Description System.UInt32 Inner A collection of CW wound Edges. Declaration public Loop[] Inner { get; } Property Value Type Description Loop [] Outer A CCW wound list of Edges. Declaration public Loop Outer { get; } Property Value Type Description Loop Methods ToString() The string representation of the Face. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Solids.HalfEdge.html": {
    "href": "api/Elements.Geometry.Solids.HalfEdge.html",
    "title": "Class HalfEdge | Hypar Docs",
    "keywords": "Class HalfEdge One half of the directional components of an Edge. Inheritance System.Object HalfEdge Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class HalfEdge Constructors HalfEdge(Edge, Vertex) Construct a HalfEdge. Declaration public HalfEdge(Edge edge, Vertex vertex) Parameters Type Name Description Edge edge The Edge associated with this HalfEdge. Vertex vertex The Vertex at the start of the edge. HalfEdge(Vertex) Create a half edge. Declaration public HalfEdge(Vertex v) Parameters Type Name Description Vertex v Properties Edge The Edge of which this is one half. Declaration public Edge Edge { get; } Property Value Type Description Edge Loop The Loop to which this HalfEdge belongs. Declaration public Loop Loop { get; } Property Value Type Description Loop Vertex The Vertex at the start of the edge. Declaration public Vertex Vertex { get; set; } Property Value Type Description Vertex Methods ToString() Get the string representation of this half edge. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Solids.html": {
    "href": "api/Elements.Geometry.Solids.html",
    "title": "Namespace Elements.Geometry.Solids | Hypar Docs",
    "keywords": "Namespace Elements.Geometry.Solids Classes ConstructedSolid Create a custom SolidOperation from imported geometry. Edge A Solid Edge. Extrude An extrusion of a profile, in a direction, to a height. Face A Solid Face. HalfEdge One half of the directional components of an Edge. Lamina A zero-thickness solid defined by a profile. Loop A Loop of HalfEdges which bound a Face. Solid Boolean operations on solids. SolidOperation The base class for all operations which create solids. Sweep A sweep of a profile along a curve. Vertex A Solid Vertex."
  },
  "api/Elements.Geometry.Solids.Lamina.html": {
    "href": "api/Elements.Geometry.Solids.Lamina.html",
    "title": "Class Lamina | Hypar Docs",
    "keywords": "Class Lamina A zero-thickness solid defined by a profile. Inheritance System.Object SolidOperation Lamina Inherited Members SolidOperation.LocalTransform SolidOperation.Solid SolidOperation.IsVoid SolidOperation.PropertyChanged SolidOperation.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Lamina : SolidOperation Constructors Lamina(Polygon, Boolean) Construct a lamina from a perimeter. Declaration public Lamina(Polygon perimeter, bool isVoid = false) Parameters Type Name Description Polygon perimeter The lamina's perimeter System.Boolean isVoid Should the lamina be considered a void? Lamina(Polygon, IList<Polygon>, Boolean) Construct a lamina. Declaration [JsonConstructor] public Lamina(Polygon perimeter, IList<Polygon> voids, bool isVoid) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids System.Boolean isVoid Lamina(Profile, Boolean) Construct a lamina from a profile. Declaration public Lamina(Profile profile, bool isVoid = false) Parameters Type Name Description Profile profile The profile of the lamina System.Boolean isVoid Should the lamina be considered a void? Properties Perimeter The perimeter. Declaration [JsonProperty(\"Perimeter\", Required = Required.AllowNull)] public Polygon Perimeter { get; set; } Property Value Type Description Polygon Voids A collection of voids. Declaration [JsonProperty(\"Voids\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public IList<Polygon> Voids { get; set; } Property Value Type Description System.Collections.Generic.IList < Polygon >"
  },
  "api/Elements.Geometry.Solids.Loop.html": {
    "href": "api/Elements.Geometry.Solids.Loop.html",
    "title": "Class Loop | Hypar Docs",
    "keywords": "Class Loop A Loop of HalfEdges which bound a Face. Inheritance System.Object Loop Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Loop Constructors Loop() Construct a Loop. Declaration public Loop() Loop(HalfEdge[]) Construct a Loop from an array of HalfEdges. Declaration public Loop(HalfEdge[] edges) Parameters Type Name Description HalfEdge [] edges Properties Edges A collection of HalfEdges which comprise the Loop. Declaration public List<HalfEdge> Edges { get; } Property Value Type Description System.Collections.Generic.List < HalfEdge > Face The Face to which this Loop corresponds. Declaration public Face Face { get; set; } Property Value Type Description Face Methods AddEdgeToEnd(HalfEdge) Add a HalfEdge to the end of the Loop. Declaration public void AddEdgeToEnd(HalfEdge he) Parameters Type Name Description HalfEdge he AddEdgeToStart(HalfEdge) Add a HalfEdge ot the start of the Loop. Declaration public void AddEdgeToStart(HalfEdge he) Parameters Type Name Description HalfEdge he InsertEdgeAfter(HalfEdge, HalfEdge) Insert the provided half edge after the target half edge. Declaration public void InsertEdgeAfter(HalfEdge target, HalfEdge newEdge) Parameters Type Name Description HalfEdge target The half after which the new edge will be inserted. HalfEdge newEdge The half edge to be inserted. InsertEdgeBefore(HalfEdge, HalfEdge) Insert the provided half edge before the target half edge. Declaration public void InsertEdgeBefore(HalfEdge target, HalfEdge newEdge) Parameters Type Name Description HalfEdge target The half before which the new edge will be inserted. HalfEdge newEdge The half edge to be inserted. ToPolygon(Transform) Convert this loop to a polygon. Declaration public Polygon ToPolygon(Transform transform = null) Parameters Type Name Description Transform transform Returns Type Description Polygon"
  },
  "api/Elements.Geometry.Solids.Solid.html": {
    "href": "api/Elements.Geometry.Solids.Solid.html",
    "title": "Class Solid | Hypar Docs",
    "keywords": "Class Solid Boolean operations on solids. Inheritance System.Object Solid Implements ITessellate Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Solid : ITessellate Constructors Solid() Construct a solid. Declaration public Solid() Properties Edges The edges of the solid. Declaration public Dictionary<long, Edge> Edges { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Int64 , Edge > Faces The Faces of the Solid. Declaration public Dictionary<long, Face> Faces { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Int64 , Face > Vertices The vertices of the solid. Declaration public Dictionary<long, Vertex> Vertices { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Int64 , Vertex > Methods AddEdge(Vertex, Vertex) Add an edge to the solid. Declaration public Edge AddEdge(Vertex from, Vertex to) Parameters Type Name Description Vertex from The start vertex. Vertex to The end vertex. Returns Type Description Edge The newly added edge. AddEdges(Polygon) Creates a series of edges from a polygon. Declaration public Edge[] AddEdges(Polygon p) Parameters Type Name Description Polygon p Returns Type Description Edge [] AddFace(Polygon, IList<Polygon>, Boolean, Transform, Boolean) Add a Face to the Solid. Declaration public Face AddFace(Polygon outer, IList<Polygon> inner = null, bool mergeVerticesAndEdges = false, Transform transform = null, bool reverse = false) Parameters Type Name Description Polygon outer A polygon representing the perimeter of the face. System.Collections.Generic.IList < Polygon > inner An array of polygons representing the holes in the face. System.Boolean mergeVerticesAndEdges Should existing vertices / edges in the solid be used for the added face? Transform transform An optional transform which is applied to the polygon. System.Boolean reverse Should the loop be reversed? Returns Type Description Face The newly added face. AddFace(Loop, Loop[]) Add a face to the solid. Provided edges are expected to be wound CCW for outer, and CW for inner. The face will be linked to the edges. Declaration public Face AddFace(Loop outer, Loop[] inner = null) Parameters Type Name Description Loop outer The outer Loop of the Face. Loop [] inner The inner Loops of the Face. Returns Type Description Face The newly added Face. AddVertex(Vector3) Add a Vertex to the Solid. Declaration public Vertex AddVertex(Vector3 position) Parameters Type Name Description Vector3 position Returns Type Description Vertex The newly added vertex. Cap(Edge[][], Boolean) Create a face from edges. The first edge array is treated as the outer edge. Additional edge arrays are treated as holes. Declaration protected void Cap(Edge[][] edges, bool reverse = true) Parameters Type Name Description Edge [][] edges System.Boolean reverse CreateLamina(Polygon, IList<Polygon>) Declaration public static Solid CreateLamina(Polygon perimeter, IList<Polygon> voids = null) Parameters Type Name Description Polygon perimeter System.Collections.Generic.IList < Polygon > voids Returns Type Description Solid CreateLamina(Profile) Declaration public static Solid CreateLamina(Profile profile) Parameters Type Name Description Profile profile Returns Type Description Solid CreateLamina(IList<Vector3>) Construct a lamina solid. Declaration public static Solid CreateLamina(IList<Vector3> perimeter) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > perimeter The perimeter of the lamina's faces. Returns Type Description Solid Difference(Solid, Transform, Solid, Transform) Compute the difference of two solids. Declaration public static Solid Difference(Solid a, Transform aTransform, Solid b, Transform bTransform) Parameters Type Name Description Solid a The first solid. Transform aTransform A local transformation of a. Solid b The second solid. Transform bTransform A local transformation of b. Returns Type Description Solid A solid which is the difference of a and b. Difference(SolidOperation, SolidOperation) Compute the difference of two solid operations. Declaration public static Solid Difference(SolidOperation a, SolidOperation b) Parameters Type Name Description SolidOperation a The first solid. SolidOperation b The second solid. Returns Type Description Solid A solid which is the difference of a and b. Intersection(Solid, Transform, Solid, Transform) Compute the intersection of two solids. Declaration public static Solid Intersection(Solid a, Transform aTransform, Solid b, Transform bTransform) Parameters Type Name Description Solid a The first solid. Transform aTransform A local transformation of a. Solid b The second solid. Transform bTransform A local transformation of b. Returns Type Description Solid A solid which is the the intersection of a and b. Intersection(SolidOperation, SolidOperation) Compute the intersection of two solid operations. Declaration public static Solid Intersection(SolidOperation a, SolidOperation b) Parameters Type Name Description SolidOperation a The first solid. SolidOperation b The second solid. Returns Type Description Solid A solid which is the the intersection of a and b. Intersects(Plane, out List<Polygon>) Intersect this solid with the provided plane. Declaration public bool Intersects(Plane p, out List<Polygon> result) Parameters Type Name Description Plane p The plane of intersection. System.Collections.Generic.List < Polygon > result A collection of polygons resulting from the intersection or null if there was no intersection. Returns Type Description System.Boolean True if an intersection occurred, otherwise false. LoopFromPolygon(Polygon, Boolean, Transform, Boolean) Declaration protected Loop LoopFromPolygon(Polygon p, bool mergeVerticesAndEdges = false, Transform transform = null, bool reverse = false) Parameters Type Name Description Polygon p System.Boolean mergeVerticesAndEdges Transform transform System.Boolean reverse Returns Type Description Loop SweepFace(Polygon, IList<Polygon>, Vector3, Double, Boolean, Double) Construct a solid by sweeping a face in a direction. Declaration public static Solid SweepFace(Polygon perimeter, IList<Polygon> holes, Vector3 direction, double distance, bool bothSides = false, double rotation = 0) Parameters Type Name Description Polygon perimeter The perimeter of the face to sweep. System.Collections.Generic.IList < Polygon > holes The holes of the face to sweep. Vector3 direction The direction in which to sweep. System.Double distance The distance to sweep. System.Boolean bothSides Should the sweep start offset by direction distance/2? System.Double rotation An optional rotation in degrees of the perimeter around the direction vector. Returns Type Description Solid A solid. SweepFace(Polygon, IList<Polygon>, Double, Boolean, Double) Construct a solid by sweeping a face. Declaration public static Solid SweepFace(Polygon perimeter, IList<Polygon> holes, double distance, bool bothSides = false, double rotation = 0) Parameters Type Name Description Polygon perimeter The perimeter of the face to sweep. System.Collections.Generic.IList < Polygon > holes The holes of the face to sweep. System.Double distance The distance to sweep. System.Boolean bothSides Should the sweep start offset by direction distance/2? System.Double rotation An optional rotation in degrees of the perimeter around the z axis. Returns Type Description Solid A solid. SweepFaceAlongCurve(Polygon, IList<Polygon>, IBoundedCurve, Double, Double, Double) Construct a solid by sweeping a face along a curve. Declaration public static Solid SweepFaceAlongCurve(Polygon perimeter, IList<Polygon> holes, IBoundedCurve curve, double startSetback = 0, double endSetback = 0, double profileRotation = 0) Parameters Type Name Description Polygon perimeter The perimeter of the face to sweep. System.Collections.Generic.IList < Polygon > holes The holes of the face to sweep. IBoundedCurve curve The curve along which to sweep. System.Double startSetback The setback distance of the sweep from the start of the curve. System.Double endSetback The setback distance of the sweep from the end of the curve. System.Double profileRotation The rotation of the profile. Returns Type Description Solid A solid. Tessellate(ref Mesh, Transform, Color) Triangulate this solid. Declaration public void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh The mesh to which the solid's tessellated data will be added. Transform transform An optional transform used to transform the generated vertex coordinates. Color color An optional color to apply to the vertex. ToMesh() Get the Mesh of this Solid. Declaration public Mesh ToMesh() Returns Type Description Mesh ToString() Get the string representation of the solid. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Union(Solid, Transform, Solid, Transform) Compute the union of two solids. Declaration public static Solid Union(Solid a, Transform aTransform, Solid b, Transform bTransform) Parameters Type Name Description Solid a The first solid. Transform aTransform A local transformation of a. Solid b The second solid. Transform bTransform A local transformation of b. Returns Type Description Solid A solid which is the union of a and b. Union(SolidOperation, SolidOperation) Compute the union of two solid operations. Declaration public static Solid Union(SolidOperation a, SolidOperation b) Parameters Type Name Description SolidOperation a The first solid. SolidOperation b The second solid. Returns Type Description Solid A solid which is the union of a and b. Implements ITessellate"
  },
  "api/Elements.Geometry.Solids.SolidOperation.html": {
    "href": "api/Elements.Geometry.Solids.SolidOperation.html",
    "title": "Class SolidOperation | Hypar Docs",
    "keywords": "Class SolidOperation The base class for all operations which create solids. Inheritance System.Object SolidOperation ConstructedSolid Extrude Lamina Sweep Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public abstract class SolidOperation Constructors SolidOperation(Boolean) Construct a solid operation. Declaration [JsonConstructor] public SolidOperation(bool isVoid) Parameters Type Name Description System.Boolean isVoid Properties IsVoid Is the solid operation a void operation? Declaration [JsonProperty(\"IsVoid\", Required = Required.Always)] public bool IsVoid { get; set; } Property Value Type Description System.Boolean LocalTransform The local transform of the operation. Declaration public Transform LocalTransform { get; set; } Property Value Type Description Transform Solid The solid operation's solid. Declaration [JsonIgnore] public Solid Solid { get; } Property Value Type Description Solid Methods RaisePropertyChanged(String) Raise a property change event. Declaration protected virtual void RaisePropertyChanged(string propertyName = null) Parameters Type Name Description System.String propertyName The name of the property. Events PropertyChanged An event raised when a property is changed. Declaration public event PropertyChangedEventHandler PropertyChanged Event Type Type Description System.ComponentModel.PropertyChangedEventHandler"
  },
  "api/Elements.Geometry.Solids.Sweep.html": {
    "href": "api/Elements.Geometry.Solids.Sweep.html",
    "title": "Class Sweep | Hypar Docs",
    "keywords": "Class Sweep A sweep of a profile along a curve. Inheritance System.Object SolidOperation Sweep Implements System.ComponentModel.INotifyPropertyChanged Inherited Members SolidOperation.LocalTransform SolidOperation.Solid SolidOperation.IsVoid SolidOperation.PropertyChanged SolidOperation.RaisePropertyChanged(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Sweep : SolidOperation, INotifyPropertyChanged Constructors Sweep(Profile, BoundedCurve, Double, Double, Double, Boolean) Construct a sweep. Declaration [JsonConstructor] public Sweep(Profile profile, BoundedCurve curve, double startSetback, double endSetback, double profileRotation, bool isVoid) Parameters Type Name Description Profile profile BoundedCurve curve System.Double startSetback System.Double endSetback System.Double profileRotation System.Boolean isVoid Properties Curve The curve along which the profile will be swept. Declaration [JsonProperty(\"Curve\", Required = Required.AllowNull)] public BoundedCurve Curve { get; set; } Property Value Type Description BoundedCurve EndSetback The amount to set back the resulting solid from the end of the curve. Declaration [JsonProperty(\"EndSetback\", Required = Required.Always)] public double EndSetback { get; set; } Property Value Type Description System.Double Profile The id of the profile to be swept along the curve. Declaration [JsonProperty(\"Profile\", Required = Required.AllowNull)] public Profile Profile { get; set; } Property Value Type Description Profile ProfileRotation The rotation of the profile around the sweep's curve. Declaration [JsonProperty(\"ProfileRotation\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public double ProfileRotation { get; set; } Property Value Type Description System.Double StartSetback The amount to set back the resulting solid from the start of the curve. Declaration [JsonProperty(\"StartSetback\", Required = Required.Always)] public double StartSetback { get; set; } Property Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged"
  },
  "api/Elements.Geometry.Solids.Vertex.html": {
    "href": "api/Elements.Geometry.Solids.Vertex.html",
    "title": "Class Vertex | Hypar Docs",
    "keywords": "Class Vertex A Solid Vertex. Inheritance System.Object Vertex Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry.Solids Assembly : Hypar.Elements.dll Syntax public class Vertex Constructors Vertex(UInt32, Vector3) Construct a Vertex. Declaration public Vertex(uint id, Vector3 point) Parameters Type Name Description System.UInt32 id Vector3 point The location of the Vertex. Properties HalfEdge The HalfEdge which has this Vertex as its start. Declaration public HalfEdge HalfEdge { get; set; } Property Value Type Description HalfEdge Id The Id of the Vertex. Declaration public uint Id { get; } Property Value Type Description System.UInt32 Point The location of the Vertex. Declaration public Vector3 Point { get; } Property Value Type Description Vector3 Methods ToString() Get the string representation of the Vertex. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/Elements.Geometry.Transform.html": {
    "href": "api/Elements.Geometry.Transform.html",
    "title": "Class Transform | Hypar Docs",
    "keywords": "Class Transform A right-handed coordinate system with +Z up. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Geometry_Transform.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var m1 = new Mass(Polygon.Rectangle(1.0, 1.0), 1.0, new Material(\"yellow\", Colors.Yellow)); this.Model.AddElement(m1); Profile prof = Polygon.Rectangle(1.0, 1.0); var j = 1.0; var count = 10; for (var i = 0.0; i < 360.0; i += 360.0 / (double)count) { var m2 = new Mass(prof, 1.0, new Material($\"color_{j}\", new Color((float)j - 1.0f, 0.0f, 0.0f, 1.0f)), new Transform()); // Scale the mass. m2.Transform.Scale(new Vector3(j, j, j)); // Move the mass. m2.Transform.Move(new Vector3(3, 0, 0)); // Rotate the mass. m2.Transform.Rotate(Vector3.ZAxis, i); this.Model.AddElement(m2); j += 1.0 / (double)count; } Inheritance System.Object Transform Implements System.IEquatable < Transform > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Transform : IEquatable<Transform> Constructors Transform() Create the identity transform. Declaration public Transform() Transform(Matrix) Construct a transform. Declaration [JsonConstructor] public Transform(Matrix matrix) Parameters Type Name Description Matrix matrix Transform(Plane) Create a transform using the provided plane's origin and normal. Declaration public Transform(Plane plane) Parameters Type Name Description Plane plane The plane used to orient the transform. Transform(Transform) Create a transform by copying another transform. Declaration public Transform(Transform t) Parameters Type Name Description Transform t The transform to copy. Transform(Vector3, Vector3, Vector3, Vector3) Create a transform by origin, X, Y, and Z axes. Axes are automatically unitized  to create non-uniform transforms, use Transform.Scale. Declaration public Transform(Vector3 origin, Vector3 xAxis, Vector3 yAxis, Vector3 zAxis) Parameters Type Name Description Vector3 origin The origin of the transform. Vector3 xAxis The X axis of the transform. Vector3 yAxis The Y axis of the transform. Vector3 zAxis The Z axis of the transform. Transform(Vector3, Vector3, Vector3, Double) Create a transform by origin and X and Z axes. Declaration public Transform(Vector3 origin, Vector3 xAxis, Vector3 zAxis, double rotation = 0) Parameters Type Name Description Vector3 origin The origin of the transform. Vector3 xAxis The X axis of the transform. Vector3 zAxis The Z axis of the transform. System.Double rotation An optional rotation in degrees around the transform's z axis. Transform(Vector3, Vector3, Double) Create a transform centered at origin with its Z axis pointing along up. Declaration public Transform(Vector3 origin, Vector3 z, double rotation = 0) Parameters Type Name Description Vector3 origin The origin of the transform. Vector3 z The vector which will define the Z axis of the transform. System.Double rotation An optional rotation around the z axis. Transform(Vector3, Double) Create a transform with a translation. Declaration public Transform(Vector3 origin, double rotation = 0) Parameters Type Name Description Vector3 origin The origin of the transform. System.Double rotation An optional rotation in degrees around the transform's z axis. Transform(Double, Double, Double, Double) Create a transform with a translation. Declaration public Transform(double x, double y, double z, double rotation = 0) Parameters Type Name Description System.Double x The X component of translation. System.Double y The Y component of translation. System.Double z The Z component of translation. System.Double rotation An optional rotation in degrees around the transform's z axis. Properties Matrix The transform's matrix. Declaration [JsonProperty(\"Matrix\", Required = Required.Always)] [Required] public Matrix Matrix { get; set; } Property Value Type Description Matrix Origin The origin of the transform. Declaration [JsonIgnore] public Vector3 Origin { get; } Property Value Type Description Vector3 XAxis The x axis of the transform. Declaration [JsonIgnore] public Vector3 XAxis { get; } Property Value Type Description Vector3 YAxis The y axis of the transform. Declaration [JsonIgnore] public Vector3 YAxis { get; } Property Value Type Description Vector3 ZAxis The z axis of the transform. Declaration [JsonIgnore] public Vector3 ZAxis { get; } Property Value Type Description Vector3 Methods Concatenate(Transform) Concatenate the transform. Declaration public void Concatenate(Transform transform) Parameters Type Name Description Transform transform Concatenated(Transform) Return a new transform which is the supplied transform concatenated to this transform. Declaration public Transform Concatenated(Transform transform) Parameters Type Name Description Transform transform The transform to concatenate. Returns Type Description Transform CreateHorizontalFrameAlongCurve(Curve, Double, Vector3) Create a transform that is oriented along a curve at parameter t. The transform's +z axis will align with the +z world axis, and the +x axis will align with the XY projection of the tangent of the curve. If you want a perpendicular transform, use Curve.TransformAt(t) instead. Declaration public static Transform CreateHorizontalFrameAlongCurve(Curve curve, double t, Vector3 up = default(Vector3)) Parameters Type Name Description Curve curve The curve along which to orient the transform. System.Double t A parameter value between 0.0 and 1.0. Vector3 up Returns Type Description Transform CreateOrientedAlongCurve(Curve, Double, Vector3) Create a transform that is oriented along a curve at parameter t. The transform's +z axis will align with the +z world axis, and the +x axis will align with the tangent of the curve. If you want a perpendicular transform, use Curve.TransformAt(t) instead. Declaration [Obsolete] public static Transform CreateOrientedAlongCurve(Curve curve, double t, Vector3 up = default(Vector3)) Parameters Type Name Description Curve curve The curve along which to orient the transform. System.Double t A parameter value between 0.0 and 1.0. Vector3 up Returns Type Description Transform Equals(Transform) Is this transform equal to the provided transform? Declaration public bool Equals(Transform other) Parameters Type Name Description Transform other The transform to test. Returns Type Description System.Boolean True if the two transforms are equal, otherwise false. GetHashCode() Get the hash code for the transform. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() GetScale() Get the scale of the transform. Declaration public Vector3 GetScale() Returns Type Description Vector3 Invert() Invert this transform. Declaration public void Invert() Inverted() Return a new transform which is the inverse of this transform. Declaration public Transform Inverted() Returns Type Description Transform Move(Vector3) Apply a translation to the transform. Declaration public void Move(Vector3 translation) Parameters Type Name Description Vector3 translation The translation to apply. Move(Double, Double, Double) Apply a translation to the transform. Declaration public void Move(double x = 0, double y = 0, double z = 0) Parameters Type Name Description System.Double x System.Double y System.Double z Moved(Vector3) Return a new transform which is this transform moved by the specified amount. Declaration public Transform Moved(Vector3 translation) Parameters Type Name Description Vector3 translation The translation to apply. Returns Type Description Transform Moved(Double, Double, Double) Return a new transform which is this transform moved by the specified amount. Declaration public Transform Moved(double x = 0, double y = 0, double z = 0) Parameters Type Name Description System.Double x System.Double y System.Double z Returns Type Description Transform OfBezier(Bezier) Transform the specifed bezier. Declaration [Obsolete(\"Use Bezier.Transformed(Transform) instead.\")] public Bezier OfBezier(Bezier bezier) Parameters Type Name Description Bezier bezier The bezier to transform. Returns Type Description Bezier A new bezier transformed by this transform. OfCurve(Curve) A transformed copy of the supplied curve. Declaration [Obsolete(\"Use Curve.Transformed(Transform) instead.\")] public Curve OfCurve(Curve curve) Parameters Type Name Description Curve curve The curve to transform. Returns Type Description Curve OfLine(Line) Transform the specified line. Declaration [Obsolete(\"Use Line.Transformed(Transform) instead.\")] public Line OfLine(Line line) Parameters Type Name Description Line line The line to transform. Returns Type Description Line A new line transformed by this transform. OfPlane(Plane) Transform the specified plane. Declaration public Plane OfPlane(Plane plane) Parameters Type Name Description Plane plane The plane to transform. Returns Type Description Plane A new plane transformed by this transform. OfPoint(Vector3) Transform a vector into the coordinate space defined by this transform. Declaration public Vector3 OfPoint(Vector3 vector) Parameters Type Name Description Vector3 vector The vector to transform. Returns Type Description Vector3 A new vector transformed by this transform. OfPolygon(Polygon) Transform the specified polygon. Declaration [Obsolete(\"Use Polygon.Transformed(Transform) instead.\")] public Polygon OfPolygon(Polygon polygon) Parameters Type Name Description Polygon polygon The polygon to transform. Returns Type Description Polygon A new polygon transformed by this transform. OfPolygons(IList<Polygon>) Transform the specified polygons. Declaration public Polygon[] OfPolygons(IList<Polygon> polygons) Parameters Type Name Description System.Collections.Generic.IList < Polygon > polygons The polygons to transform. Returns Type Description Polygon [] An array of polygons transformed by this transform. OfProfile(Profile) Transform the specified profile. Declaration public Profile OfProfile(Profile profile) Parameters Type Name Description Profile profile The profile to transform. Returns Type Description Profile A new profile transformed by this transform. OfVector(Vector3) Transform a vector into the coordinate space defined by this transform ignoring the translation. Declaration public Vector3 OfVector(Vector3 vector) Parameters Type Name Description Vector3 vector The vector to transform. Returns Type Description Vector3 A new vector transformed by this transform. Reflect(Vector3) Reflect about the plane with normal n. Declaration public void Reflect(Vector3 n) Parameters Type Name Description Vector3 n The normal of the reflection plane. Rotate(Vector3, Double) Apply a rotation to the transform. Declaration public void Rotate(Vector3 axis, double angle) Parameters Type Name Description Vector3 axis The axis of rotation. System.Double angle The angle of rotation in degrees. Rotate(Double) Apply a rotation to the transform around the Z axis. Declaration public void Rotate(double angle) Parameters Type Name Description System.Double angle The angle of rotation in degrees. RotateAboutPoint(Vector3, Vector3, Double) Apply a rotation to the transform about a center. Declaration public void RotateAboutPoint(Vector3 point, Vector3 axis, double angle) Parameters Type Name Description Vector3 point The center of rotation. Vector3 axis The axis direction. System.Double angle The angle of rotation in degrees. Rotated(Vector3, Double) Return a new transform which is a rotated copy of this transform. Declaration public Transform Rotated(Vector3 axis, double angle) Parameters Type Name Description Vector3 axis The axis of rotation. System.Double angle The angle of rotation in degrees. Returns Type Description Transform RotatedAboutPoint(Vector3, Vector3, Double) Return a new Transform which is a rotated copy of this transform. Declaration public Transform RotatedAboutPoint(Vector3 point, Vector3 axis, double angle) Parameters Type Name Description Vector3 point The center of rotation. Vector3 axis The axis direction. System.Double angle The angle of rotation in degrees. Returns Type Description Transform Scale(Vector3) Apply a scale to the transform. Declaration public void Scale(Vector3 amount) Parameters Type Name Description Vector3 amount The amount to scale. Scale(Double) Scale uniformly about the origin. Declaration public void Scale(double factor) Parameters Type Name Description System.Double factor The amount to scale uniformly Scale(Double, Vector3) Scale uniformly about a point Declaration public void Scale(double factor, Vector3 origin) Parameters Type Name Description System.Double factor The scale factor Vector3 origin The origin of scaling Scaled(Vector3) Return a copy of this transform scaled by the given value. Declaration public Transform Scaled(Vector3 amount) Parameters Type Name Description Vector3 amount The amount to scale. Returns Type Description Transform Scaled(Double) Return a copy of this transform scaled uniformly. Declaration public Transform Scaled(double factor) Parameters Type Name Description System.Double factor The amount to scale uniformly Returns Type Description Transform ToString() Get a string representation of the transform. Declaration public override string ToString() Returns Type Description System.String A string representation of the transform. Overrides System.Object.ToString() XY() Calculate XY plane of the transform. Declaration public Plane XY() Returns Type Description Plane XZ() Calculate the XZ plane of the transform. Declaration public Plane XZ() Returns Type Description Plane YZ() Calculate the YZ plane of the transform. Declaration public Plane YZ() Returns Type Description Plane Implements System.IEquatable<T> Extension Methods ModelCurveExtensions.ToModelCurves(Transform, Transform)"
  },
  "api/Elements.Geometry.Triangle.html": {
    "href": "api/Elements.Geometry.Triangle.html",
    "title": "Class Triangle | Hypar Docs",
    "keywords": "Class Triangle A mesh triangle. Inheritance System.Object Triangle Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Triangle Constructors Triangle(Vertex, Vertex, Vertex) Create a triangle. Declaration public Triangle(Vertex a, Vertex b, Vertex c) Parameters Type Name Description Vertex a The index of the first vertex of the triangle. Vertex b The index of the second vertex of the triangle. Vertex c The index of the third vertex of the triangle. Triangle(IList<Vertex>, Vector3) Construct a triangle. Declaration [JsonConstructor] public Triangle(IList<Vertex> vertices, Vector3 normal) Parameters Type Name Description System.Collections.Generic.IList < Vertex > vertices The vertices of the triangle. Vector3 normal The normal of the triangle. Properties Normal The triangle's normal. Declaration [JsonProperty(\"Normal\", Required = Required.AllowNull)] public Vector3 Normal { get; set; } Property Value Type Description Vector3 Vertices The triangle's vertices. Declaration [JsonProperty(\"Vertices\", Required = Required.Always)] [Required] public IList<Vertex> Vertices { get; set; } Property Value Type Description System.Collections.Generic.IList < Vertex > Methods Area() The area of the triangle. Declaration public double Area() Returns Type Description System.Double"
  },
  "api/Elements.Geometry.TrimmedCurve-1.html": {
    "href": "api/Elements.Geometry.TrimmedCurve-1.html",
    "title": "Class TrimmedCurve<TBasis> | Hypar Docs",
    "keywords": "Class TrimmedCurve<TBasis> A trimmed curve. Inheritance System.Object Curve BoundedCurve TrimmedCurve<TBasis> Arc EllipticalArc Line Implements ICurve ITransformable < Curve > IBoundedCurve ITrimmedCurve <TBasis> Inherited Members BoundedCurve.DefaultMinimumChordLength BoundedCurve.Start BoundedCurve.End BoundedCurve.Domain BoundedCurve.Bounds() BoundedCurve.Length() BoundedCurve.ArcLength(Double, Double) BoundedCurve.Mid() BoundedCurve.IsClosedForRendering BoundedCurve.Frames(Double, Double, Double) BoundedCurve.ToPolyline(Int32) BoundedCurve.GetSubdivisionParameters(Double, Double) BoundedCurve.PointAtNormalized(Double) BoundedCurve.TransformAtNormalized(Double) Curve.PointAt(Double) Curve.TransformAt(Double) Curve.Transformed(Transform) Curve.ParameterAtDistanceFromParameter(Double, Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public abstract class TrimmedCurve<TBasis> : BoundedCurve, ICurve, ITransformable<Curve>, IBoundedCurve, ITrimmedCurve<TBasis> where TBasis : ICurve Type Parameters Name Description TBasis Properties BasisCurve The basis curve for this bounded curve. Declaration [JsonIgnore] public TBasis BasisCurve { get; protected set; } Property Value Type Description TBasis Implements ICurve ITransformable<T> IBoundedCurve ITrimmedCurve<TBasis>"
  },
  "api/Elements.Geometry.UV.html": {
    "href": "api/Elements.Geometry.UV.html",
    "title": "Struct UV | Hypar Docs",
    "keywords": "Struct UV A UV coordinate. Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct UV Constructors UV(Double, Double) Construct a uv coordinate. Declaration [JsonConstructor] public UV(double u, double v) Parameters Type Name Description System.Double u The U coordinate. System.Double v The V coordinate. Properties U The U coordinate. Declaration [JsonProperty(\"U\", Required = Required.Always)] public double U { get; set; } Property Value Type Description System.Double V The V coordinate. Declaration [JsonProperty(\"V\", Required = Required.Always)] public double V { get; set; } Property Value Type Description System.Double Methods Equals(Object) Are the two uvs equal? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.ValueType.Equals(System.Object) GetHashCode() Get the hash code for the uv. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() ToString() A string representation of the uv. Declaration public override string ToString() Returns Type Description System.String Overrides System.ValueType.ToString() Operators Equality(UV, UV) Are the two UVs equal? Declaration public static bool operator ==(UV a, UV b) Parameters Type Name Description UV a UV b Returns Type Description System.Boolean Implicit((Double u, Double v) to UV) Automatically convert a tuple of two doubles into a UV. Declaration public static implicit operator UV((double u, double v) uv) Parameters Type Name Description System.ValueTuple < System.Double , System.Double > uv An (u,v) tuple of doubles. Returns Type Description UV Inequality(UV, UV) Are the two UVs equal? Declaration public static bool operator !=(UV a, UV b) Parameters Type Name Description UV a UV b Returns Type Description System.Boolean"
  },
  "api/Elements.Geometry.Vector3.html": {
    "href": "api/Elements.Geometry.Vector3.html",
    "title": "Struct Vector3 | Hypar Docs",
    "keywords": "Struct Vector3 A 3D vector. Implements System.IComparable < Vector3 > System.IEquatable < Vector3 > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public struct Vector3 : IComparable<Vector3>, IEquatable<Vector3> Constructors Vector3(Vector3) Create a Vector3 by copying the components of another Vector3. Declaration public Vector3(Vector3 v) Parameters Type Name Description Vector3 v The Vector3 to copy. Vector3(Double, Double) Create a vector from x, and y coordinates. Declaration public Vector3(double x, double y) Parameters Type Name Description System.Double x The x coordinate of the vector. System.Double y Thy y coordinate of the vector. Vector3(Double, Double, Double) Create a vector. Declaration [JsonConstructor] public Vector3(double x, double y, double z) Parameters Type Name Description System.Double x The x component. System.Double y The y component. System.Double z The z component. Fields COS_ANGLE_EPSILON A tolerance for angle comparison operation of cos of 0.001 degrees. Declaration public const double COS_ANGLE_EPSILON = 0.99999999984769128 Field Value Type Description System.Double EPSILON A tolerance for comparison operations of 1e-5. Declaration public const double EPSILON = 1E-05 Field Value Type Description System.Double Properties Max The largest possible value of a Vector3. Declaration public static readonly Vector3 Max { get; } Property Value Type Description Vector3 Min The smallest possible value of a Vector3. Declaration public static readonly Vector3 Min { get; } Property Value Type Description Vector3 Origin Create a vector at the origin. Declaration public static readonly Vector3 Origin { get; } Property Value Type Description Vector3 X The X component of the vector. Declaration [JsonProperty(\"X\", Required = Required.Always)] public double X { get; set; } Property Value Type Description System.Double XAxis Create a vector along the X axis. Declaration public static readonly Vector3 XAxis { get; } Property Value Type Description Vector3 Y The Y component of the vector. Declaration [JsonProperty(\"Y\", Required = Required.Always)] public double Y { get; set; } Property Value Type Description System.Double YAxis Create a vector along the Y axis. Declaration public static readonly Vector3 YAxis { get; } Property Value Type Description Vector3 Z The Z component of the vector. Declaration [JsonProperty(\"Z\", Required = Required.Always)] public double Z { get; set; } Property Value Type Description System.Double ZAxis Create a vector along the Z axis. Declaration public static readonly Vector3 ZAxis { get; } Property Value Type Description Vector3 Methods AngleTo(Vector3) The angle in degrees from this vector to the provided vector. Note that for angles in the plane that can be greater than 180 degrees, you should use Vector3.PlaneAngleTo. Declaration public double AngleTo(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to measure the angle. Returns Type Description System.Double The angle in degrees between 0 and 180. AreCollinear(Vector3, Vector3, Vector3) Check whether three points are on the same line. Declaration [Obsolete(\"Use AreCollinearByDistance or AreCollinearByAngle instead\")] public static bool AreCollinear(Vector3 a, Vector3 b, Vector3 c) Parameters Type Name Description Vector3 a The first point. Vector3 b The second point. Vector3 c The third point. Returns Type Description System.Boolean True if the points are on the same line, false otherwise. AreCollinearByAngle(Vector3, Vector3, Vector3, Double) Check whether three points are on the same line within certain angle. Order is important since unsigned abc angle is checked. This function is much faster than AreCollinearByDistance but angle deviation scales with the distance of points being compared. If points are far away from each other they might appear collinear even if there are large distance offsets between them. Declaration public static bool AreCollinearByAngle(Vector3 a, Vector3 b, Vector3 c, double cosAngleTolerance = 0.99999999984769128) Parameters Type Name Description Vector3 a The first point. Vector3 b The second point. Vector3 c The third point. System.Double cosAngleTolerance Angle tolerance as cos. Returns Type Description System.Boolean AreCollinearByDistance(Vector3, Vector3, Vector3, Double) Check whether three points are on the same line within certain distance. This function is slower than AreCollinearByAngle and less suitable for high complexity code. Declaration public static bool AreCollinearByDistance(Vector3 a, Vector3 b, Vector3 c, double tolerance = 1E-05) Parameters Type Name Description Vector3 a The first point. Vector3 b The second point. Vector3 c The third point. System.Double tolerance Distance tolerance. Returns Type Description System.Boolean True if the points are on the same line, false otherwise. AreCoplanar(Vector3, Vector3, Vector3, Vector3) Are four provided points on the same plane? Declaration public static bool AreCoplanar(Vector3 a, Vector3 b, Vector3 c, Vector3 d) Parameters Type Name Description Vector3 a Vector3 b Vector3 c Vector3 d Returns Type Description System.Boolean AtNEqualSpacesAlongLine(Line, Int32, Boolean) Create vectors at n equal spaces along the provided line. Declaration public static IList<Vector3> AtNEqualSpacesAlongLine(Line line, int n, bool includeEnds = false) Parameters Type Name Description Line line The line. System.Int32 n The number of samples along the line. System.Boolean includeEnds A flag indicating whether or not to include points for the start and end of the line. Returns Type Description System.Collections.Generic.IList < Vector3 > Average(Vector3) Compute the average of this Vector3 and v. Declaration public Vector3 Average(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to compute the average. Returns Type Description Vector3 A vector which is the average of this and v. CCW(Vector3, Vector3, Vector3) Check whether three points are wound CCW in two dimensions. Declaration public static double CCW(Vector3 a, Vector3 b, Vector3 c) Parameters Type Name Description Vector3 a The first point. Vector3 b The second point. Vector3 c The third point. Returns Type Description System.Double Greater than 0 if the points are CCW, less than 0 if they are CW, and 0 if they are collinear. ClosestPointOn(Line, Boolean) Get the closest point on the line from this point. Declaration public Vector3 ClosestPointOn(Line line, bool infinite = false) Parameters Type Name Description Line line The line on which to find the closest point. System.Boolean infinite If true, line will be treated as infinite. (False by default) Returns Type Description Vector3 The closest point on the line from this point. CompareTo(Vector3) Implement IComparable interface. Declaration public int CompareTo(Vector3 v) Parameters Type Name Description Vector3 v Returns Type Description System.Int32 ComputeDefaultBasisVectors() Compute basis vectors for this vector. By default, the cross product of the world Z axis and this vector are used to compute the U direction. If this vector is parallel the world Z axis, then the world Y axis is used instead. Declaration public (Vector3 U, Vector3 V) ComputeDefaultBasisVectors() Returns Type Description System.ValueTuple < Vector3 , Vector3 > Cross(Vector3) Compute the cross product of this vector and v. Declaration public Vector3 Cross(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to compute the cross product. Returns Type Description Vector3 Cross(Double, Double, Double) Compute the cross product of this vector and a vector composed of the provided components. Declaration public Vector3 Cross(double x, double y, double z) Parameters Type Name Description System.Double x X System.Double y Y System.Double z Z Returns Type Description Vector3 DistanceTo(Line) Find the distance from this point to the line. Declaration public double DistanceTo(Line line) Parameters Type Name Description Line line Returns Type Description System.Double DistanceTo(Line, out Vector3) Find the distance from this point to the line, and output the location of the closest point on that line. Using formula from https://diego.assencio.com/?index=ec3d5dfdfc0b6a0d147a656f0af332bd Declaration public double DistanceTo(Line line, out Vector3 closestPoint) Parameters Type Name Description Line line The line to find the distance to. Vector3 closestPoint The point on the line that is closest to this point. Returns Type Description System.Double DistanceTo(Plane) The distance from this point to the plane. The distance will be negative when this point lies \"behind\" the plane. Declaration public double DistanceTo(Plane p) Parameters Type Name Description Plane p The plane. Returns Type Description System.Double DistanceTo(Polygon) Find the shortest distance from this point to any point within the polygon Declaration public double DistanceTo(Polygon polygon) Parameters Type Name Description Polygon polygon The polygon for computing the distance Returns Type Description System.Double DistanceTo(Polygon, out Vector3) Find the shortest distance from this point to any point within the polygon, and output the location of the closest point on that polygon. Declaration public double DistanceTo(Polygon polygon, out Vector3 closestPoint) Parameters Type Name Description Polygon polygon The polygon for computing the distance Vector3 closestPoint Point within the polygon that is closest to this point Returns Type Description System.Double DistanceTo(Polyline) Find the shortest distance from this point to any point on the polyline, and output the location of the closest point on that polyline. Declaration public double DistanceTo(Polyline polyline) Parameters Type Name Description Polyline polyline The polyline for computing the distance. Returns Type Description System.Double DistanceTo(Polyline, out Vector3) Find the shortest distance from this point to any point on the polyline, and output the location of the closest point on that polyline. Declaration public double DistanceTo(Polyline polyline, out Vector3 closestPoint) Parameters Type Name Description Polyline polyline The polyline for computing the distance. Vector3 closestPoint The point on the polyline that is closest to this point. Returns Type Description System.Double DistanceTo(Ray) The distance from this point to the ray. The ray is treated as being infinitely long. Declaration public double DistanceTo(Ray ray) Parameters Type Name Description Ray ray The target ray. Returns Type Description System.Double DistanceTo(Vector3) The distance from this point to v. Declaration public double DistanceTo(Vector3 v) Parameters Type Name Description Vector3 v The target vector. Returns Type Description System.Double The distance between this vector and the provided vector. DistanceTo((Vector3 from, Vector3 to), out Vector3) Find the distance from this point to the edge, and output the location of the closest point on that line. Using formula from https://diego.assencio.com/?index=ec3d5dfdfc0b6a0d147a656f0af332bd Declaration public double DistanceTo((Vector3 from, Vector3 to) edge, out Vector3 closestPoint) Parameters Type Name Description System.ValueTuple < Vector3 , Vector3 > edge The edge to find the distance to. Vector3 closestPoint The point on the line that is closest to this point. Returns Type Description System.Double Dot(Vector3) Compute the dot product of this vector and v. Declaration public double Dot(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to compute the dot product. Returns Type Description System.Double A value between 1 and -1. Dot(Double, Double, Double) Compute the dot product of this vector and a vector composed of the provided components. Declaration public double Dot(double x, double y, double z) Parameters Type Name Description System.Double x X System.Double y Y System.Double z Z Returns Type Description System.Double A value between 1 and -1. Equals(Vector3) Is this vector equal to the provided vector? Declaration public bool Equals(Vector3 other) Parameters Type Name Description Vector3 other The vector to test. Returns Type Description System.Boolean Returns true if all components of the two vectors are within Epsilon, otherwise false. Equals(Object) Is this vector equal to the provided vector? Declaration public override bool Equals(object other) Parameters Type Name Description System.Object other The vector to test. Returns Type Description System.Boolean Returns true if all components of the two vectors are within Epsilon, otherwise false. Overrides System.ValueType.Equals(System.Object) GetHashCode() Get the hash code for the vector. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.ValueType.GetHashCode() IsAlmostEqualTo(Vector3, Double) Determine whether this vector's components are equal to those of v, within tolerance. Declaration public bool IsAlmostEqualTo(Vector3 v, double tolerance = 1E-05) Parameters Type Name Description Vector3 v The vector to compare. System.Double tolerance Optional custom tolerance value. Returns Type Description System.Boolean True if the difference of this vector and the supplied vector's components are all within Tolerance, otherwise false. IsAlmostEqualTo(Double, Double, Double) Determine whether this vector's components are equal to the provided components, within tolerance. Declaration public bool IsAlmostEqualTo(double x, double y, double z = 0) Parameters Type Name Description System.Double x The x component to compare. System.Double y The y component to compare. System.Double z The z component to compare. Returns Type Description System.Boolean True if the difference of this vector and the supplied vector's components are all within Tolerance, otherwise false. IsNaN() Are any components of this vector NaN? Declaration public bool IsNaN() Returns Type Description System.Boolean True if any components are NaN otherwise false. IsParallelTo(Vector3, Double) Determine whether this vector is parallel to v. Declaration public bool IsParallelTo(Vector3 v, double tolerance = 1E-05) Parameters Type Name Description Vector3 v The vector to compare to this vector. System.Double tolerance The amount of tolerance in the parallel comparison. Returns Type Description System.Boolean True if the vectors are parallel, otherwise false. IsUnitized() Is this vector of unit length? Declaration public bool IsUnitized() Returns Type Description System.Boolean True if the vector is of unit length, otherwise false. IsZero() Is this vector zero length? Declaration public bool IsZero() Returns Type Description System.Boolean True if this vector's components are all less than Epsilon. Length() Get the length of this vector. Declaration public double Length() Returns Type Description System.Double LengthSquared() Get the squared length of this vector. Declaration public double LengthSquared() Returns Type Description System.Double Negate() Construct a new vector which is the inverse of this vector. Declaration public Vector3 Negate() Returns Type Description Vector3 A new vector which is the inverse of this vector. PlaneAngleTo(Vector3) Calculate a counter-clockwise plane angle between this vector and the provided vector in the XY plane. Declaration public double PlaneAngleTo(Vector3 v) Parameters Type Name Description Vector3 v The vector with which to measure the angle. Returns Type Description System.Double Angle in degrees between 0 and 360, or NaN if the projected input vectors are invalid. PlaneAngleTo(Vector3, Vector3) Calculate a counter-clockwise plane angle between this vector and the provided vector, projected to the plane perpendicular to the provided normal. Declaration public double PlaneAngleTo(Vector3 v, Vector3 normal) Parameters Type Name Description Vector3 v The vector with which to measure the angle. Vector3 normal The normal of the plane in which you wish to calculate the angle. Returns Type Description System.Double Angle in degrees between 0 and 360, or NaN if the projected input vectors are invalid. Project(Plane) Project this vector onto the plane. Declaration public Vector3 Project(Plane p) Parameters Type Name Description Plane p The plane on which to project the point. Returns Type Description Vector3 ProjectAlong(Vector3, Plane) Project this vector onto the plane along a vector. Declaration public Vector3 ProjectAlong(Vector3 v, Plane p) Parameters Type Name Description Vector3 v The vector along which t project. Plane p The plane on which to project. Returns Type Description Vector3 A point on the plane. ProjectOnto(Vector3) Project vector a onto this vector. Declaration public Vector3 ProjectOnto(Vector3 a) Parameters Type Name Description Vector3 a The vector to project onto this vector. Returns Type Description Vector3 A new vector which is the projection of a onto this vector. ToArray() Convert a vector's components to an array. Declaration public double[] ToArray() Returns Type Description System.Double [] An array of comprised of the x, y, and z components of this vector. ToString() A string representation of the vector. Declaration public override string ToString() Returns Type Description System.String The string representation of this vector. Overrides System.ValueType.ToString() TripleProduct(Vector3, Vector3) Check if two vectors are coplanar. Declaration public double TripleProduct(Vector3 b, Vector3 c) Parameters Type Name Description Vector3 b The second vector. Vector3 c The third vector. Returns Type Description System.Double True is the vectors are coplanar, otherwise false. Unitized() Return a new vector which is the unitized version of this vector. Declaration public Vector3 Unitized() Returns Type Description Vector3 Operators Addition(Vector3, Vector3) Add two vectors. Declaration public static Vector3 operator +(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description Vector3 A vector which is the sum of a and b. Division(Vector3, Double) Divide a vector by a scalar. Declaration public static Vector3 operator /(Vector3 v, double a) Parameters Type Name Description Vector3 v The vector to divide. System.Double a The scalar divisor. Returns Type Description Vector3 A vector whose magnitude is multiplied by a. Equality(Vector3, Vector3) Are the two vectors the same within Epsilon? Declaration public static bool operator ==(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a Vector3 b Returns Type Description System.Boolean GreaterThan(Vector3, Vector3) Compute whether all components of vector a are greater than those of vector b. Declaration public static bool operator>(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description System.Boolean True if all of a's components are greater than those of b, otherwise false. GreaterThanOrEqual(Vector3, Vector3) Compute whether all components of vector a are greater than or equal to those of vector b. Declaration public static bool operator >=(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description System.Boolean True if all of a's components are greater than or equal to all of those of b, otherwise false. Implicit((Double X, Double Y, Double Z) to Vector3) Automatically convert a tuple of three doubles into a Vector3. Declaration public static implicit operator Vector3((double X, double Y, double Z) vector) Parameters Type Name Description System.ValueTuple < System.Double , System.Double , System.Double > vector An (X,Y,Z) tuple of doubles. Returns Type Description Vector3 Implicit((Double X, Double Y) to Vector3) Automatically convert a tuple of two doubles into a Vector3. Declaration public static implicit operator Vector3((double X, double Y) vector) Parameters Type Name Description System.ValueTuple < System.Double , System.Double > vector An (X,Y) tuple of doubles. Returns Type Description Vector3 Implicit((Int32 X, Int32 Y, Int32 Z) to Vector3) Automatically convert a tuple of three ints into a Vector3. Declaration public static implicit operator Vector3((int X, int Y, int Z) vector) Parameters Type Name Description System.ValueTuple < System.Int32 , System.Int32 , System.Int32 > vector An (X,Y,Z) tuple of ints. Returns Type Description Vector3 Implicit((Int32 X, Int32 Y) to Vector3) Automatically convert a tuple of two ints into a Vector3. Declaration public static implicit operator Vector3((int X, int Y) vector) Parameters Type Name Description System.ValueTuple < System.Int32 , System.Int32 > vector An (X,Y) tuple of ints. Returns Type Description Vector3 Inequality(Vector3, Vector3) Are the two vectors not the same within Epsilon? Declaration public static bool operator !=(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a Vector3 b Returns Type Description System.Boolean LessThan(Vector3, Vector3) Compute whether all components of vector a are less than those of vector b. Declaration public static bool operator <(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description System.Boolean True if all of a's components are less than those of b, otherwise false. LessThanOrEqual(Vector3, Vector3) Compute whether all components of vector a are less than or equal to those of vector b. Declaration public static bool operator <=(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description System.Boolean True if all of a's components are less than or equal to all of those of b, otherwise false. Multiply(Vector3, Double) Multiply a vector and a scalar. Declaration public static Vector3 operator *(Vector3 v, double a) Parameters Type Name Description Vector3 v The vector to multiply. System.Double a The scalar value to multiply. Returns Type Description Vector3 A vector whose magnitude is multiplied by a. Multiply(Double, Vector3) Multiply a scalar and a vector. Declaration public static Vector3 operator *(double a, Vector3 v) Parameters Type Name Description System.Double a The scalar value to multiply. Vector3 v The vector to multiply. Returns Type Description Vector3 A vector whose magnitude is multiplied by a. Subtraction(Vector3, Vector3) Subtract two vectors. Declaration public static Vector3 operator -(Vector3 a, Vector3 b) Parameters Type Name Description Vector3 a The first vector. Vector3 b The second vector. Returns Type Description Vector3 A vector which is the difference between a and b. Implements System.IComparable<T> System.IEquatable<T>"
  },
  "api/Elements.Geometry.Vector3Extensions.html": {
    "href": "api/Elements.Geometry.Vector3Extensions.html",
    "title": "Class Vector3Extensions | Hypar Docs",
    "keywords": "Class Vector3Extensions Extension methods for Vector3. Inheritance System.Object Vector3Extensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public static class Vector3Extensions Methods AreCollinear(IList<Vector3>) Are the provided points along the same line? Declaration [Obsolete(\"Use AreCollinearByDistance instead\")] public static bool AreCollinear(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points Returns Type Description System.Boolean AreCollinearByDistance(IList<Vector3>, Double) Check whether three points are on the same line withing certain distance. Declaration public static bool AreCollinearByDistance(this IList<Vector3> points, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points List of points to check. Order is not important. System.Double tolerance Distance tolerance. Returns Type Description System.Boolean AreCoplanar(IList<Vector3>, Double) Are the provided points on the same plane, within tolerance? Declaration public static bool AreCoplanar(this IList<Vector3> points, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points to test. System.Double tolerance Acceptable deviation from the plane while still being considered coplanar. Returns Type Description System.Boolean Remarks This method uses the first three non-collinear points to define the plane, rather than a best-fit plane. We may return a false negative in the case that there is a different best-fit plane that is within tolerance of all points. Average(IEnumerable<Vector3>) Find the average of a collection of Vector3. Declaration public static Vector3 Average(this IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The Vector3 collection to average. Returns Type Description Vector3 A Vector3 representing the average. BestFitLine(IList<Vector3>) Return an approximate fit line through a set of points using the least squares method. Declaration public static Line BestFitLine(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points to fit. Should have at least 2 distinct points. Returns Type Description Line An approximate fit line through a set of points using the least squares method. If there is less than 2 distinct points, returns null. FitLine(IList<Vector3>) Return an approximate fit line through a set of points. Not intended for statistical regression purposes. Note that the line is unit length: it shouldn't be expected to span the length of the points. Declaration public static Line FitLine(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The points to fit. Returns Type Description Line A line roughly running through the set of points, or null if the points are nearly coincident. Shrink(Vector3[], Double) Shrink a collection of Vector3 towards their average. Declaration public static Vector3[] Shrink(this Vector3[] points, double distance) Parameters Type Name Description Vector3 [] points The collection of Vector3 to shrink. System.Double distance The distance to shrink along the vector to average. Returns Type Description Vector3 [] ToArray(IList<Vector3>) Convert a collection of Vector3 to a flat array of double. Declaration public static double[] ToArray(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The collection of Vector3 to convert. Returns Type Description System.Double [] An array containing x,y,z,x1,y1,z1,x2,y2,z2,... ToGraphicsBuffers(IList<Vector3>) Convert a list of vertices to a GraphicsBuffers object. Declaration public static GraphicsBuffers ToGraphicsBuffers(this IList<Vector3> vertices) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > vertices The vertices to convert. Returns Type Description GraphicsBuffers ToTransform(IList<Vector3>) Compute a transform with the origin at points[0], with an X axis along points[1]->points[0], and a normal computed using the vectors points[2]->points[1] and points[1]->points[0]. Declaration public static Transform ToTransform(this IList<Vector3> points) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points Returns Type Description Transform TryGetThreeNonCollinearPoints(IList<Vector3>, out Int32, out Int32) Check if a collection of points has at least three non-collinear points. Returns true if it does, false otherwise. The first two points which form a valid triangle with the first point are returned via out parameters. Declaration public static bool TryGetThreeNonCollinearPoints(this IList<Vector3> points, out int p1Index, out int p2Index) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points The list of points to search. System.Int32 p1Index The index of the first non-collinear point after index 0. System.Int32 p2Index The index of the second non-collinear point after index 0. Returns Type Description System.Boolean True if there are three non-collinear points. UniqueWithinTolerance(IEnumerable<Vector3>, Double) De-duplicate a collection of Vectors, such that no two vectors in the result are within tolerance of each other. Declaration public static IEnumerable<Vector3> UniqueWithinTolerance(this IEnumerable<Vector3> vectors, double tolerance = 1E-05) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > vectors List of vectors System.Double tolerance Distance tolerance Returns Type Description System.Collections.Generic.IEnumerable < Vector3 > A new collection of vectors with duplicates removed."
  },
  "api/Elements.Geometry.Vertex.html": {
    "href": "api/Elements.Geometry.Vertex.html",
    "title": "Class Vertex | Hypar Docs",
    "keywords": "Class Vertex A mesh vertex. Inheritance System.Object Vertex Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public class Vertex Constructors Vertex(Vector3, Vector3, Color, Int32, UV) Construct a vertex. Declaration [JsonConstructor] public Vertex(Vector3 position, Vector3 normal, Color color, int index, UV uv) Parameters Type Name Description Vector3 position The position of the vertex. Vector3 normal The normal of the vertex. Color color The color of the vertex. System.Int32 index The index of the vertex. UV uv The uv coordinate of the vertex. Vertex(Vector3, Nullable<Vector3>, Color) Create a vertex. Declaration public Vertex(Vector3 position, Vector3? normal = null, Color color = default(Color)) Parameters Type Name Description Vector3 position The position of the vertex. System.Nullable < Vector3 > normal The vertex's normal. Color color The vertex's color. Properties Color The vertex's color. Declaration [JsonProperty(\"Color\", Required = Required.Always)] [Required] public Color Color { get; set; } Property Value Type Description Color Index The index of the vertex within a mesh. Declaration [JsonProperty(\"Index\", Required = Required.Always)] public int Index { get; set; } Property Value Type Description System.Int32 Normal The vertex's normal. Declaration [JsonProperty(\"Normal\", Required = Required.AllowNull)] public Vector3 Normal { get; set; } Property Value Type Description Vector3 Position The vertex's position. Declaration [JsonProperty(\"Position\", Required = Required.AllowNull)] public Vector3 Position { get; set; } Property Value Type Description Vector3 Tag A tag used to map a mesh vertex to a vertex of a CSG or a solid. Declaration [JsonIgnore] public int Tag { get; set; } Property Value Type Description System.Int32 Triangles The triangles associated with this vertex. Declaration [JsonProperty(\"Triangles\", Required = Required.Always)] [Required] [JsonIgnore] public IList<Triangle> Triangles { get; set; } Property Value Type Description System.Collections.Generic.IList < Triangle > UV The vertex's texture coordinate. Declaration [JsonProperty(\"UV\", Required = Required.Always)] [Required] public UV UV { get; set; } Property Value Type Description UV"
  },
  "api/Elements.Geometry.VoidTreatment.html": {
    "href": "api/Elements.Geometry.VoidTreatment.html",
    "title": "Enum VoidTreatment | Hypar Docs",
    "keywords": "Enum VoidTreatment Controls the handling of internal regions in a polygon boolean operation. Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum VoidTreatment Fields Name Description IgnoreInternalVoids Treat all contained or overlapping polygons as solid. This corresponds to Clipper's \"Positive\" PolyFillType. PreserveInternalVoids Use an Even/Odd fill pattern to decide whether internal polygons are solid or void. This corresponds to Clipper's \"EvenOdd\" PolyFillType."
  },
  "api/Elements.Geometry.WideFlangeProfileType.html": {
    "href": "api/Elements.Geometry.WideFlangeProfileType.html",
    "title": "Enum WideFlangeProfileType | Hypar Docs",
    "keywords": "Enum WideFlangeProfileType Namespace : Elements.Geometry Assembly : Hypar.Elements.dll Syntax public enum WideFlangeProfileType Fields Name Description W10x100 W10x112 W10x12 W10x15 W10x17 W10x19 W10x22 W10x26 W10x30 W10x33 W10x39 W10x45 W10x49 W10x54 W10x60 W10x68 W10x77 W10x88 W12x106 W12x120 W12x136 W12x14 W12x152 W12x16 W12x170 W12x19 W12x190 W12x210 W12x22 W12x230 W12x252 W12x26 W12x279 W12x30 W12x305 W12x336 W12x35 W12x40 W12x45 W12x50 W12x53 W12x58 W12x65 W12x72 W12x79 W12x87 W12x96 W14x109 W14x120 W14x132 W14x145 W14x159 W14x176 W14x193 W14x211 W14x22 W14x233 W14x257 W14x26 W14x283 W14x30 W14x311 W14x34 W14x342 W14x370 W14x38 W14x398 W14x426 W14x43 W14x455 W14x48 W14x500 W14x53 W14x550 W14x605 W14x61 W14x665 W14x68 W14x730 W14x74 W14x808 W14x82 W14x90 W14x99 W16x100 W16x26 W16x31 W16x36 W16x40 W16x45 W16x50 W16x57 W16x67 W16x77 W16x89 W18x106 W18x119 W18x130 W18x143 W18x158 W18x175 W18x192 W18x211 W18x234 W18x258 W18x283 W18x311 W18x35 W18x40 W18x46 W18x50 W18x55 W18x60 W18x65 W18x71 W18x76 W18x86 W18x97 W21x101 W21x111 W21x122 W21x132 W21x147 W21x166 W21x182 W21x201 W21x223 W21x248 W21x275 W21x300 W21x333 W21x364 W21x402 W21x44 W21x48 W21x50 W21x55 W21x57 W21x62 W21x68 W21x73 W21x83 W21x93 W24x103 W24x104 W24x117 W24x131 W24x146 W24x162 W24x176 W24x192 W24x207 W24x229 W24x250 W24x279 W24x306 W24x335 W24x370 W24x408 W24x450 W24x492 W24x55 W24x62 W24x68 W24x76 W24x84 W24x94 W27x102 W27x114 W27x129 W27x146 W27x161 W27x178 W27x194 W27x217 W27x235 W27x258 W27x281 W27x307 W27x336 W27x368 W27x407 W27x448 W27x494 W27x539 W27x84 W27x94 W30x108 W30x116 W30x124 W30x132 W30x148 W30x173 W30x191 W30x211 W30x235 W30x261 W30x292 W30x326 W30x357 W30x391 W30x433 W30x477 W30x526 W30x581 W30x90 W30x99 W33x118 W33x130 W33x141 W33x152 W33x169 W33x201 W33x221 W33x241 W33x263 W33x291 W33x318 W33x354 W33x387 W33x424 W33x468 W33x515 W33x567 W33x619 W36x135 W36x150 W36x160 W36x170 W36x182 W36x194 W36x210 W36x230 W36x232 W36x245 W36x256 W36x260 W36x280 W36x300 W36x328 W36x359 W36x393 W36x439 W36x485 W36x527 W36x588 W36x650 W36x720 W36x798 W36x848 W40x149 W40x167 W40x174 W40x183 W40x192 W40x199 W40x211 W40x215 W40x221 W40x235 W40x244 W40x249 W40x264 W40x268 W40x277 W40x278 W40x297 W40x298 W40x321 W40x324 W40x327 W40x328 W40x331 W40x362 W40x372 W40x392 W40x397 W40x431 W40x436 W40x466 W40x480 W40x503 W40x531 W40x593 W40x655 W44x198 W44X224 W44x230 W44x248 W44x262 W44x285 W44x290 W44x335 W4x13 W5x16 W5x19 W6x12 W6x15 W6x16 W6x20 W6x25 W6x8_5 W6x9 W8x10 W8x13 W8x15 W8x18 W8x21 W8x24 W8x28 W8x31 W8x35 W8x40 W8x48 W8x58 W8x67"
  },
  "api/Elements.GeometryReference.html": {
    "href": "api/Elements.GeometryReference.html",
    "title": "Class GeometryReference | Hypar Docs",
    "keywords": "Class GeometryReference A reference to a model, hosted at a URL. Inheritance System.Object GeometryReference Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class GeometryReference Constructors GeometryReference(String, IList<Object>) Construct a geometry reference. Declaration [JsonConstructor] public GeometryReference(string geometryUrl, IList<object> internalGeometry) Parameters Type Name Description System.String geometryUrl The url of the referenced geometry. System.Collections.Generic.IList < System.Object > internalGeometry Geometry containe in this reference. Properties GeometryUrl The URL where the referenced geometry is hosted. Declaration [JsonProperty(\"GeometryUrl\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public string GeometryUrl { get; set; } Property Value Type Description System.String InternalGeometry Any geometric data directly contained in this reference. Declaration [JsonProperty(\"InternalGeometry\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public IList<object> InternalGeometry { get; set; } Property Value Type Description System.Collections.Generic.IList < System.Object >"
  },
  "api/Elements.GridLine.html": {
    "href": "api/Elements.GridLine.html",
    "title": "Class GridLine | Hypar Docs",
    "keywords": "Class GridLine An architectural or structural gridline. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_GridLine.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var gridData = new List<(string name, Vector3 origin)>() { (\"A\", new Vector3()), (\"B\", new Vector3(10, 0, 0)), (\"C\", new Vector3(20, 0, 0)), (\"D\", new Vector3(30, 0, 0)), }; var texts = new List<(Vector3 location, Vector3 facingDirection, Vector3 lineDirection, string text, Color? color)>(); var radius = 1; var material = new Material(\"Red\", Colors.Red); foreach (var (name, origin) in gridData) { var gridline = new GridLine { Name = name, Curve = new Line(origin, origin + new Vector3(25, 25, 0)), Material = material, Radius = radius }; gridline.AddTextToCollection(texts, Colors.Black); this.Model.AddElement(gridline); } Inheritance System.Object Element GeometricElement GridLine Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class GridLine : GeometricElement, INotifyPropertyChanged Fields ExtensionBeginning How far to extend the gridline from the beginning to the start of the circle. Declaration public double ExtensionBeginning Field Value Type Description System.Double ExtensionEnd How far to extend the gridline past the end of the circle. Declaration public double ExtensionEnd Field Value Type Description System.Double Radius Radius of the gridline head. Declaration public double Radius Field Value Type Description System.Double Properties Curve Curve that runs from the start of the gridline to its end. Declaration public BoundedCurve Curve { get; set; } Property Value Type Description BoundedCurve Geometry The polyline that runs from the start of the gridline to its end. Declaration [Obsolete(\"We now use 'Curve' instead.\")] public Polyline Geometry { get; set; } Property Value Type Description Polyline Line Line that runs from the start of the gridline to its end. Declaration [Obsolete(\"We now use 'Curve' instead.\")] public Line Line { get; set; } Property Value Type Description Line Methods AddTextToCollection(List<(Vector3 location, Vector3 facingDirection, Vector3 lineDirection, String text, Nullable<Color> color)>, Nullable<Color>) Add gridline's text data to a text collection for insertion into ModelText. Declaration public void AddTextToCollection(List<(Vector3 location, Vector3 facingDirection, Vector3 lineDirection, string text, Color? color)> texts, Color? color = null) Parameters Type Name Description System.Collections.Generic.List < System.ValueTuple < Vector3 , Vector3 , Vector3 , System.String , System.Nullable < Color >>> texts Collection of texts to add to. System.Nullable < Color > color Color for this text. GetCircleTransform() Get the transform of the circle created by the gridline. Declaration public Transform GetCircleTransform() Returns Type Description Transform TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Get graphics buffers and other metadata required to modify a GLB. Declaration public override bool TryToGraphicsBuffers(out List<GraphicsBuffers> graphicsBuffers, out string id, out MeshPrimitive.ModeEnum? mode) Parameters Type Name Description System.Collections.Generic.List < GraphicsBuffers > graphicsBuffers System.String id System.Nullable < glTFLoader.Schema.MeshPrimitive.ModeEnum > mode Returns Type Description System.Boolean True if there is graphicsbuffers data applicable to add, false otherwise. Out variables should be ignored if the return value is false. Overrides GeometricElement.TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.html": {
    "href": "api/Elements.html",
    "title": "Namespace Elements | Hypar Docs",
    "keywords": "Namespace Elements Classes BaseCeiling The base class for all ceilings. BaseError Represents error that occur during application execution Beam A structural framing element defined by a center line curve and a profile. Brace A Brace is a structural framing element which is often diagonal. BuiltInMaterials Built in materials. Column A vertical structural framing element. ContentCatalog A collection of content elements. ContentElement An element representing user content. DirectionalLight A directional light. DomainExtensions Extension and utility methods for mathematical operations. EdgeDisplaySettings Settings for how a curve or line should be displayed. Element An object which is identified with a unique identifier and a name. ElementError Represents error that occur inside an element during application execution ElementInstance An instance of an element in the model. Instances point to one instance of a type, but have individual ids and transforms. ElementProxy Wrapper/utilities for ElementProxy generics. ElementProxy<T> Proxy for an element from another function. This is used to attach additional information to upstream elements. Proxies created via Element.Proxy() are intended to be reused, so we are not creating multiple proxies for each element. Proxies deserialized from other functions are not added to the current proxy cache, so that each function will create its own, new proxies for each element. ElementProxyExtensions Extension methods for element proxies. Floor A floor is a horizontal element defined by a profile. Frame An element defined by a perimeter and a cross section swept along that perimeter. GeometricElement An element with a geometric representation. GeometryReference A reference to a model, hosted at a URL. GridLine An architectural or structural gridline. Identity Methods for discovering and tracking stable identifiers for Elements. ImportMeshElement An element definition whose representation is provided by an imported mesh like an STL. Joist A joist. Light Base class for all lights. MappingBase The base class for all mapping classes. A mapping specifies additional data utilized to translate an element to a different application context or platform. Mass An extruded volume. Material A material with red, green, blue, alpha, and metallic factor components. MeshElement An element whose representation is provided by a mesh. Model A container for elements. ModelArrows A collection of arrows which are visible in 3D. ModelCurve A curve which is visible in 3D. ModelCurveExtensions Extension methods for model curves. ModelExtensions ModelLines A collection of lines which are visible in 3D. ModelPoints A collection of points which are visible in 3D. ModelText A collection of text tags which are visible in 3D. OpenCeiling A ceiling that has no physical geometry, but still defines a perimeter and an elevation. Opening A polygonal opening. An opening's placement is defined by the x and y coordinates. The direction of the opening corresponds to the +Z axis of the transform. Panel A zero-thickness planar element defined by a perimeter. PointLight A point light. PriorityQueue<T> PriorityQueue is a collection that allows you to retrieve the item with the lowest priority in constant time and be able update priority of an item with log complexity. Items are unique within the collection but priorities can have duplicate values. RandomExtensions Extension methods for generating new random objects from an instance of System.Random. SetOperations Operations on sets of edges. SolidCeiling A ceiling defined by a planar profile extruded to a thickness. Space An extruded region of occupiable space. SpotLight A spot light. StandardWall A wall defined by a planar curve, a height, and a thickness. StringExtensions String utilities and extension methods. StructuralFraming A structural element with a profile swept along a curve. Symbol An alternate representation of an object. TiledCeiling A tiled ceiling. Topography A topographic mesh defined by an array of elevation values. Units Unit conversions and utilities. Wall A wall defined by a planar profile extruded to a height. WallByProfile A wall drawn using the elevation profile Structs Domain1d A 1 dimensional interval or domain. Interfaces IOverride An override value object Enums CoplanarSetClassification Coplanar classification. EdgeDisplayDashMode Different ways to interpret the Width property of a EdgeDisplaySettings. EdgeDisplayWidthMode Different ways to interpret the Width property of a EdgeDisplaySettings. FontSize Model text font sizes. LightType A light type. LocalClassification A local set classification. SetClassification A set containment classification. SymbolCameraPosition An enumeration of typical camera positions. Units.CardinalDirection Cardinal directions. Units.LengthUnit Units of length. Units.UnitType Unit types."
  },
  "api/Elements.Identity.html": {
    "href": "api/Elements.Identity.html",
    "title": "Class Identity | Hypar Docs",
    "keywords": "Class Identity Methods for discovering and tracking stable identifiers for Elements. Inheritance System.Object Identity Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class Identity Methods AddOverrideIdentity(Element, IOverride) Track that an element was affected by a specific override. Declaration public static void AddOverrideIdentity(this Element element, IOverride overrideObject) Parameters Type Name Description Element element IOverride overrideObject AddOverrideIdentity(Element, String, String, Object) Track that an element was affected by a specific override. Declaration public static void AddOverrideIdentity(this Element element, string overrideName, string overrideId, object overrideIdentity) Parameters Type Name Description Element element The element that was overridden. System.String overrideName The name of the override property, from the hypar.json. System.String overrideId The unique ID of the specific override within overrideName that is associated with this element. System.Object overrideIdentity The identity object that the override used to describe the object. AddOverrideValue(Element, String, Object) Add the final values used from an override to an element or proxy. This is only required if the override schema does not reflect the element schema, or if the properties within the override were not added directly to additionalProperties. In the earlier two cases, the data on the element within the schema or in additionalProperties will be used as the current values for override. Declaration public static void AddOverrideValue(this Element element, string overrideName, object overrideValue) Parameters Type Name Description Element element System.String overrideName System.Object overrideValue OverrideIds<T>(Element, String) Get the IDs of all overrides of this type that were already attached using AddOverrideIdentity to this element. Declaration public static List<string> OverrideIds<T>(this Element element, string overrideName) Parameters Type Name Description Element element System.String overrideName Returns Type Description System.Collections.Generic.List < System.String > Type Parameters Name Description T"
  },
  "api/Elements.ImportMeshElement.html": {
    "href": "api/Elements.ImportMeshElement.html",
    "title": "Class ImportMeshElement | Hypar Docs",
    "keywords": "Class ImportMeshElement An element definition whose representation is provided by an imported mesh like an STL. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ImportMeshElement.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var path = \"../../../models/STL/Hilti_2008782_Speed lock clevis hanger MH-SLC 2_ EG_2.stl\"; var shiny = new Material(\"shiny\", Colors.Red, 1.0, 0.9); var bracket = new ImportMeshElement(path, Units.LengthUnit.Millimeter, shiny); model.AddElement(bracket); var brackets = new List<ElementInstance>(); for (var u = 0; u < 360.0; u += 20) { var t = new Transform(new Vector3(1, 0, 0)); t.Rotate(Vector3.ZAxis, u); var instance = bracket.CreateInstance(t, $\"Component_{u}\"); model.AddElement(instance); } Inheritance System.Object Element GeometricElement MeshElement ImportMeshElement Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members MeshElement._mesh MeshElement.Mesh MeshElement.Tessellate(Mesh, Transform, Color) GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public sealed class ImportMeshElement : MeshElement, INotifyPropertyChanged, ITessellate Constructors ImportMeshElement(String, Units.LengthUnit, Material, Guid, String) Construct an import mesh element. Declaration public ImportMeshElement(string path, Units.LengthUnit lengthUnit, Material material = null, Guid id = default(Guid), string name = null) Parameters Type Name Description System.String path The path to the element's mesh on disk. Units.LengthUnit lengthUnit The length unit used in the provided mesh. Material material The element's material. System.Guid id The element's id. System.String name The element's name. Properties Path The path to the element's mesh on disk. Declaration public string Path { get; } Property Value Type Description System.String Implements System.ComponentModel.INotifyPropertyChanged ITessellate Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Interfaces.html": {
    "href": "api/Elements.Interfaces.html",
    "title": "Namespace Elements.Interfaces | Hypar Docs",
    "keywords": "Namespace Elements.Interfaces Interfaces IHasOpenings"
  },
  "api/Elements.Interfaces.IHasOpenings.html": {
    "href": "api/Elements.Interfaces.IHasOpenings.html",
    "title": "Interface IHasOpenings | Hypar Docs",
    "keywords": "Interface IHasOpenings Namespace : Elements.Interfaces Assembly : Hypar.Elements.dll Syntax public interface IHasOpenings Properties Openings A collection of openings. Declaration List<Opening> Openings { get; } Property Value Type Description System.Collections.Generic.List < Opening >"
  },
  "api/Elements.IOverride.html": {
    "href": "api/Elements.IOverride.html",
    "title": "Interface IOverride | Hypar Docs",
    "keywords": "Interface IOverride An override value object Namespace : Elements Assembly : Hypar.Elements.dll Syntax public interface IOverride Properties Id The override Id Declaration string Id { get; set; } Property Value Type Description System.String Methods GetIdentity() The override's identity Declaration object GetIdentity() Returns Type Description System.Object GetName() The name of the override Declaration string GetName() Returns Type Description System.String"
  },
  "api/Elements.Joist.html": {
    "href": "api/Elements.Joist.html",
    "title": "Class Joist | Hypar Docs",
    "keywords": "Class Joist A joist. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Joist.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples Inheritance System.Object Element GeometricElement StructuralFraming Joist Implements System.ComponentModel.INotifyPropertyChanged Inherited Members StructuralFraming.Curve StructuralFraming.StartSetback StructuralFraming.EndSetback StructuralFraming.Profile StructuralFraming.Rotation StructuralFraming.Volume() StructuralFraming.ProfileTransformed() GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Joist : StructuralFraming, INotifyPropertyChanged Constructors Joist(Line, LProfile, LProfile, LProfile, Double, Int32, Double, Double, Material, String, Guid) Construct a new BarJoist. Declaration [JsonConstructor] public Joist(Line curve, LProfile topChordProfile, LProfile bottomChordProfile, LProfile webProfile, double depth, int cellCount, double seatDepth, double distanceToFirstPanel, Material material, string name = null, Guid id = default(Guid)) Parameters Type Name Description Line curve The centerline of the joist. LProfile topChordProfile The top chord profile of the joist. LProfile bottomChordProfile The bottom chord profile of the joist. LProfile webProfile The web profile of the joist. System.Double depth The depth of the joist. System.Int32 cellCount The cell count of the joist. System.Double seatDepth The seat depth of the joist. System.Double distanceToFirstPanel The distance to the first panel of the joist (Y). Material material The joist's material. System.String name The name of the joist. System.Guid id The unique identifier of the joist. Properties BottomChordProfile Profile of the bottom chord of the joist. Declaration public LProfile BottomChordProfile { get; set; } Property Value Type Description LProfile CellCount The number of cells in the joist. Declaration public int CellCount { get; set; } Property Value Type Description System.Int32 Depth The depth of the joist. Declaration public double Depth { get; set; } Property Value Type Description System.Double DistanceToFirstPanel The distance to the first panel (Y). Declaration public double DistanceToFirstPanel { get; set; } Property Value Type Description System.Double JoistPoints The joist support points along the top of the joist. Declaration public List<Vector3> JoistPoints { get; set; } Property Value Type Description System.Collections.Generic.List < Vector3 > SeatDepth The seat depth of the joist. Declaration public double SeatDepth { get; set; } Property Value Type Description System.Double TopChordProfile Profile of the top chord of the joist. Declaration public LProfile TopChordProfile { get; set; } Property Value Type Description LProfile WebProfile Profile of the web of the joist. Declaration public LProfile WebProfile { get; set; } Property Value Type Description LProfile Methods UpdateRepresentations() Update the bar joist's representation. Declaration public override void UpdateRepresentations() Overrides StructuralFraming.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Light.html": {
    "href": "api/Elements.Light.html",
    "title": "Class Light | Hypar Docs",
    "keywords": "Class Light Base class for all lights. Inheritance System.Object Element Light DirectionalLight PointLight SpotLight Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public abstract class Light : Element, INotifyPropertyChanged Constructors Light(Double, Color, Transform, Guid, String) Construct a light. Declaration public Light(double intensity, Color color, Transform transform, Guid id, string name) Parameters Type Name Description System.Double intensity The intensity of the light. Color color The color of the light. Transform transform The transform of the light. System.Guid id The unique identifier of the light. System.String name The name of the light. Properties Color The color of the light. The color's alpha value will be ignored. Declaration public Color Color { get; set; } Property Value Type Description Color Intensity The intensity of the light measured in lux. Declaration public double Intensity { get; set; } Property Value Type Description System.Double LightType The type of the light. Declaration public LightType LightType { get; set; } Property Value Type Description LightType Transform The light's transform. The light will be aimed along the transform's -Z axis. Declaration public Transform Transform { get; set; } Property Value Type Description Transform Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.LightType.html": {
    "href": "api/Elements.LightType.html",
    "title": "Enum LightType | Hypar Docs",
    "keywords": "Enum LightType A light type. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum LightType Fields Name Description Directional A directional light. Point A point light. Spot A spot light. Undefined An undefined light type."
  },
  "api/Elements.LocalClassification.html": {
    "href": "api/Elements.LocalClassification.html",
    "title": "Enum LocalClassification | Hypar Docs",
    "keywords": "Enum LocalClassification A local set classification. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum LocalClassification Fields Name Description Inside Inside. Outside Outside."
  },
  "api/Elements.MappingBase.html": {
    "href": "api/Elements.MappingBase.html",
    "title": "Class MappingBase | Hypar Docs",
    "keywords": "Class MappingBase The base class for all mapping classes. A mapping specifies additional data utilized to translate an element to a different application context or platform. Inheritance System.Object Element MappingBase Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public abstract class MappingBase : Element, INotifyPropertyChanged Constructors MappingBase() The default empty constructor. Declaration public MappingBase() MappingBase(Guid, String) The default constructor. Declaration public MappingBase(Guid id, string name) Parameters Type Name Description System.Guid id System.String name Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Mass.html": {
    "href": "api/Elements.Mass.html",
    "title": "Class Mass | Hypar Docs",
    "keywords": "Class Mass An extruded volume. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Mass.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(); var b = new Vector3(30, 10); var c = new Vector3(20, 50); var d = new Vector3(-10, 5); var poly = new Polygon(new[] { a, b, c, d }); // Create a mass. var mass = new Mass(poly, 5.0); Inheritance System.Object Element GeometricElement Mass Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Mass : GeometricElement, INotifyPropertyChanged Constructors Mass(Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a Mass. Declaration public Mass(Profile profile, double height = 1, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The profile of the mass. System.Double height The height of the mass from the bottom elevation. Material material The mass' material. The default is the built in mass material. Transform transform The mass' transform. Representation representation The mass' representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the mass. System.String name The name of the mass. Properties Height The height of the mass. Declaration public double Height { get; set; } Property Value Type Description System.Double Profile The profile of the mass. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Thickness The thickness of the mass' extrusion. Declaration [JsonIgnore] public double Thickness { get; } Property Value Type Description System.Double Methods ProfileTransformed() Get the profile of the mass transformed by the mass' transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() The volume of the mass. Declaration public double Volume() Returns Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Material.html": {
    "href": "api/Elements.Material.html",
    "title": "Class Material | Hypar Docs",
    "keywords": "Class Material A material with red, green, blue, alpha, and metallic factor components. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Material.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var x = 0.0; var y = 0.0; var z = 0.0; var specularFactor = 0.0; var glossinessFactor = 0.0; var textData = new List<(Vector3, Vector3, Vector3, string, Color?)>(); var sphere = Mesh.Sphere(0.5, 20); for (var r = 0.0; r <= 1.0; r += 0.2) { for (var g = 0.0; g <= 1.0; g += 0.2) { if (r == 0) { textData.Add((new Vector3(-1.5, y), Vector3.ZAxis, Vector3.XAxis, $\"roughness: {1 - glossinessFactor:f2}\", Colors.Black)); } if (g == 0) { textData.Add((new Vector3(x, -1), Vector3.ZAxis, Vector3.XAxis, $\"specular: {specularFactor:f2}\", Colors.Black)); } for (var b = 0.0; b <= 1.0; b += 0.2) { var color = new Color(r, g, b, 1 - b); if (r == 1.0 && g == 0.0) { textData.Add((new Vector3(x + 1.5, y, z), Vector3.YAxis.Negate(), Vector3.XAxis, $\"alpha: {color.Alpha:f2}\", Colors.Black)); } var material = new Material($\"{r}_{g}_{b}\", color, specularFactor, glossinessFactor); Model.AddElement(new MeshElement(sphere, new Transform(new Vector3(x, y, z)), material)); z += 2.0; } z = 0; y += 2.0; glossinessFactor += 0.2; } glossinessFactor = 0.0; y = 0; x += 2.0; specularFactor += 0.2; } Model.AddElement(new ModelText(textData, FontSize.PT72)); Inheritance System.Object Element Material Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Material : Element, INotifyPropertyChanged Constructors Material() Construct a material. Declaration public Material() Material(Color, Double, Double, Boolean, String, Boolean, Boolean, String, Boolean, String, Double, Boolean, Guid, String) Construct a material. Declaration [JsonConstructor] public Material(Color color, double specularFactor, double glossinessFactor, bool unlit, string texture, bool doubleSided, bool repeatTexture, string normalTexture, bool interpolateTexture, string emissiveTexture, double emissiveFactor, bool drawInFront, Guid id = default(Guid), string name = null) Parameters Type Name Description Color color The color component. System.Double specularFactor The specular component. System.Double glossinessFactor The glossiness factor. System.Boolean unlit Does this material have a constant color? System.String texture A path to an image texture for texture mapping. System.Boolean doubleSided Is this material double sided? System.Boolean repeatTexture Does the texture repeat? System.String normalTexture A path to an image texture for normal mapping. System.Boolean interpolateTexture Should the texture be interpolated? System.String emissiveTexture A path to an emissive image texture. System.Double emissiveFactor The scale, between 0.0 and 1.0, of the emissive texture's components. System.Boolean drawInFront Should objects with this material be drawn in front of all other objects? System.Guid id The id of the material. System.String name The name of the material. Material(String, Color, Double, Double, String, Boolean, Boolean, Boolean, String, Boolean, String, Double, Boolean, Guid) Construct a material. Declaration public Material(string name, Color color, double specularFactor = 0.1, double glossinessFactor = 0.1, string texture = null, bool unlit = false, bool doubleSided = false, bool repeatTexture = true, string normalTexture = null, bool interpolateTexture = true, string emissiveTexture = null, double emissiveFactor = 0, bool drawInFront = false, Guid id = default(Guid)) Parameters Type Name Description System.String name The identifier of the material. Identifiers should be unique within a model. Color color The RGBA color of the material. System.Double specularFactor The specular component of the color. Between 0.0 and 1.0. System.Double glossinessFactor The glossiness component of the color. Between 0.0 and 1.0. System.String texture A relative path to a jpg or png image file to be used as a texture. System.Boolean unlit Is this material affected by lights? System.Boolean doubleSided Is this material to be rendered from both sides? System.Boolean repeatTexture Should the texture be repeated? The RepeatTexture property determines whether textures are clamped in the [0,0]->[1,1] range or repeat continuously. System.String normalTexture A relative path to a jpg or png image file to be used as a normal texture. System.Boolean interpolateTexture Should the texture colors be interpolated between pixels? If false, renders hard pixels in the texture rather than fading between adjacent pixels. System.String emissiveTexture A relative path to a jpg or png image file to be used as en emissive texture. System.Double emissiveFactor The scale, between 0.0 and 1.0, of the emissive texture's components. System.Boolean drawInFront Should objects with this material be drawn in front of all other objects? System.Guid id The id of the material. Material(String, Guid) Construct a material. Declaration public Material(string name, Guid id = default(Guid)) Parameters Type Name Description System.String name The name of the material. System.Guid id The id of the material. Properties Color The material's color. Declaration [JsonProperty(\"Color\", Required = Required.Always)] [Required] public Color Color { get; set; } Property Value Type Description Color DoubleSided Is this material to be rendered from both sides? Declaration [JsonProperty(\"DoubleSided\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public bool DoubleSided { get; set; } Property Value Type Description System.Boolean DrawInFront Should objects with this material be drawn in front of all other objects? Declaration [JsonProperty(\"Draw In Front\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public bool DrawInFront { get; set; } Property Value Type Description System.Boolean EdgeDisplaySettings If provided, this controls how curves and lines will be drawn in the 3D view for supported viewers. This will not affect mesh / solid-based elements. Declaration public EdgeDisplaySettings EdgeDisplaySettings { get; set; } Property Value Type Description EdgeDisplaySettings EmissiveFactor The scale, between 0.0 and 1.0, of the emissive texture's components. Declaration [JsonProperty(\"EmissiveFactor\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public double EmissiveFactor { get; set; } Property Value Type Description System.Double EmissiveTexture A relative path to a jpg or png image file to be used as an emissive texture. Declaration [JsonProperty(\"EmissiveTexture\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public string EmissiveTexture { get; set; } Property Value Type Description System.String GlossinessFactor The glossiness factor between 0.0 and 1.0. Declaration [JsonProperty(\"GlossinessFactor\", Required = Required.Always)] [Range(0, 1)] public double GlossinessFactor { get; set; } Property Value Type Description System.Double InterpolateTexture Should the texture colors be interpolated between pixels? If false, renders hard pixels in the texture rather than fading between adjacent pixels. Declaration [JsonProperty(\"InterpolateTexture\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public bool InterpolateTexture { get; set; } Property Value Type Description System.Boolean NormalTexture A relative path to a jpg or png image file to be used as a normal texture. Declaration [JsonProperty(\"NormalTexture\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public string NormalTexture { get; set; } Property Value Type Description System.String RepeatTexture Should the texture be repeated? The RepeatTexture property determines whether textures are clamped in the [0,0]->[1,1] range or repeat continuously. Declaration [JsonProperty(\"RepeatTexture\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public bool RepeatTexture { get; set; } Property Value Type Description System.Boolean SpecularFactor The specular factor between 0.0 and 1.0. Declaration [JsonProperty(\"SpecularFactor\", Required = Required.Always)] [Range(0, 1)] public double SpecularFactor { get; set; } Property Value Type Description System.Double Texture A relative file path to an image file to be used as a texture. Declaration [JsonProperty(\"Texture\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public string Texture { get; set; } Property Value Type Description System.String Unlit Is this material affected by lights? Declaration [JsonProperty(\"Unlit\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public bool Unlit { get; set; } Property Value Type Description System.Boolean Methods Equals(Object) Is this material equal to the provided material? Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) GetHashCode() Get the hash code for the material. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.MeshElement.html": {
    "href": "api/Elements.MeshElement.html",
    "title": "Class MeshElement | Hypar Docs",
    "keywords": "Class MeshElement An element whose representation is provided by a mesh. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_MeshElement.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var mesh = new Mesh(); var gridSize = 10; for (var u = 0; u < gridSize; u += 1) { for (var v = 0; v < gridSize; v += 1) { var sinu = Math.Sin(-Math.PI + 2 * ((double)u / (double)gridSize * Math.PI)); var sinv = Math.Sin(-Math.PI + 2 * ((double)v / (double)gridSize * Math.PI)); var z = sinu + sinv; var vertex = new Vertex(new Vector3(u, v, z), color: Colors.Mint); mesh.AddVertex(vertex); if (u > 0 && v > 0) { var index = u * gridSize + v; var a = mesh.Vertices[index]; var b = mesh.Vertices[index - gridSize]; var c = mesh.Vertices[index - 1]; var d = mesh.Vertices[index - gridSize - 1]; var tri1 = new Triangle(a, b, c); var tri2 = new Triangle(c, b, d); mesh.AddTriangle(tri1); mesh.AddTriangle(tri2); } } } mesh.ComputeNormals(); var meshElement = new MeshElement(mesh, material: new Material(\"Lime\", Colors.Lime)); Inheritance System.Object Element GeometricElement MeshElement ImportMeshElement ModelText Topography Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class MeshElement : GeometricElement, INotifyPropertyChanged, ITessellate Constructors MeshElement() Empty constructor for compatibility purposes. It is best to use the structured constructor with arguments, to ensure the mesh is correctly created. Declaration public MeshElement() MeshElement(Mesh, Transform, Material, Representation, Boolean, Guid, String) Construct an import mesh element. Declaration [JsonConstructor] public MeshElement(Mesh mesh, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Mesh mesh The element's mesh. Transform transform The element's transform. Material material The element's material. Representation representation The element's representation. System.Boolean isElementDefinition Is this element a definition? System.Guid id The element's id. System.String name The element's name. Fields _mesh The mesh. Declaration protected Mesh _mesh Field Value Type Description Mesh Properties Mesh The element's mesh. Declaration public Mesh Mesh { get; set; } Property Value Type Description Mesh Methods Tessellate(ref Mesh, Transform, Color) Tessellate the element. Declaration public void Tessellate(ref Mesh mesh, Transform transform = null, Color color = default(Color)) Parameters Type Name Description Mesh mesh Transform transform Color color Implements System.ComponentModel.INotifyPropertyChanged ITessellate Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Model.html": {
    "href": "api/Elements.Model.html",
    "title": "Class Model | Hypar Docs",
    "keywords": "Class Model A container for elements. Inheritance System.Object Model Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Model Constructors Model() Construct an empty model. Declaration public Model() Model(Position, Transform, IDictionary<Guid, Element>) Construct a model. Declaration [JsonConstructor] public Model(Position origin, Transform transform, IDictionary<Guid, Element> elements) Parameters Type Name Description Position origin The origin of the model. Transform transform The transform of the model. System.Collections.Generic.IDictionary < System.Guid , Element > elements A collection of elements. Model(Transform, IDictionary<Guid, Element>) Construct a model. Declaration public Model(Transform transform, IDictionary<Guid, Element> elements) Parameters Type Name Description Transform transform The model's transform. System.Collections.Generic.IDictionary < System.Guid , Element > elements The model's elements. Model(IEnumerable<Element>, Transform) Construct a model with the given elements. Declaration public Model(IEnumerable<Element> elements, Transform transform = null) Parameters Type Name Description System.Collections.Generic.IEnumerable < Element > elements The model's elements. Transform transform The models' transform. Properties Elements A collection of Elements keyed by their identifiers. Declaration [JsonProperty(\"Elements\", Required = Required.Always)] [Required] public IDictionary<Guid, Element> Elements { get; set; } Property Value Type Description System.Collections.Generic.IDictionary < System.Guid , Element > Origin The origin of the model. Declaration [JsonProperty(\"Origin\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] [Obsolete(\"Use Transform instead.\")] public Position Origin { get; set; } Property Value Type Description Position Transform The transform of the model. Declaration [JsonProperty(\"Transform\", Required = Required.AllowNull)] public Transform Transform { get; set; } Property Value Type Description Transform Methods AddElement(Element, Boolean) Declaration public void AddElement(Element element, bool gatherSubElements = true) Parameters Type Name Description Element element System.Boolean gatherSubElements AddElements(Element[]) Add elements to the model. Declaration public void AddElements(params Element[] elements) Parameters Type Name Description Element [] elements The elements to add to the model. AddElements(IEnumerable<Element>, Boolean) Add a collection of elements to the model. Declaration public void AddElements(IEnumerable<Element> elements, bool gatherSubElements = true) Parameters Type Name Description System.Collections.Generic.IEnumerable < Element > elements The elements to add to the model. System.Boolean gatherSubElements Should sub-elements in properties be added to the model's elements collection? AllElementsAssignableFromType<T>() Get all elements assignable from type T. This will include types which derive from T and types which implement T if T is an interface. Declaration public IEnumerable<T> AllElementsAssignableFromType<T>() where T : Element Returns Type Description System.Collections.Generic.IEnumerable <T> A collection of elements derived from the specified type. Type Parameters Name Description T The type of the element from which returned elements derive. AllElementsOfType<T>() Get all elements of the type T. Declaration public IEnumerable<T> AllElementsOfType<T>() where T : Element Returns Type Description System.Collections.Generic.IEnumerable <T> A collection of elements of the specified type. Type Parameters Name Description T The type of element to return. FromJson(String, Boolean) Declaration public static Model FromJson(string json, bool forceTypeReload = false) Parameters Type Name Description System.String json System.Boolean forceTypeReload Returns Type Description Model FromJson(String, out List<String>, Boolean) Deserialize a model from JSON. Declaration public static Model FromJson(string json, out List<string> errors, bool forceTypeReload = false) Parameters Type Name Description System.String json The JSON representing the model. System.Collections.Generic.List < System.String > errors A collection of deserialization errors. System.Boolean forceTypeReload Option to force reloading the inernal type cache. Use if you add types dynamically in your code. Returns Type Description Model GetElementByName<T>(String) Get the first entity with the specified name. Declaration public T GetElementByName<T>(string name) where T : Element Parameters Type Name Description System.String name Returns Type Description T An entity or null if no entity can be found with the provided name. Type Parameters Name Description T GetElementOfType<T>(Guid) Get an entity by id from the Model. Declaration public T GetElementOfType<T>(Guid id) where T : Element Parameters Type Name Description System.Guid id The identifier of the element. Returns Type Description T An entity or null if no entity can be found with the provided id. Type Parameters Name Description T Intersect(Plane, out Dictionary<Guid, List<Polygon>>, out Dictionary<Guid, List<Polygon>>, out Dictionary<Guid, List<Line>>) Intersect the model with the provided plane. Declaration public void Intersect(Plane plane, out Dictionary<Guid, List<Polygon>> intersectionPolygons, out Dictionary<Guid, List<Polygon>> beyondPolygons, out Dictionary<Guid, List<Line>> lines) Parameters Type Name Description Plane plane The intersection plane. System.Collections.Generic.Dictionary < System.Guid , System.Collections.Generic.List < Polygon >> intersectionPolygons A collection of polygons resulting from the intersection of the plane with all elements in the model. System.Collections.Generic.Dictionary < System.Guid , System.Collections.Generic.List < Polygon >> beyondPolygons A collection of polygons resulting from intersection of the beyond plane with all elements in the model. System.Collections.Generic.Dictionary < System.Guid , System.Collections.Generic.List < Line >> lines A collection of line segments resulting from intersection of the plane with all elements in the model. ToJson() Serialize the model to JSON using default arguments. Declaration public string ToJson() Returns Type Description System.String ToJson(Boolean) Serialize the model to JSON to match default arguments. TODO this method can be removed after Hypar.Functions release 0.9.11 occurs. Declaration public string ToJson(bool indent = false) Parameters Type Name Description System.Boolean indent Returns Type Description System.String ToJson(Boolean, Boolean) Serialize the model to JSON. Declaration public string ToJson(bool indent = false, bool gatherSubElements = true) Parameters Type Name Description System.Boolean indent System.Boolean gatherSubElements Returns Type Description System.String ToJson(String, Boolean) Serialize the model to a JSON file. Declaration public void ToJson(string path, bool gatherSubElements = true) Parameters Type Name Description System.String path The path of the file on disk. System.Boolean gatherSubElements UpdateBoundsAndComputedSolids() Update the bounds and computed solids of all geometric elements in the model. Declaration public void UpdateBoundsAndComputedSolids() UpdateRepresentations() Update the representations of all geometric elements in the model. Declaration public void UpdateRepresentations() Extension Methods GltfExtensions.ToGlTF(Model, String, out List<BaseError>, Boolean, Boolean) GltfExtensions.ToGlTF(Model, String, Boolean, Boolean) GltfExtensions.ToGlTF(Model, Boolean, Boolean) GltfExtensions.ToBase64String(Model, Boolean, Boolean)"
  },
  "api/Elements.ModelArrows.html": {
    "href": "api/Elements.ModelArrows.html",
    "title": "Class ModelArrows | Hypar Docs",
    "keywords": "Class ModelArrows A collection of arrows which are visible in 3D. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ModelArrows.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create some arrow locations. var vectors = new List<(Vector3 location, Vector3 direction, double magnitude, Color? color)>(); var target = new Vector3(15, 20); var squareSize = 25.0; var maxDistance = Math.Sqrt(Math.Pow(squareSize, 2) + Math.Pow(squareSize, 2)); for (var x = 0.0; x < squareSize; x += 1.0) { for (var y = 0.0; y < squareSize; y += 1.0) { var l = new Vector3(x, y); var d = (target - l).Unitized(); var distance = target.DistanceTo(l); var r = distance / maxDistance; var c = new Color(x / squareSize, y / squareSize, 0.0, 1.0); vectors.Add((l, d, r, c)); } } // Create a model arrows object. var modelArrows = new ModelArrows(vectors, false, true); Inheritance System.Object Element GeometricElement ModelArrows Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ModelArrows : GeometricElement, INotifyPropertyChanged Constructors ModelArrows(IList<(Vector3 location, Vector3 direction, Double magnitude, Nullable<Color> color)>, Boolean, Boolean, Double, Transform, Boolean, Guid, String) Create a collection of points. Declaration [JsonConstructor] public ModelArrows(IList<(Vector3 location, Vector3 direction, double magnitude, Color? color)> vectors = null, bool arrowAtStart = false, bool arrowAtEnd = true, double arrowAngle = 60, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description System.Collections.Generic.IList < System.ValueTuple < Vector3 , Vector3 , System.Double , System.Nullable < Color >>> vectors A collection of tuples specifying the origin, direction, and the magnitude of the arrows. System.Boolean arrowAtStart Should an arrow head be drawn at the start? System.Boolean arrowAtEnd Should an arrow head be drawn at the end? System.Double arrowAngle The angle of the arrow head. Transform transform The model arrows' transform. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the model arrows. System.String name The name of the model arrows. Properties ArrowAngle The angle of the arrow head. Declaration public double ArrowAngle { get; set; } Property Value Type Description System.Double ArrowAtEnd Should an arrow head be drawn at the end? Declaration public bool ArrowAtEnd { get; set; } Property Value Type Description System.Boolean ArrowAtStart Should an arrow head be drawn at the start? Declaration public bool ArrowAtStart { get; set; } Property Value Type Description System.Boolean Vectors A collection of tuples specifying the origin, magnitude, and color of the arrows. Declaration public IList<(Vector3 origin, Vector3 direction, double magnitude, Color? color)> Vectors { get; set; } Property Value Type Description System.Collections.Generic.IList < System.ValueTuple < Vector3 , Vector3 , System.Double , System.Nullable < Color >>> Methods TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Get graphics buffers and other metadata required to modify a GLB. Declaration public override bool TryToGraphicsBuffers(out List<GraphicsBuffers> graphicsBuffers, out string id, out MeshPrimitive.ModeEnum? mode) Parameters Type Name Description System.Collections.Generic.List < GraphicsBuffers > graphicsBuffers System.String id System.Nullable < glTFLoader.Schema.MeshPrimitive.ModeEnum > mode Returns Type Description System.Boolean True if there is graphicsbuffers data applicable to add, false otherwise. Out variables should be ignored if the return value is false. Overrides GeometricElement.TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ModelCurve.html": {
    "href": "api/Elements.ModelCurve.html",
    "title": "Class ModelCurve | Hypar Docs",
    "keywords": "Class ModelCurve A curve which is visible in 3D. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ModelCurve.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // A line var line = new Line(Vector3.Origin, new Vector3(5, 5, 5)); // An arc var arc = new Arc(Vector3.Origin, 2.0, 45.0, 135.0); // A polygon var pline = Polygon.L(2, 2, 0.5); // A Bezier var a = Vector3.Origin; var b = new Vector3(5, 0, 1); var c = new Vector3(5, 5, 2); var d = new Vector3(0, 5, 3); var e = new Vector3(0, 0, 4); var f = new Vector3(5, 0, 5); var ctrlPts = new List<Vector3> { a, b, c, d, e, f }; var bezier = new Bezier(ctrlPts); var lineModelCurve = new ModelCurve(line, new Material(\"Red\", Colors.Red) { EdgeDisplaySettings = new EdgeDisplaySettings { LineWidth = 5, DashMode = EdgeDisplayDashMode.WorldUnits, DashSize = 0.1 } }); var arcModelCurve = new ModelCurve(arc, new Material(\"Orange\", Colors.Orange) { EdgeDisplaySettings = new EdgeDisplaySettings { LineWidth = 0.1, WidthMode = EdgeDisplayWidthMode.WorldUnits } }, new Transform(5, 0, 0)); var plineModelCurve = new ModelCurve(pline, new Material(\"Purple\", Colors.Purple) { EdgeDisplaySettings = new EdgeDisplaySettings { LineWidth = 10, WidthMode = EdgeDisplayWidthMode.ScreenUnits, DashMode = EdgeDisplayDashMode.ScreenUnits, DashSize = 10, GapSize = 4 } }, new Transform(10, 0, 0)); var bezierModelCurve = new ModelCurve(bezier, new Material(\"Green\", Colors.Green) { EdgeDisplaySettings = new EdgeDisplaySettings { LineWidth = 1, WidthMode = EdgeDisplayWidthMode.WorldUnits } }, new Transform(15, 0, 0)); Inheritance System.Object Element GeometricElement ModelCurve Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ModelCurve : GeometricElement, INotifyPropertyChanged Constructors ModelCurve(BoundedCurve, Material, Transform, Representation, Boolean, Guid, String) Create a model curve. Declaration public ModelCurve(BoundedCurve curve, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description BoundedCurve curve The curve. Material material The material. Specular and glossiness components will be ignored. Transform transform The model curve's transform. Representation representation The curve's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the model curve. System.String name The name of the model curve. Properties Curve The curve. Declaration public BoundedCurve Curve { get; set; } Property Value Type Description BoundedCurve Methods SetSelectable(Boolean) Set whether this model curve should be selectable in the web UI. Declaration public void SetSelectable(bool selectable) Parameters Type Name Description System.Boolean selectable TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Get graphics buffers and other metadata required to modify a GLB. Declaration public override bool TryToGraphicsBuffers(out List<GraphicsBuffers> graphicsBuffers, out string id, out MeshPrimitive.ModeEnum? mode) Parameters Type Name Description System.Collections.Generic.List < GraphicsBuffers > graphicsBuffers System.String id System.Nullable < glTFLoader.Schema.MeshPrimitive.ModeEnum > mode Returns Type Description System.Boolean True if there is graphicsbuffers data applicable to add, false otherwise. Out variables should be ignored if the return value is false. Overrides GeometricElement.TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ModelCurveExtensions.html": {
    "href": "api/Elements.ModelCurveExtensions.html",
    "title": "Class ModelCurveExtensions | Hypar Docs",
    "keywords": "Class ModelCurveExtensions Extension methods for model curves. Inheritance System.Object ModelCurveExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class ModelCurveExtensions Methods ToModelCurves(BBox3, Transform, Material) Convert a Bounding Box to a set of model curves. Declaration public static IList<ModelCurve> ToModelCurves(this BBox3 box, Transform context = null, Material material = null) Parameters Type Name Description BBox3 box The bounding box to convert. Transform context An optional transform in which these curves should be drawn. Material material An optional material to use for these curves. Returns Type Description System.Collections.Generic.IList < ModelCurve > ToModelCurves(Profile, Transform, Material) Convert a profile to a set of model curves. Declaration public static IList<ModelCurve> ToModelCurves(this Profile p, Transform context = null, Material material = null) Parameters Type Name Description Profile p The profile to convert. Transform context An optional transform in which these curves should be drawn. Material material An optional material to use for these curves. Returns Type Description System.Collections.Generic.IList < ModelCurve > ToModelCurves(Transform, Transform) Convert a transform to a set of model curves. Declaration public static IList<ModelCurve> ToModelCurves(this Transform t, Transform context = null) Parameters Type Name Description Transform t The transform to convert. Transform context An optional transform in which these curves should be drawn. Returns Type Description System.Collections.Generic.IList < ModelCurve > ToModelCurves(Grid2d, Transform, Material) Convert a Grid2d to a set of model curves. Declaration public static IEnumerable<ModelCurve> ToModelCurves(this Grid2d grid, Transform context = null, Material material = null) Parameters Type Name Description Grid2d grid The grid to convert. Transform context An optional transform to apply to these curves. Material material An optional material to use for these curves. Returns Type Description System.Collections.Generic.IEnumerable < ModelCurve >"
  },
  "api/Elements.ModelExtensions.html": {
    "href": "api/Elements.ModelExtensions.html",
    "title": "Class ModelExtensions | Hypar Docs",
    "keywords": "Class ModelExtensions Inheritance System.Object ModelExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class ModelExtensions Methods AllElementsOfType<T>(Dictionary<String, Model>, String) Get all elements of a certain type from a specific model name in a dictionary of models. Declaration public static List<T> AllElementsOfType<T>(this Dictionary<string, Model> models, string modelName) where T : Element Parameters Type Name Description System.Collections.Generic.Dictionary < System.String , Model > models Dictionary of models keyed by string. System.String modelName The name of the model. Returns Type Description System.Collections.Generic.List <T> Type Parameters Name Description T The type of element we want to retrieve. AllProxiesOfType<T>(Dictionary<String, Model>, String) Get all proxies of a certain type from a specific model name in a dictionary of models. Declaration public static List<ElementProxy<T>> AllProxiesOfType<T>(this Dictionary<string, Model> models, string modelName) where T : Element Parameters Type Name Description System.Collections.Generic.Dictionary < System.String , Model > models Dictionary of models keyed by string System.String modelName The name of the model Returns Type Description System.Collections.Generic.List < ElementProxy <T>> Type Parameters Name Description T The type of element we want to retrieve"
  },
  "api/Elements.ModelLines.html": {
    "href": "api/Elements.ModelLines.html",
    "title": "Class ModelLines | Hypar Docs",
    "keywords": "Class ModelLines A collection of lines which are visible in 3D. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ModelLines.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var lines = new List<Line>() { new Line(new Vector3(0, 0), new Vector3(0, 5)), new Line(new Vector3(0, 0), new Vector3(5, 0)), new Line(new Vector3(0, 5), new Vector3(5, 5)), new Line(new Vector3(5, 0), new Vector3(5, 5)), new Line(new Vector3(0, 0), new Vector3(5, 5)) }; var modelLines = new ModelLines(lines, new Material(\"Yellow\", Colors.Yellow)); Inheritance System.Object Element GeometricElement ModelLines Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ModelLines : GeometricElement, INotifyPropertyChanged Constructors ModelLines(IList<Line>, Material, Transform, Boolean, Guid, String) Create a collection of lines. They share Material, Transformation and other parameters. Declaration [JsonConstructor] public ModelLines(IList<Line> lines = null, Material material = null, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description System.Collections.Generic.IList < Line > lines The lines. Material material The material. Specular and glossiness components will be ignored. Transform transform The model lines transform. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the model lines. System.String name The name of the model lines. Properties Lines The lines. Declaration public IList<Line> Lines { get; set; } Property Value Type Description System.Collections.Generic.IList < Line > Methods SetSelectable(Boolean) Set whether these model lines should be selectable in the web UI. Lines are not selectable by default. Declaration public void SetSelectable(bool selectable) Parameters Type Name Description System.Boolean selectable TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Get graphics buffers and other metadata required to modify a GLB. Declaration public override bool TryToGraphicsBuffers(out List<GraphicsBuffers> graphicsBuffers, out string id, out MeshPrimitive.ModeEnum? mode) Parameters Type Name Description System.Collections.Generic.List < GraphicsBuffers > graphicsBuffers System.String id System.Nullable < glTFLoader.Schema.MeshPrimitive.ModeEnum > mode Returns Type Description System.Boolean True if there is graphicsbuffers data applicable to add, false otherwise. Out variables should be ignored if the return value is false. Overrides GeometricElement.TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ModelPoints.html": {
    "href": "api/Elements.ModelPoints.html",
    "title": "Class ModelPoints | Hypar Docs",
    "keywords": "Class ModelPoints A collection of points which are visible in 3D. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ModelPoints.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create some point locations. var pts = new List<Vector3>(); for (var x = 0; x < 25; x++) { for (var y = 0; y < 25; y++) { for (var z = 0; z < 25; z++) { // Add points to the object. pts.Add(new Vector3(x, y, z)); } } } // Create a model points object. var pink = new Material(\"pink\", Colors.Pink); var modelPoints = new ModelPoints(pts, pink); Inheritance System.Object Element GeometricElement ModelPoints Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ModelPoints : GeometricElement, INotifyPropertyChanged Constructors ModelPoints(IList<Vector3>, Material, Transform, Boolean, Guid, String) Create a collection of points. Declaration [JsonConstructor] public ModelPoints(IList<Vector3> locations = null, Material material = null, Transform transform = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > locations The locations of the points. Material material The material. Specular and glossiness components will be ignored. Transform transform The model points transform. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the model points. System.String name The name of the model points. Properties Locations The locations of the points. Declaration public IList<Vector3> Locations { get; set; } Property Value Type Description System.Collections.Generic.IList < Vector3 > Methods TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Get graphics buffers and other metadata required to modify a GLB. Declaration public override bool TryToGraphicsBuffers(out List<GraphicsBuffers> graphicsBuffers, out string id, out MeshPrimitive.ModeEnum? mode) Parameters Type Name Description System.Collections.Generic.List < GraphicsBuffers > graphicsBuffers System.String id System.Nullable < glTFLoader.Schema.MeshPrimitive.ModeEnum > mode Returns Type Description System.Boolean True if there is graphicsbuffers data applicable to add, false otherwise. Out variables should be ignored if the return value is false. Overrides GeometricElement.TryToGraphicsBuffers(out List<GraphicsBuffers>, out String, out Nullable<MeshPrimitive.ModeEnum>) Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.ModelText.html": {
    "href": "api/Elements.ModelText.html",
    "title": "Class ModelText | Hypar Docs",
    "keywords": "Class ModelText A collection of text tags which are visible in 3D. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_ModelText.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var squareSize = 25.0; var texts = new List<(Vector3 location, Vector3 facingDirection, Vector3 lineDirection, string text, Color? color)>(); var dir = Vector3.YAxis.Negate(); for (var x = 0.0; x < squareSize; x += 1.0) { for (var y = 0.0; y < squareSize; y += 1.0) { var c = new Color(x / squareSize, y / squareSize, 0.0, 1.0); texts.Add((new Vector3(x, y), dir, Vector3.XAxis, $\"[{x},{y}]\", c)); } } // Create a model text object. var modelText = new ModelText(texts, FontSize.PT36, 30); Inheritance System.Object Element GeometricElement MeshElement ModelText Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members MeshElement._mesh MeshElement.Mesh MeshElement.Tessellate(Mesh, Transform, Color) GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class ModelText : MeshElement, INotifyPropertyChanged, ITessellate Constructors ModelText(IList<(Vector3 location, Vector3 facingDirection, Vector3 lineDirection, String text, Nullable<Color> color)>, FontSize, Double) Create a set of text Declaration public ModelText(IList<(Vector3 location, Vector3 facingDirection, Vector3 lineDirection, string text, Color? color)> texts, FontSize fontSize, double scale = 10) Parameters Type Name Description System.Collections.Generic.IList < System.ValueTuple < Vector3 , Vector3 , Vector3 , System.String , System.Nullable < Color >>> texts A collection of text data objects which specify the location, direction, and content of the text. FontSize fontSize The font size of the text. System.Double scale An additional scale to apply to the size of the text. Fonts will be drawn at the real world equivalent of 72 dpi at scale=1.0. Properties FontSize The font size of the model text. Declaration public FontSize FontSize { get; set; } Property Value Type Description FontSize Scale An additional scale to apply to the size of the text. Fonts will be drawn at the real world equivalent of 72 dpi at scale=1.0. Declaration public double Scale { get; set; } Property Value Type Description System.Double Texts A collection of text data objects which specify the location, direction, content, and color of the text. Declaration public IList<(Vector3 location, Vector3 facingDirection, Vector3 lineDirection, string text, Color? color)> Texts { get; set; } Property Value Type Description System.Collections.Generic.IList < System.ValueTuple < Vector3 , Vector3 , Vector3 , System.String , System.Nullable < Color >>> Implements System.ComponentModel.INotifyPropertyChanged ITessellate Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.OpenCeiling.html": {
    "href": "api/Elements.OpenCeiling.html",
    "title": "Class OpenCeiling | Hypar Docs",
    "keywords": "Class OpenCeiling A ceiling that has no physical geometry, but still defines a perimeter and an elevation. Inheritance System.Object Element GeometricElement BaseCeiling OpenCeiling Implements System.ComponentModel.INotifyPropertyChanged Inherited Members BaseCeiling.Elevation BaseCeiling.Perimeter GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateRepresentations() GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class OpenCeiling : BaseCeiling, INotifyPropertyChanged Constructors OpenCeiling(Polygon, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling from perimeter. Declaration public OpenCeiling(Polygon perimeter, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan perimeter of the ceiling. It must lie on the XY plane. Z coordinate will be used as elevation Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. OpenCeiling(Polygon, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling from perimeter and an elevation. Declaration public OpenCeiling(Polygon perimeter, double elevation, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double elevation The elevation of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. OpenCeiling(Polygon, Double, Guid, Material, Transform, Representation, Boolean, String) Construct a ceiling. It's a private constructor that doesn't add elevation to transform Declaration [JsonConstructor] protected OpenCeiling(Polygon perimeter, double elevation, Guid id = default(Guid), Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double elevation The elevation of the ceiling. System.Guid id The id of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.String name The name of the ceiling. Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Opening.html": {
    "href": "api/Elements.Opening.html",
    "title": "Class Opening | Hypar Docs",
    "keywords": "Class Opening A polygonal opening. An opening's placement is defined by the x and y coordinates. The direction of the opening corresponds to the +Z axis of the transform. Inheritance System.Object Element GeometricElement Opening Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Opening : GeometricElement, INotifyPropertyChanged Constructors Opening(Polygon, Vector3, Double, Double, Transform, Representation, Boolean, Guid, String) Create an opening. Declaration [JsonConstructor] public Opening(Polygon perimeter, Vector3 normal, double depthFront = 1, double depthBack = 1, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter Vector3 normal System.Double depthFront System.Double depthBack Transform transform Representation representation System.Boolean isElementDefinition System.Guid id System.String name Opening(Polygon, Double, Double, Transform, Representation, Boolean, Guid, String) Create an opening normal to the ZAxis. Declaration public Opening(Polygon perimeter, double depthFront = 1, double depthBack = 1, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter System.Double depthFront System.Double depthBack Transform transform Representation representation System.Boolean isElementDefinition System.Guid id System.String name Properties DepthBack The depth of the opening along the opening's -Z axis. Declaration public double DepthBack { get; set; } Property Value Type Description System.Double DepthFront The depth of the opening along the opening's +Z axis. Declaration public double DepthFront { get; set; } Property Value Type Description System.Double Normal The normal direction of the opening. Declaration public Vector3 Normal { get; set; } Property Value Type Description Vector3 Perimeter The perimeter of the opening. Declaration public Polygon Perimeter { get; set; } Property Value Type Description Polygon Profile The profile of the opening. Declaration [Obsolete(\"Use perimeter instead.\")] public Profile Profile { get; set; } Property Value Type Description Profile Methods UpdateRepresentations() Update representations Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Panel.html": {
    "href": "api/Elements.Panel.html",
    "title": "Class Panel | Hypar Docs",
    "keywords": "Class Panel A zero-thickness planar element defined by a perimeter. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Panel.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var a = new Vector3(0,0,0); var b = new Vector3(1,0,0); var c = new Vector3(1,0,1); var d = new Vector3(0,0,1); // Create a panel. var panel = new Panel(new Polygon(new []{a,b,c,d}), BuiltInMaterials.Glass); Inheritance System.Object Element GeometricElement Panel Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Panel : GeometricElement, INotifyPropertyChanged Constructors Panel(Polygon, Material, Transform, Representation, Boolean, Guid, String) Create a panel. Declaration public Panel(Polygon perimeter, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The perimeter of the panel. Material material The panel's material Transform transform The panel's transform. Representation representation The panel's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the panel. System.String name The name of the panel. Properties Perimeter The perimeter of the panel. Declaration public Polygon Perimeter { get; } Property Value Type Description Polygon Methods Area() The panel's area. Declaration public double Area() Returns Type Description System.Double Normal() The normal of the panel, defined using the first 3 vertices in the location. Declaration public Vector3 Normal() Returns Type Description Vector3 The normal vector of the panel. UpdateRepresentations() Update representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.PointLight.html": {
    "href": "api/Elements.PointLight.html",
    "title": "Class PointLight | Hypar Docs",
    "keywords": "Class PointLight A point light. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_PointLight.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var lightMaterial = new Material(\"Light\", Colors.White, unlit: true); var t = new Transform(0, 0, 5); var lightBulb = new Mass(Polygon.Rectangle(0.1, 0.1), 0.1, lightMaterial, transform: t); var floor = new Floor(Polygon.Rectangle(20, 20), 0.1); var pointLight = new PointLight(Colors.White, t, 20); Inheritance System.Object Element Light PointLight Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Light.LightType Light.Intensity Light.Color Light.Transform Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class PointLight : Light, INotifyPropertyChanged Constructors PointLight(Color, Transform, Double, Guid, String) A point light. Declaration public PointLight(Color color, Transform transform, double intensity = 1, Guid id = default(Guid), string name = null) Parameters Type Name Description Color color The light's color. Transform transform The light's transform. System.Double intensity The light's intensity measured in candela. System.Guid id The light's unique id. System.String name The light's name. Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.PriorityQueue-1.html": {
    "href": "api/Elements.PriorityQueue-1.html",
    "title": "Class PriorityQueue<T> | Hypar Docs",
    "keywords": "Class PriorityQueue<T> PriorityQueue is a collection that allows you to retrieve the item with the lowest priority in constant time and be able update priority of an item with log complexity. Items are unique within the collection but priorities can have duplicate values. Inheritance System.Object PriorityQueue<T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class PriorityQueue<T> where T : IComparable<T> Type Parameters Name Description T Type of the item. Must support hash and comparing. Constructors PriorityQueue() Creates an empty collection. Declaration public PriorityQueue() PriorityQueue(IEnumerable<T>) Creates collection from input list. First item in the list is set to priority 0, others with double.MaxValue. Declaration public PriorityQueue(IEnumerable<T> uniqueCollection) Parameters Type Name Description System.Collections.Generic.IEnumerable <T> uniqueCollection List of ids. Methods AddOrUpdate(T, Double) Adds a new item to the collection. If an item with id already exist in collection - it's priority will be updated. Declaration public void AddOrUpdate(T id, double priority) Parameters Type Name Description T id Id of the item. System.Double priority New priority. Contains(T) Checks if certain Id is in the queue. Declaration public bool Contains(T id) Parameters Type Name Description T id Returns Type Description System.Boolean Empty() Is collection empty. Declaration public bool Empty() Returns Type Description System.Boolean PopMin() Returns the lowest priority item from collection. Throws an exception if called on an empty collection. Declaration public T PopMin() Returns Type Description T Id of the item with lowest priority. UpdatePriority(T, Double) Sets priority for the item with given id. Does nothing if item is not present in the queue. Declaration public void UpdatePriority(T id, double priority) Parameters Type Name Description T id Id of the item. System.Double priority New priority."
  },
  "api/Elements.RandomExtensions.html": {
    "href": "api/Elements.RandomExtensions.html",
    "title": "Class RandomExtensions | Hypar Docs",
    "keywords": "Class RandomExtensions Extension methods for generating new random objects from an instance of System.Random. Inheritance System.Object RandomExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class RandomExtensions Methods NextColor(Random) Generate a new color with a random R, G, and B component. Useful for debugging purposes. Declaration public static Color NextColor(this Random random) Parameters Type Name Description System.Random random The Random object. Returns Type Description Color NextMaterial(Random, Boolean) Generate a new material with a random color assigned. Useful for debugging purposes. Declaration public static Material NextMaterial(this Random random, bool unlit = true) Parameters Type Name Description System.Random random The Random object. System.Boolean unlit Whether or not to treat the material as unlit. Returns Type Description Material NextRay(Random, Vector3) Generate a ray in a random direction. Declaration public static Ray NextRay(this Random random, Vector3 origin) Parameters Type Name Description System.Random random The Random object. Vector3 origin The origin of the ray. Returns Type Description Ray NextRayInPlane(Random, Vector3, Vector3) Generate a ray in a random direction in the specified plane. Declaration public static Ray NextRayInPlane(this Random random, Vector3 origin, Vector3 normal) Parameters Type Name Description System.Random random The Random object. Vector3 origin The origin of the ray. Vector3 normal The normal of the plane in which the resulting ray will lie. Returns Type Description Ray A ray pointing in a random direction, along the plane. NextVector(Random, BBox3) Generate a new random vector with an optional bounds. Declaration public static Vector3 NextVector(this Random random, BBox3 bounds = default(BBox3)) Parameters Type Name Description System.Random random The Random object to generate from BBox3 bounds If specified, the bounds within which the vectors will be generated. If not specified, vectors will be generated in the range (-1,-1,-1) to (1,1,1). Returns Type Description Vector3"
  },
  "api/Elements.Search.DirectionComparer.html": {
    "href": "api/Elements.Search.DirectionComparer.html",
    "title": "Class DirectionComparer | Hypar Docs",
    "keywords": "Class DirectionComparer A comparer used to order collections of vectors according to their \"sameness\" with the provided vector. Inheritance System.Object DirectionComparer Implements System.Collections.Generic.IComparer < Vector3 > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Search Assembly : Hypar.Elements.dll Syntax public class DirectionComparer : IComparer<Vector3> Constructors DirectionComparer(Vector3) Construct a direction comparer. Declaration public DirectionComparer(Vector3 v) Parameters Type Name Description Vector3 v The vector against which to compare. Methods Compare(Vector3, Vector3) Compare two vectors. Declaration public int Compare(Vector3 x, Vector3 y) Parameters Type Name Description Vector3 x The first vector. Vector3 y The second vector. Returns Type Description System.Int32 Implements System.Collections.Generic.IComparer<T>"
  },
  "api/Elements.Search.DistanceComparer.html": {
    "href": "api/Elements.Search.DistanceComparer.html",
    "title": "Class DistanceComparer | Hypar Docs",
    "keywords": "Class DistanceComparer A comparer used to order collections of points based on their distance from a provided point. Inheritance System.Object DistanceComparer Implements System.Collections.Generic.IComparer < Vector3 > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Search Assembly : Hypar.Elements.dll Syntax public class DistanceComparer : IComparer<Vector3> Constructors DistanceComparer(Vector3) Construct an event comparer. Declaration public DistanceComparer(Vector3 v) Parameters Type Name Description Vector3 v The vector against which to compare. Methods Compare(Vector3, Vector3) Compare two points. Declaration public int Compare(Vector3 x, Vector3 y) Parameters Type Name Description Vector3 x The first point. Vector3 y The second point. Returns Type Description System.Int32 Implements System.Collections.Generic.IComparer<T>"
  },
  "api/Elements.Search.DoubleToleranceComparer.html": {
    "href": "api/Elements.Search.DoubleToleranceComparer.html",
    "title": "Class DoubleToleranceComparer | Hypar Docs",
    "keywords": "Class DoubleToleranceComparer Double comparer that treats all numbers within tolerance as the same. This comparer doesn't use hash code as it is impossible to create a hashing algorithm that consistently returns identical values for any two points within tolerance of each other. Note that any item that is not within tolerance of other key is set as a new key. This mean that keys are not always whole number in the middle of a range. Inheritance System.Object DoubleToleranceComparer Implements System.Collections.Generic.IEqualityComparer < System.Double > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Search Assembly : Hypar.Elements.dll Syntax public class DoubleToleranceComparer : IEqualityComparer<double> Constructors DoubleToleranceComparer(Double) Create a comparer. Declaration public DoubleToleranceComparer(double tolerance) Parameters Type Name Description System.Double tolerance Number tolerance Methods Equals(Double, Double) Check if two numbers are the same within tolerance Declaration public bool Equals(double x, double y) Parameters Type Name Description System.Double x First number System.Double y Second number Returns Type Description System.Boolean True if x should be treated the same as y. GetHashCode(Double) Hash code for number. Always returns 0. Declaration public int GetHashCode(double obj) Parameters Type Name Description System.Double obj number Returns Type Description System.Int32 0 Implements System.Collections.Generic.IEqualityComparer<T>"
  },
  "api/Elements.Search.html": {
    "href": "api/Elements.Search.html",
    "title": "Namespace Elements.Search | Hypar Docs",
    "keywords": "Namespace Elements.Search Classes DirectionComparer A comparer used to order collections of vectors according to their \"sameness\" with the provided vector. DistanceComparer A comparer used to order collections of points based on their distance from a provided point. DoubleToleranceComparer Double comparer that treats all numbers within tolerance as the same. This comparer doesn't use hash code as it is impossible to create a hashing algorithm that consistently returns identical values for any two points within tolerance of each other. Note that any item that is not within tolerance of other key is set as a new key. This mean that keys are not always whole number in the middle of a range. LocalEdge Provides graph edge info Network<T> A network composed of nodes and edges with associated data. A network does not store spatial information. A network can index into another collection of entities which have a spatial context. PointOctree<T> A Dynamic Octree for storing any objects that can be described as a single point. This is a thin wrapper around the PointOctree class from NetOctree ( https://github.com/mcserep/NetOctree )."
  },
  "api/Elements.Search.LocalEdge.html": {
    "href": "api/Elements.Search.LocalEdge.html",
    "title": "Class LocalEdge | Hypar Docs",
    "keywords": "Class LocalEdge Provides graph edge info Inheritance System.Object LocalEdge Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Search Assembly : Hypar.Elements.dll Syntax public class LocalEdge Constructors LocalEdge(Int32, Int32) Creates a new instance of Edge class Declaration public LocalEdge(int vertexIndex1, int vertexIndex2) Parameters Type Name Description System.Int32 vertexIndex1 The index of the first vertex. System.Int32 vertexIndex2 The index of the second vertex. Properties End The index of the second vertex. Declaration public int End { get; } Property Value Type Description System.Int32 Start The index of the first vertex. Declaration public int Start { get; } Property Value Type Description System.Int32 Methods IsBetweenVertices(Int32, Int32) Is this edge between the provided vertices? Declaration public bool IsBetweenVertices(int start, int end) Parameters Type Name Description System.Int32 start The index of the first vertex. System.Int32 end The index of the second vertex. Returns Type Description System.Boolean Returns true if the edge is between the provided vertex indices. IsVisitedFromVertex(Int32) Is this edge visited from the provided vertex? Declaration public bool IsVisitedFromVertex(int vertexIndex) Parameters Type Name Description System.Int32 vertexIndex The index of the vertex from which the vertex is visited. Returns Type Description System.Boolean Returns true if the edge was visited from the vertex. MarkAsVisited(Int32) Mark a vertex as having been visited from the specified index. Declaration public void MarkAsVisited(int start) Parameters Type Name Description System.Int32 start The index of the vertex from which the edge is visited."
  },
  "api/Elements.Search.Network-1.html": {
    "href": "api/Elements.Search.Network-1.html",
    "title": "Class Network<T> | Hypar Docs",
    "keywords": "Class Network<T> A network composed of nodes and edges with associated data. A network does not store spatial information. A network can index into another collection of entities which have a spatial context. Inheritance System.Object Network<T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Search Assembly : Hypar.Elements.dll Syntax public class Network<T> Type Parameters Name Description T The type of data associated with the graph's edges. Constructors Network() Create a network. Declaration public Network() Methods AddEdgeBothWays(Int32, Int32, T) Adds edges to the network both ways from->to and to->from. Declaration public void AddEdgeBothWays(int from, int to, T data) Parameters Type Name Description System.Int32 from The index of the start node. System.Int32 to The index of the end node. T data The data associated with the edge. AddEdgeOneWay(Int32, Int32, T) Adds an edge to the network from->to. Declaration public void AddEdgeOneWay(int from, int to, T data) Parameters Type Name Description System.Int32 from The index of the start node. System.Int32 to The index of the end node. T data The data associated with the edge. AddVertex() Add a vertex to the network. Declaration public int AddVertex() Returns Type Description System.Int32 BranchNodes() All branch nodes of the network. Declaration public List<int> BranchNodes() Returns Type Description System.Collections.Generic.List < System.Int32 > A collection of branch node indices. EdgesAt(Int32) Get all edges at the specified index. Declaration public IEnumerable<(int, T)> EdgesAt(int i) Parameters Type Name Description System.Int32 i The index. Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Int32 , T>> FindAllClosedRegions(List<Vector3>) Find all the closed regions in the network. This method uses the Traverse method internally with a traversal function that uses the maximal plane angle to determine the direction of traversal. Declaration public List<List<int>> FindAllClosedRegions(List<Vector3> allNodeLocations) Parameters Type Name Description System.Collections.Generic.List < Vector3 > allNodeLocations A collection of all node locations in the network. Returns Type Description System.Collections.Generic.List < System.Collections.Generic.List < System.Int32 >> A collection of integers representing the indices of the nodes forming closed regions in the network. FromSegmentableItems(IList<T>, Func<T, Line>, out List<Vector3>, out List<Vector3>, Boolean) Construct a network from the intersections of a collection of items which provide segments in a shared plane. Declaration public static Network<T> FromSegmentableItems(IList<T> items, Func<T, Line> getSegment, out List<Vector3> allNodeLocations, out List<Vector3> allIntersectionLocations, bool twoWayEdges = true) Parameters Type Name Description System.Collections.Generic.IList <T> items A collection of segmentable items. System.Func <T, Line > getSegment A delegate which returns a segment from an item of type T. System.Collections.Generic.List < Vector3 > allNodeLocations A collection of all node locations. System.Collections.Generic.List < Vector3 > allIntersectionLocations A collection of all intersection locations. System.Boolean twoWayEdges Should edges be created in both directions? Returns Type Description Network <T> A network. LeafNodes() All leaf nodes of the network. Declaration public List<int> LeafNodes() Returns Type Description System.Collections.Generic.List < System.Int32 > A collection of leaf node indices. NodeCount() The total number of nodes in the network. Declaration public int NodeCount() Returns Type Description System.Int32 ToBoundedAreaPanels(List<Vector3>) Draw bounded areas of the network as panels. Declaration public List<Panel> ToBoundedAreaPanels(List<Vector3> allNodeLocations) Parameters Type Name Description System.Collections.Generic.List < Vector3 > allNodeLocations All node locations in the network. Returns Type Description System.Collections.Generic.List < Panel > ToModelArrows(IList<Vector3>, Nullable<Color>) Draw the network as model arrows. Declaration public ModelArrows ToModelArrows(IList<Vector3> nodeLocations, Color? color) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > nodeLocations The locations of the network's nodes. System.Nullable < Color > color The color of the resulting model geometry. Returns Type Description ModelArrows ToModelCurves(List<Vector3>) Draw the network as model curves. Declaration public List<ModelCurve> ToModelCurves(List<Vector3> nodeLocations) Parameters Type Name Description System.Collections.Generic.List < Vector3 > nodeLocations Returns Type Description System.Collections.Generic.List < ModelCurve > ToModelText(List<Vector3>, Color) Draw node indices and connected node indices at each node. Declaration public List<ModelText> ToModelText(List<Vector3> nodeLocations, Color color) Parameters Type Name Description System.Collections.Generic.List < Vector3 > nodeLocations A collection of node locations. Color color The color of the model text. Returns Type Description System.Collections.Generic.List < ModelText > Traverse(Int32, Func<(Int32, Int32, IEnumerable<Int32>), List<Vector3>, List<LocalEdge>, Int32>, List<Vector3>, List<LocalEdge>, out List<Int32>, Int32) Traverse the network from the specified node index. Traversal concludes when there are no more available nodes to traverse. Declaration public List<int> Traverse(int start, Func<(int, int, IEnumerable<int>), List<Vector3>, List<LocalEdge>, int> next, List<Vector3> allNodeLocations, List<LocalEdge> visitedEdges, out List<int> visited, int prevIndex = -1) Parameters Type Name Description System.Int32 start The starting point of the traversal. System.Func < System.ValueTuple < System.Int32 , System.Int32 , System.Collections.Generic.IEnumerable < System.Int32 >>, System.Collections.Generic.List < Vector3 >, System.Collections.Generic.List < LocalEdge >, System.Int32 > next The traversal step delegate. System.Collections.Generic.List < Vector3 > allNodeLocations A collection of all node locations in the network. System.Collections.Generic.List < LocalEdge > visitedEdges A collection of all visited edges. System.Collections.Generic.List < System.Int32 > visited A collection of visited node indices. System.Int32 prevIndex The previous index found during the traversal Returns Type Description System.Collections.Generic.List < System.Int32 > A list of indices of the traversed nodes. TraverseLargestPlaneAngle((Int32 currentIndex, Int32 previousIndex, IEnumerable<Int32> edgeIndices), List<Vector3>, List<LocalEdge>) Traverse a network following the smallest plane angle between the current edge and the next candidate edge. Declaration public static int TraverseLargestPlaneAngle((int currentIndex, int previousIndex, IEnumerable<int> edgeIndices) traversalData, List<Vector3> allNodeLocations, List<LocalEdge> visitedEdges) Parameters Type Name Description System.ValueTuple < System.Int32 , System.Int32 , System.Collections.Generic.IEnumerable < System.Int32 >> traversalData Data about the current step of the traversal. System.Collections.Generic.List < Vector3 > allNodeLocations A collection of all node locations in the network. System.Collections.Generic.List < LocalEdge > visitedEdges A collection of previously visited edges. Returns Type Description System.Int32 The next index to traverse. TraverseSmallestPlaneAngle((Int32 currentIndex, Int32 previousIndex, IEnumerable<Int32> edgeIndices), List<Vector3>, List<LocalEdge>) Traverse a network following the smallest plane angle between the current edge and the next candidate edge. Declaration public static int TraverseSmallestPlaneAngle((int currentIndex, int previousIndex, IEnumerable<int> edgeIndices) traversalData, List<Vector3> allNodeLocations, List<LocalEdge> visitedEdges) Parameters Type Name Description System.ValueTuple < System.Int32 , System.Int32 , System.Collections.Generic.IEnumerable < System.Int32 >> traversalData Data about the current step of the traversal. System.Collections.Generic.List < Vector3 > allNodeLocations A collection of all node locations in the network. System.Collections.Generic.List < LocalEdge > visitedEdges A collection of previously visited edges. Returns Type Description System.Int32 The next index to traverse."
  },
  "api/Elements.Search.PointOctree-1.html": {
    "href": "api/Elements.Search.PointOctree-1.html",
    "title": "Class PointOctree<T> | Hypar Docs",
    "keywords": "Class PointOctree<T> A Dynamic Octree for storing any objects that can be described as a single point. This is a thin wrapper around the PointOctree class from NetOctree ( https://github.com/mcserep/NetOctree ). Inheritance System.Object PointOctree<T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Search Assembly : Hypar.Elements.dll Syntax public class PointOctree<T> Type Parameters Name Description T The content of the octree can be anything, since the bounds data is supplied separately. Remarks Octree: An octree is a tree data structure which divides 3D space into smaller partitions (nodes) and places objects into the appropriate nodes. This allows fast access to objects in an area of interest without having to check every object. Dynamic: The octree grows or shrinks as required when objects as added or removed. It also splits and merges nodes as appropriate. There is no maximum depth. Constructors PointOctree(Double, Vector3, Double) Constructor for the point octree. Declaration public PointOctree(double initialWorldSize, Vector3 initialWorldPos, double minNodeSize) Parameters Type Name Description System.Double initialWorldSize Size of the sides of the initial node. The octree will never shrink smaller than this. Vector3 initialWorldPos Position of the center of the initial node. System.Double minNodeSize Nodes will stop splitting if the new nodes would be smaller than this. Properties Count The total amount of objects currently in the tree Declaration public int Count { get; } Property Value Type Description System.Int32 MaxBounds Gets the bounding box that represents the whole octree Declaration public BBox3 MaxBounds { get; } Property Value Type Description BBox3 The bounding box of the root node. Methods Add(T, Vector3) Add an object. Declaration public void Add(T obj, Vector3 objPos) Parameters Type Name Description T obj Object to add. Vector3 objPos Position of the object. GetAll() Returns all objects in the tree. If none, returns an empty array (not null). Declaration public ICollection<T> GetAll() Returns Type Description System.Collections.Generic.ICollection <T> All objects. GetNearby(Ray, Double) Returns objects that are within maxDistance of the specified ray. If none, returns an empty array (not null). Declaration public T[] GetNearby(Ray ray, double maxDistance) Parameters Type Name Description Ray ray The ray. System.Double maxDistance Maximum distance from the ray to consider. Returns Type Description T[] Objects within range. GetNearby(Vector3, Double) Returns objects that are within maxDistance of the specified position. If none, returns an empty array (not null). Declaration public T[] GetNearby(Vector3 position, double maxDistance) Parameters Type Name Description Vector3 position The position. Passing as ref to improve performance since it won't have to be copied. System.Double maxDistance Maximum distance from the position to consider. Returns Type Description T[] Objects within range. Remove(T) Remove an object. Makes the assumption that the object only exists once in the tree. Declaration public bool Remove(T obj) Parameters Type Name Description T obj Object to remove. Returns Type Description System.Boolean True if the object was removed successfully. Remove(T, Vector3) Removes the specified object at the given position. Makes the assumption that the object only exists once in the tree. Declaration public bool Remove(T obj, Vector3 objPos) Parameters Type Name Description T obj Object to remove. Vector3 objPos Position of the object. Returns Type Description System.Boolean True if the object was removed successfully."
  },
  "api/Elements.Serialization.glTF.GltfBufferExtensions.html": {
    "href": "api/Elements.Serialization.glTF.GltfBufferExtensions.html",
    "title": "Class GltfBufferExtensions | Hypar Docs",
    "keywords": "Class GltfBufferExtensions Extensions for glTF serialization. Inheritance System.Object GltfBufferExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization.glTF Assembly : Hypar.Elements.dll Syntax public static class GltfBufferExtensions"
  },
  "api/Elements.Serialization.glTF.GltfExtensions.html": {
    "href": "api/Elements.Serialization.glTF.GltfExtensions.html",
    "title": "Class GltfExtensions | Hypar Docs",
    "keywords": "Class GltfExtensions Extensions for glTF serialization. Inheritance System.Object GltfExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization.glTF Assembly : Hypar.Elements.dll Syntax public static class GltfExtensions Properties GltfCachePath In normal function use, this should be set to null. If not null and set to a valid directory path, gltfs loaded for content elements will be cached to this directory, and can be explicitly loaded by calling LoadGltfCacheFromDisk(). This is used by hypar run and test capabilities to speed up repeated runs. Declaration public static string GltfCachePath { get; set; } Property Value Type Description System.String UseReferencedContentExtension If true, the model will write content elements using an experimental GLTF extension. This extension is not yet finalized and may change. Declaration public static bool UseReferencedContentExtension { get; set; } Property Value Type Description System.Boolean Methods GetGlbStreamFromPath(String) Get a stream from a glb path, either file reference or remote. The streams are cached based on the location, so updates to files may not be reflected immediately, especially during long running parent processes. Declaration public static Stream GetGlbStreamFromPath(string gltfLocation) Parameters Type Name Description System.String gltfLocation The URI of the gltf binary file Returns Type Description System.IO.Stream ToBase64String(Model, Boolean, Boolean) Serialize the model to a base64 encoded string. Declaration public static string ToBase64String(this Model model, bool drawEdges = false, bool mergeVertices = false) Parameters Type Name Description Model model System.Boolean drawEdges System.Boolean mergeVertices Returns Type Description System.String A Base64 string representing the model. ToGlTF(Model, Boolean, Boolean) Serialize the model to a byte array. Declaration public static byte[] ToGlTF(this Model model, bool drawEdges = false, bool mergeVertices = false) Parameters Type Name Description Model model The model to serialize. System.Boolean drawEdges Should edges of the model be drawn? System.Boolean mergeVertices Should vertices be merged in the resulting output? Returns Type Description System.Byte [] A byte array representing the model. ToGlTF(Model, String, Boolean, Boolean) Serialize the model to a gltf file on disk. If there is no geometry, an empty GLTF will still be produced. Declaration public static void ToGlTF(this Model model, string path, bool useBinarySerialization = true, bool drawEdges = false) Parameters Type Name Description Model model The model to serialize. System.String path The output path. System.Boolean useBinarySerialization Should binary serialization be used? System.Boolean drawEdges Should the solid edges be written to the gltf? ToGlTF(Model, String, out List<BaseError>, Boolean, Boolean) Serialize the model to a gltf file on disk. If there is no geometry, an empty GLTF will still be produced. Declaration public static void ToGlTF(this Model model, string path, out List<BaseError> errors, bool useBinarySerialization = true, bool drawEdges = false) Parameters Type Name Description Model model The model to serialize. System.String path The output path. System.Collections.Generic.List < BaseError > errors A collection of serialization errors System.Boolean useBinarySerialization Should binary serialization be used? System.Boolean drawEdges Should the solid edges be written to the gltf?"
  },
  "api/Elements.Serialization.glTF.html": {
    "href": "api/Elements.Serialization.glTF.html",
    "title": "Namespace Elements.Serialization.glTF | Hypar Docs",
    "keywords": "Namespace Elements.Serialization.glTF Classes GltfBufferExtensions Extensions for glTF serialization. GltfExtensions Extensions for glTF serialization."
  },
  "api/Elements.Serialization.html": {
    "href": "api/Elements.Serialization.html",
    "title": "Namespace Elements.Serialization | Hypar Docs",
    "keywords": "Namespace Elements.Serialization Classes MappingConfiguration Additional metadata to guide layer creation for various output formats, such as DXF. MappingConfiguration.Layer Represents the configuration of a Layer for export. Enums MappingConfiguration.ElementColorSetting How an item on a layer should have its color determined."
  },
  "api/Elements.Serialization.JSON.html": {
    "href": "api/Elements.Serialization.JSON.html",
    "title": "Namespace Elements.Serialization.JSON | Hypar Docs",
    "keywords": "Namespace Elements.Serialization.JSON Classes JsonInheritanceConverter MeshConverter Triangle converter."
  },
  "api/Elements.Serialization.JSON.JsonInheritanceConverter.html": {
    "href": "api/Elements.Serialization.JSON.JsonInheritanceConverter.html",
    "title": "Class JsonInheritanceConverter | Hypar Docs",
    "keywords": "Class JsonInheritanceConverter Inheritance System.Object Newtonsoft.Json.JsonConverter JsonInheritanceConverter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization.JSON Assembly : Hypar.Elements.dll Syntax public class JsonInheritanceConverter : JsonConverter Constructors JsonInheritanceConverter() Declaration public JsonInheritanceConverter() JsonInheritanceConverter(String) Declaration public JsonInheritanceConverter(string discriminator) Parameters Type Name Description System.String discriminator Properties CanRead Declaration public override bool CanRead { get; } Property Value Type Description System.Boolean Overrides Newtonsoft.Json.JsonConverter.CanRead CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean Overrides Newtonsoft.Json.JsonConverter.CanWrite Elements Declaration public static Dictionary<Guid, Element> Elements { get; } Property Value Type Description System.Collections.Generic.Dictionary < System.Guid , Element > ElementwiseSerialization Declaration public static bool ElementwiseSerialization { get; set; } Property Value Type Description System.Boolean Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description System.Type objectType Returns Type Description System.Boolean Overrides Newtonsoft.Json.JsonConverter.CanConvert(System.Type) ExcludeTypePrefixesFromTypeCache(String[]) When we build up the element type cache, we iterate over all types in the app domain. Excluding other types can speed up the process and reduce deserialization issues. Declaration public static void ExcludeTypePrefixesFromTypeCache(params string[] prefixes) Parameters Type Name Description System.String [] prefixes ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonReader reader System.Type objectType System.Object existingValue Newtonsoft.Json.JsonSerializer serializer Returns Type Description System.Object Overrides Newtonsoft.Json.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader, System.Type, System.Object, Newtonsoft.Json.JsonSerializer) WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonWriter writer System.Object value Newtonsoft.Json.JsonSerializer serializer Overrides Newtonsoft.Json.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter, System.Object, Newtonsoft.Json.JsonSerializer)"
  },
  "api/Elements.Serialization.JSON.MeshConverter.html": {
    "href": "api/Elements.Serialization.JSON.MeshConverter.html",
    "title": "Class MeshConverter | Hypar Docs",
    "keywords": "Class MeshConverter Triangle converter. Inheritance System.Object Newtonsoft.Json.JsonConverter MeshConverter Inherited Members Newtonsoft.Json.JsonConverter.CanRead Newtonsoft.Json.JsonConverter.CanWrite System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization.JSON Assembly : Hypar.Elements.dll Syntax public class MeshConverter : JsonConverter Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description System.Type objectType Returns Type Description System.Boolean Overrides Newtonsoft.Json.JsonConverter.CanConvert(System.Type) ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonReader reader System.Type objectType System.Object existingValue Newtonsoft.Json.JsonSerializer serializer Returns Type Description System.Object Overrides Newtonsoft.Json.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader, System.Type, System.Object, Newtonsoft.Json.JsonSerializer) WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonWriter writer System.Object value Newtonsoft.Json.JsonSerializer serializer Overrides Newtonsoft.Json.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter, System.Object, Newtonsoft.Json.JsonSerializer)"
  },
  "api/Elements.Serialization.MappingConfiguration.ElementColorSetting.html": {
    "href": "api/Elements.Serialization.MappingConfiguration.ElementColorSetting.html",
    "title": "Enum MappingConfiguration.ElementColorSetting | Hypar Docs",
    "keywords": "Enum MappingConfiguration.ElementColorSetting How an item on a layer should have its color determined. Namespace : Elements.Serialization Assembly : Hypar.Elements.dll Syntax public enum ElementColorSetting Fields Name Description ByLayer Use the color of the item's layer (The default setting). TryGetColorFromMaterial Attempt to set the item's color based on its material."
  },
  "api/Elements.Serialization.MappingConfiguration.html": {
    "href": "api/Elements.Serialization.MappingConfiguration.html",
    "title": "Class MappingConfiguration | Hypar Docs",
    "keywords": "Class MappingConfiguration Additional metadata to guide layer creation for various output formats, such as DXF. Inheritance System.Object MappingConfiguration Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization Assembly : Hypar.Elements.dll Syntax public class MappingConfiguration Constructors MappingConfiguration() Create a new MappingConfiguration /// Declaration public MappingConfiguration() Properties Layers The layer configurations for this model. Declaration public List<MappingConfiguration.Layer> Layers { get; set; } Property Value Type Description System.Collections.Generic.List < MappingConfiguration.Layer > Methods Merge(MappingConfiguration) Merge another export configuration into this one. Declaration public void Merge(MappingConfiguration other) Parameters Type Name Description MappingConfiguration other"
  },
  "api/Elements.Serialization.MappingConfiguration.Layer.html": {
    "href": "api/Elements.Serialization.MappingConfiguration.Layer.html",
    "title": "Class MappingConfiguration.Layer | Hypar Docs",
    "keywords": "Class MappingConfiguration.Layer Represents the configuration of a Layer for export. Inheritance System.Object MappingConfiguration.Layer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Serialization Assembly : Hypar.Elements.dll Syntax public class Layer Constructors Layer() Create a new Layer configuration. Declaration public Layer() Properties ElementColorSetting How items on this layer should have their colors determined. Declaration public MappingConfiguration.ElementColorSetting ElementColorSetting { get; set; } Property Value Type Description MappingConfiguration.ElementColorSetting LayerColor The display color of the layer. Declaration public Color LayerColor { get; set; } Property Value Type Description Color LayerName The name of the layer. Declaration public string LayerName { get; set; } Property Value Type Description System.String Lineweight The linewight of the layer, in 1/100s of a millimeter. Declaration public int Lineweight { get; set; } Property Value Type Description System.Int32 Types The type names (FullNames) of element types that should be mapped to this layer. Declaration public List<string> Types { get; set; } Property Value Type Description System.Collections.Generic.List < System.String >"
  },
  "api/Elements.SetClassification.html": {
    "href": "api/Elements.SetClassification.html",
    "title": "Enum SetClassification | Hypar Docs",
    "keywords": "Enum SetClassification A set containment classification. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum SetClassification Fields Name Description AInsideB A segments inside B AOutsideB A segments outside B BInsideA B segments inside A BOutsideA B segments outside A None None"
  },
  "api/Elements.SetOperations.html": {
    "href": "api/Elements.SetOperations.html",
    "title": "Class SetOperations | Hypar Docs",
    "keywords": "Class SetOperations Operations on sets of edges. Inheritance System.Object SetOperations Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class SetOperations Methods BuildGraph(List<(Vector3 from, Vector3 to, SetClassification classification)>, IList<SetClassification>) Build a half edge graph from a collection of segments. Declaration public static HalfEdgeGraph2d BuildGraph(List<(Vector3 from, Vector3 to, SetClassification classification)> set, IList<SetClassification> boundaryClassifications = null) Parameters Type Name Description System.Collections.Generic.List < System.ValueTuple < Vector3 , Vector3 , SetClassification >> set A collection of classified segments. System.Collections.Generic.IList < SetClassification > boundaryClassifications A list of boundary classifications where edges will be created running in both directions. This is required for situations where the graph will be expected to produce multiple polygons with shared edges. Returns Type Description HalfEdgeGraph2d ClassifySegments2d(Polygon, Polygon, Func<(Vector3 from, Vector3 to, SetClassification classification), Boolean>) Intersect all segments in each polygon against all segments in the other polygon, splitting segments, and classify all the resulting segments. Declaration public static List<(Vector3 from, Vector3 to, SetClassification classification)> ClassifySegments2d(Polygon a, Polygon b, Func<(Vector3 from, Vector3 to, SetClassification classification), bool> filter = null) Parameters Type Name Description Polygon a Polygon b System.Func < System.ValueTuple < Vector3 , Vector3 , SetClassification >, System.Boolean > filter Returns Type Description System.Collections.Generic.List < System.ValueTuple < Vector3 , Vector3 , SetClassification >>"
  },
  "api/Elements.SolidCeiling.html": {
    "href": "api/Elements.SolidCeiling.html",
    "title": "Class SolidCeiling | Hypar Docs",
    "keywords": "Class SolidCeiling A ceiling defined by a planar profile extruded to a thickness. Inheritance System.Object Element GeometricElement BaseCeiling SolidCeiling Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members BaseCeiling.Elevation BaseCeiling.Perimeter GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class SolidCeiling : BaseCeiling, INotifyPropertyChanged, IHasOpenings Constructors SolidCeiling(Polygon, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling by extruding a profile. Declaration public SolidCeiling(Polygon perimeter, double thickness, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan perimeter of the ceiling. It must lie on the XY plane. Z coordinate will be used as elevation System.Double thickness The thickness of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. SolidCeiling(Polygon, Double, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling by extruding a profile. Declaration public SolidCeiling(Polygon perimeter, double thickness, double elevation, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double thickness The thickness of the ceiling. System.Double elevation The elevation of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. SolidCeiling(Polygon, Double, Double, Guid, Material, Transform, Representation, Boolean, String) Construct a ceiling by extruding a profile. It's a private constructor that doesn't add elevation to transform Declaration [JsonConstructor] protected SolidCeiling(Polygon perimeter, double thickness, double elevation, Guid id = default(Guid), Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double thickness The thickness of the ceiling. System.Double elevation The elevation of the ceiling. System.Guid id The id of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.String name The name of the ceiling. Properties Openings A collection of openings in the ceiling. Declaration public List<Opening> Openings { get; } Property Value Type Description System.Collections.Generic.List < Opening > Thickness The thickness of the ceiling. Declaration public double Thickness { get; protected set; } Property Value Type Description System.Double Methods AddOpening(Polygon) Add an Opening to the Ceiling. Declaration public void AddOpening(Polygon perimeter) Parameters Type Name Description Polygon perimeter The plan perimeter of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored GetProfile() The Profile of the Ceiling computed from its Perimeter and the Openings. Declaration public Profile GetProfile() Returns Type Description Profile UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Space.html": {
    "href": "api/Elements.Space.html",
    "title": "Class Space | Hypar Docs",
    "keywords": "Class Space An extruded region of occupiable space. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Space.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a space. var a = new Vector3(); var b = new Vector3(30, 10); var c = new Vector3(20, 50); var d = new Vector3(-10, 5); var profile = new Profile(new Polygon(new[]{a,b,c,d})); var space = new Space(profile, 10); Inheritance System.Object Element GeometricElement Space Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Space : GeometricElement, INotifyPropertyChanged Constructors Space(Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a space. Declaration [JsonConstructor] public Space(Profile profile, double height, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The profile of the space. System.Double height The height of the space. Material material The space's material. Transform transform The space's transform. Representation representation The space's represenation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the space. System.String name The name of the space. Space(Solid, Transform, Material, Boolean, Guid, String) Construct a space from a solid. Declaration public Space(Solid geometry, Transform transform = null, Material material = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Solid geometry The solid which will be used to define the space. Transform transform The transform of the space. Material material The space's material. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the space. System.String name The name of the space. Properties Height The space's height. Declaration public double Height { get; set; } Property Value Type Description System.Double Profile The profile of the space. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Methods Area() The spaces's area. Declaration public double Area() Returns Type Description System.Double ProfileTransformed() Get the profile of the space transformed by the space's transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() The spaces's volume. Declaration public double Volume() Returns Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Spatial.AdaptiveGrid.AdaptiveGraphRouting.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.AdaptiveGraphRouting.html",
    "title": "Class AdaptiveGraphRouting | Hypar Docs",
    "keywords": "Class AdaptiveGraphRouting Class for routing through an AdaptiveGrid. Inheritance System.Object AdaptiveGraphRouting Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class AdaptiveGraphRouting Constructors AdaptiveGraphRouting(AdaptiveGrid, RoutingConfiguration) Create AdaptiveGraphRouting objects and store core parameters for further use. Declaration public AdaptiveGraphRouting(AdaptiveGrid grid, RoutingConfiguration configuration) Parameters Type Name Description AdaptiveGrid grid AdaptiveGrid the algorithm travels through. RoutingConfiguration configuration Storage for common parameters that affect routing. Fields ErrorMessages List of error messages that occur during routing. Are reset on the beginning of each routing operation. Declaration public List<Message> ErrorMessages Field Value Type Description System.Collections.Generic.List < Message > Methods AddPlanarWeightModifier(String, Plane, Double, String) Create WeightModifier that sets the factor on all edges lying on a given plane. Declaration public WeightModifier AddPlanarWeightModifier(string name, Plane plane, double factor, string group = null) Parameters Type Name Description System.String name Name of new WeightModifier. Plane plane Plane to check if edge lays on. System.Double factor Factor of new WeightModifier. System.String group Group name of new WeightModifier. Returns Type Description WeightModifier Created WeightModifier. AddPolylineWeightModifier(String, Polyline, Double, Double, Boolean, String) Create WeightModifier that sets the factor on all edges parallel(both points must be withing influence radius of the polyline) or intersecting with given polyline. Declaration public WeightModifier AddPolylineWeightModifier(string name, Polyline polyline, double factor, double influenceDistance, bool is2D, string group = null) Parameters Type Name Description System.String name Name of new WeightModifier. Polyline polyline Polyline to check if edge is affected or intersected. System.Double factor Factor of new WeightModifier. System.Double influenceDistance Influence radius of polyline. System.Boolean is2D Whether edge and polyline comparison should be considered in 2d or 3d. System.String group Group name of new WeightModifier. Returns Type Description WeightModifier Created WeightModifier. AddRoutingFilter(AdaptiveGraphRouting.RoutingFilter) Routing supports checking if a Vertex can be added to the path. New vertex must pass all filter functions to be accepted. Declaration public void AddRoutingFilter(AdaptiveGraphRouting.RoutingFilter f) Parameters Type Name Description AdaptiveGraphRouting.RoutingFilter f New filter function. AddWeightModifier(WeightModifier) Add WeightModifier to the dictionary of modifiers. Declaration public void AddWeightModifier(WeightModifier modifier) Parameters Type Name Description WeightModifier modifier WeightModifier to add. AggregateFactorMax(Double, Double) Return maximum of factors. Declaration public static double AggregateFactorMax(double a, double b) Parameters Type Name Description System.Double a First factor. System.Double b Second factor. Returns Type Description System.Double Maximum of factors. AggregateFactorMin(Double, Double) Return minimum of factors. Declaration public static double AggregateFactorMin(double a, double b) Parameters Type Name Description System.Double a First factor. System.Double b Second factor. Returns Type Description System.Double Minimum of factors. AggregateFactorMultiply(Double, Double) Multiply factors. Declaration public static double AggregateFactorMultiply(double a, double b) Parameters Type Name Description System.Double a First factor. System.Double b Second factor. Returns Type Description System.Double Result of multiplication of factors. BuildSimpleNetwork(IList<RoutingVertex>, IList<UInt64>, IEnumerable<RoutingHintLine>) Create network of routes between set of input Vertices and set of exit Vertices. Each route is most efficient individually, without considering other routes. Each route is connected to the network using Dijkstra algorithm. Declaration public IDictionary<ulong, TreeNode> BuildSimpleNetwork(IList<RoutingVertex> leafVertices, IList<ulong> exits, IEnumerable<RoutingHintLine> hintLines = null) Parameters Type Name Description System.Collections.Generic.IList < RoutingVertex > leafVertices Vertices to connect into the system with extra information attached. System.Collections.Generic.IList < System.UInt64 > exits Possible exit vertices. System.Collections.Generic.IEnumerable < RoutingHintLine > hintLines Collection of lines that routes are attracted to. Returns Type Description System.Collections.Generic.IDictionary < System.UInt64 , TreeNode > Travel tree from inputVertices to one of the exits. BuildSpanningTree(IList<RoutingVertex>, UInt64, IEnumerable<RoutingHintLine>, TreeOrder) Creates tree of routes between set of input Vertices and the exit Vertex. Routes merge together to form a single trunk. Starting from end, point by point, vertices are connected to the network using Dijkstra algorithm. Declaration public IDictionary<ulong, TreeNode> BuildSpanningTree(IList<RoutingVertex> leafVertices, ulong trunkVertex, IEnumerable<RoutingHintLine> hintLines, TreeOrder order) Parameters Type Name Description System.Collections.Generic.IList < RoutingVertex > leafVertices Vertices to connect into the system with extra information attached. System.UInt64 trunkVertex End vertex id. System.Collections.Generic.IEnumerable < RoutingHintLine > hintLines Collection of lines that routes are attracted to. At least one hint line is required. TreeOrder order In which order tree is constructed Returns Type Description System.Collections.Generic.IDictionary < System.UInt64 , TreeNode > Travel tree from inputVertices to the trunkVertex. BuildSpanningTree(IList<List<RoutingVertex>>, UInt64, IList<List<RoutingHintLine>>, TreeOrder) Creates tree of routes between multiple sections, each having a set of input Vertices, hint lines and local end Vertex, and the exit Vertex. Route is created by using Dijkstra algorithm locally on different segments. Segments are merged together to form a single trunk. Starting from end, point by point, segments are connected. Then, Vertices in each segments are connected as well, forming a local trunk, connected with the main one. All parameter except \"trunkPathVertices\" are provided per section in the same order. Declaration public IDictionary<ulong, TreeNode> BuildSpanningTree(IList<List<RoutingVertex>> leafVertices, ulong trunkVertex, IList<List<RoutingHintLine>> hintLines, TreeOrder order) Parameters Type Name Description System.Collections.Generic.IList < System.Collections.Generic.List < RoutingVertex >> leafVertices Vertices to connect into the system with extra information attached. System.UInt64 trunkVertex End vertex id. System.Collections.Generic.IList < System.Collections.Generic.List < RoutingHintLine >> hintLines Collection of lines that routes are attracted to. At least one hint line per group is required. TreeOrder order In which order tree is constructed Returns Type Description System.Collections.Generic.IDictionary < System.UInt64 , TreeNode > Travel tree from inputVertices to the trunkVertex. ClearWeightModifiers() Remove all WeightModifier from the dictionary of modifiers. Declaration public void ClearWeightModifiers() GetWeightModifier(String) Get WeightModifier with given name. Declaration public WeightModifier GetWeightModifier(string name) Parameters Type Name Description System.String name Name of WeightModifier. Returns Type Description WeightModifier WeightModifier object. GetWeightModifiersGroup(String) Get list of WeightModifier with specified group name. Declaration public List<WeightModifier> GetWeightModifiersGroup(string groupName) Parameters Type Name Description System.String groupName Group name. Must be not null. Returns Type Description System.Collections.Generic.List < WeightModifier > List of WeightModifier with the specified group name. Exceptions Type Condition System.ArgumentNullException Throws if groupName is null. RemoveWeightModifier(WeightModifier) Remove WeightModifier from the dictionary of modifiers. Declaration public bool RemoveWeightModifier(WeightModifier modifier) Parameters Type Name Description WeightModifier modifier WeightModifier to remove. Returns Type Description System.Boolean False if WeightModifier is not present in the dictionary of modifiers. RenderElements(IList<RoutingHintLine>, IList<Vector3>) Visualize adaptive graph edges. Material depends on elevation and proximity to different hint lines. Original split points are not stored in the graph, so they need to be provided. Declaration public IList<Element> RenderElements(IList<RoutingHintLine> hintLines, IList<Vector3> splitPoints) Parameters Type Name Description System.Collections.Generic.IList < RoutingHintLine > hintLines List of hint lines. System.Collections.Generic.IList < Vector3 > splitPoints List of split points to visualize Returns Type Description System.Collections.Generic.IList < Element > List of graphics elements SetWeightModifiersGroupAggregator(String, Func<Double, Double, Double>) Set factor aggregator function for weight modifiers group. The aggregator function will be applied to any list of weight modifications that share a group name. This ensures that if a type of modifier is applied to a single edge more than once we have options for how to apply duplicate modifiers. AggregateFactorMin(Double, Double) AggregateFactorMax(Double, Double) AggregateFactorMultiply(Double, Double) Declaration public void SetWeightModifiersGroupAggregator(string groupName, Func<double, double, double> groupFactorAggregator) Parameters Type Name Description System.String groupName Group name. System.Func < System.Double , System.Double , System.Double > groupFactorAggregator Factor aggregator function. ShortestBranchesDijkstra(UInt64, Dictionary<UInt64, EdgeInfo>, out Dictionary<UInt64, (Double, Double)>, Nullable<UInt64>, HashSet<UInt64>) This is a Dijkstra algorithm implementation that stores up to two different paths per vertex. The algorithm travels from start point to all other points, gathering travel cost. Each time route turns - extra penalty is added to the cost. Higher level algorithm then decides which one of them to use as an end point. Produced dictionary has \"Left/Right\" label using which two best routes per vertex can be retried. Declaration public Dictionary<ulong, ((ulong, BranchSide), (ulong, BranchSide))> ShortestBranchesDijkstra(ulong start, Dictionary<ulong, EdgeInfo> edgeInfos, out Dictionary<ulong, (double, double)> travelCost, ulong? startDirection = null, HashSet<ulong> excluded = null) Parameters Type Name Description System.UInt64 start Start Vertex System.Collections.Generic.Dictionary < System.UInt64 , EdgeInfo > edgeInfos Dictionary of Edge Id to precomputed information about it System.Collections.Generic.Dictionary < System.UInt64 , System.ValueTuple < System.Double , System.Double >> travelCost Output dictionary where traveling costs are stored per Vertex for two possible branches System.Nullable < System.UInt64 > startDirection Previous Vertex, if start Vertex is already part of the Route System.Collections.Generic.HashSet < System.UInt64 > excluded Vertices that are not allowed to visit Returns Type Description System.Collections.Generic.Dictionary < System.UInt64 , System.ValueTuple < System.ValueTuple < System.UInt64 , BranchSide >, System.ValueTuple < System.UInt64 , BranchSide >>> Dictionary that have two travel routes from each Vertex back to start Vertex. ShortestPathDijkstra(UInt64, Dictionary<UInt64, EdgeInfo>, out Dictionary<UInt64, Double>, Nullable<UInt64>, HashSet<UInt64>, Dictionary<UInt64, Nullable<UInt64>>) This is a Dijkstra algorithm implementation. The algorithm travels from start point to all other points, gathering travel cost. Each time route turns - extra penalty is added to the cost. Higher level algorithm then decides which one of them to use as an end point. Declaration public Dictionary<ulong, ulong> ShortestPathDijkstra(ulong start, Dictionary<ulong, EdgeInfo> edgeInfos, out Dictionary<ulong, double> travelCost, ulong? startDirection = null, HashSet<ulong> excluded = null, Dictionary<ulong, ulong?> pathDirections = null) Parameters Type Name Description System.UInt64 start Start Vertex System.Collections.Generic.Dictionary < System.UInt64 , EdgeInfo > edgeInfos Dictionary of Edge Id to precomputed information about it System.Collections.Generic.Dictionary < System.UInt64 , System.Double > travelCost Output dictionary where traveling cost is stored per Vertex System.Nullable < System.UInt64 > startDirection Previous Vertex, if start Vertex is already part of the Route System.Collections.Generic.HashSet < System.UInt64 > excluded Vertices that are not allowed to visit System.Collections.Generic.Dictionary < System.UInt64 , System.Nullable < System.UInt64 >> pathDirections Next Vertex dictionary for Vertices that are already part of the route Returns Type Description System.Collections.Generic.Dictionary < System.UInt64 , System.UInt64 > Dictionary that have travel routes from each Vertex back to start Vertex."
  },
  "api/Elements.Spatial.AdaptiveGrid.AdaptiveGraphRouting.RoutingFilter.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.AdaptiveGraphRouting.RoutingFilter.html",
    "title": "Delegate AdaptiveGraphRouting.RoutingFilter | Hypar Docs",
    "keywords": "Delegate AdaptiveGraphRouting.RoutingFilter Filter function definition. Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public delegate bool RoutingFilter(Vertex start, Vertex end); Parameters Type Name Description Vertex start Last Vertex in the route. Vertex end Candidate for the next Vertex in the route. Returns Type Description System.Boolean"
  },
  "api/Elements.Spatial.AdaptiveGrid.AdaptiveGrid.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.AdaptiveGrid.html",
    "title": "Class AdaptiveGrid | Hypar Docs",
    "keywords": "Class AdaptiveGrid A graph like edge-vertex structure with planar spaces connected by vertical edges. The grid doesn't do any intersections when new sections are added, they are stitched only by common vertices. Make sure that regions that are added into the graph are aligned with respect to boundaries and split points. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Spatial_AdaptiveGrid_AdaptiveGrid.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples var adaptiveGrid = new AdaptiveGrid(); var points = new List<Vector3>() { new Vector3(-6, -4), new Vector3(-2, -4), new Vector3(3, -4), new Vector3(1, 4.5), new Vector3(6, 3), }; adaptiveGrid.AddFromPolygon(Polygon.Rectangle(15, 10).TransformedPolygon( new Transform(new Vector3(), new Vector3(10, 0, 10))), points); Inheritance System.Object AdaptiveGrid Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class AdaptiveGrid Constructors AdaptiveGrid() Create default AdaptiveGrid Declaration public AdaptiveGrid() AdaptiveGrid(Transform) Create an AdaptiveGrid with custom transformation. Declaration public AdaptiveGrid(Transform transform) Parameters Type Name Description Transform transform Transformation, grid is aligned with. Properties Boundaries Grid boundary used in obstacle perimeter clipping. Can be null. Declaration public Polygon Boundaries { get; set; } Property Value Type Description Polygon HintExtendDistance Maximum distance for line segments of hints lines to extend to other existing edges. Declaration public double HintExtendDistance { get; set; } Property Value Type Description System.Double Tolerance Distance tolerance for points being considered the same. Tolerance is twice the epsilon because grid uses single tolerance for individual coordinates snapping. Declaration public double Tolerance { get; } Property Value Type Description System.Double Transform Transformation with which planar spaces are aligned Declaration public Transform Transform { get; set; } Property Value Type Description Transform Methods AddEdge(Vector3, Vector3, Boolean) Add an edge between two vertices represented by their position. Positions that are not yet present in the grid are created as new vertices. Declaration public List<Edge> AddEdge(Vector3 a, Vector3 b, bool cut = true) Parameters Type Name Description Vector3 a Vector3 b System.Boolean cut Intersect new edge with existing edges. Returns Type Description System.Collections.Generic.List < Edge > Edges between two vertices. Single if cut is false. AddEdge(Vertex, Vertex, Boolean) Add an edge between two vertices. Declaration public List<Edge> AddEdge(Vertex a, Vertex b, bool cut = true) Parameters Type Name Description Vertex a First vertex. Vertex b Second vertex. System.Boolean cut Intersect new edge with existing edges. Returns Type Description System.Collections.Generic.List < Edge > Edges between two vertices. Single if cut is false. AddEdge(UInt64, UInt64, Boolean) Add an edge between two vertices represented by their ids. Declaration public List<Edge> AddEdge(ulong vertexId1, ulong vertexId2, bool cut = true) Parameters Type Name Description System.UInt64 vertexId1 Id of the first vertex. System.UInt64 vertexId2 Id of the second vertex. System.Boolean cut Intersect new edge with existing edges. Returns Type Description System.Collections.Generic.List < Edge > Edges between two vertices. Single if cut is false. AddFromBbox(BBox3, List<Vector3>) Add graph section using bounding box, divided by a set of key points. Key points don't respect \"MinimumResolution\" at the moment. Any vertices that already exist are not created but reused. This way new region is connected with the rest of the graph. Declaration public void AddFromBbox(BBox3 bBox, List<Vector3> keyPoints) Parameters Type Name Description BBox3 bBox Box which region is populated with graph. System.Collections.Generic.List < Vector3 > keyPoints Set of 3D points, region is split with. Examples var adaptiveGrid = new AdaptiveGrid(); var points = new List<Vector3>() { new Vector3(-6, -4), new Vector3(-2, -4), new Vector3(3, -4), new Vector3(1, 4.5, 3), new Vector3(6, 3, -2), }; adaptiveGrid.AddFromBbox(new BBox3(new Vector3(-7.5, -5, -3), new Vector3(10, 10, 3)), points); points = new List<Vector3>() { new Vector3(-6, -4, 3), new Vector3(-2, 0, 3), new Vector3(0, 4, 3), new Vector3(2, 6, 3) }; var rectangle = Polygon.Rectangle(new Vector3(-10, -5), new Vector3(15, 10)); adaptiveGrid.AddFromPolygon(rectangle.TransformedPolygon(new Transform(new Vector3(0, 0, 3))), points); points = new List<Vector3>() { new Vector3(-6, -4, 2), new Vector3(-2, 0, 2), new Vector3(0, 4, 2), new Vector3(2, 6, 2) }; adaptiveGrid.AddFromPolygon(rectangle.TransformedPolygon(new Transform(new Vector3(0, 0, 2))), points); AddFromExtrude(Polygon, Vector3, Double, List<Vector3>) Add graph section using polygon, extruded in given direction. Any vertices that already exist are not created but reused. This way new region is connected with the rest of the graph. Declaration public void AddFromExtrude(Polygon boundingPolygon, Vector3 extrusionAxis, double distance, List<Vector3> keyPoints) Parameters Type Name Description Polygon boundingPolygon Base polygon Vector3 extrusionAxis Extrusion direction System.Double distance Height of polygon extrusion System.Collections.Generic.List < Vector3 > keyPoints Set of 3D points, region is split with. AddFromPolygon(Polygon, IEnumerable<Vector3>) Add single planar region to the graph section using polygon. Any vertices that already exist are not created but reused. This way new region is connected with the rest of the graph. Declaration public HashSet<Edge> AddFromPolygon(Polygon boundingPolygon, IEnumerable<Vector3> keyPoints) Parameters Type Name Description Polygon boundingPolygon Base polygon System.Collections.Generic.IEnumerable < Vector3 > keyPoints Set of 3D points, region is split with. Returns Type Description System.Collections.Generic.HashSet < Edge > AddVertex(Vector3) Add a Vertex or return existing one if it's withing grid tolerance. Doesn't connect new Vertex to the grid with edges. Declaration public Vertex AddVertex(Vector3 point) Parameters Type Name Description Vector3 point Position of required vertex Returns Type Description Vertex New or existing Vertex. AddVertex(Vector3, IAddVertexStrategy, Boolean) Add a Vertex and connect in to one or more other vertices. Declaration public Vertex AddVertex(Vector3 point, IAddVertexStrategy strategy, bool cut = true) Parameters Type Name Description Vector3 point Position of required Vertex. IAddVertexStrategy strategy Vertex insertion strategy. System.Boolean cut Should new edges be intersected with existing edges. Returns Type Description Vertex New Vertex or existing one if it's within grid tolerance. AddVertices(IList<Vector3>, AdaptiveGrid.VerticesInsertionMethod) Create a chain of vertices. Exact behavior depends on the method used. Declaration public List<Vertex> AddVertices(IList<Vector3> points, AdaptiveGrid.VerticesInsertionMethod method) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points List of points to insert. Must have at least two points. AdaptiveGrid.VerticesInsertionMethod method Insertion method. Returns Type Description System.Collections.Generic.List < Vertex > Vertices in order between provided points. Depends on used method. AddVerticesWithCustomExtension(IList<Vector3>, Double) Intersect points into grid and connect them into edges. New edges are intersected along intersection points. End points of each segment are extended up to given distance until the next hit on both sides. If not extended, point is connected to the grid at its position. Declaration public List<Vertex> AddVerticesWithCustomExtension(IList<Vector3> points, double extendDistance) Parameters Type Name Description System.Collections.Generic.IList < Vector3 > points Points to add and connect to the grid. System.Double extendDistance Distance at which lines are extended to existing edges. Returns Type Description System.Collections.Generic.List < Vertex > Vertices in order they are inserted, including already existing. Can contain duplicates. ClosestEdge(Vector3, out Vector3) Find closest Edge on the grid to given location. If several edges are no the same closest distance - first found is returned. Declaration public Edge ClosestEdge(Vector3 location, out Vector3 point) Parameters Type Name Description Vector3 location Position to which closest Vertex is searched. Vector3 point Closest point of the found edge line. Returns Type Description Edge Closest Edge ClosestVertex(Vector3) Find closest Vertex on the grid to given location. If several vertices are no the same closest distance - first found is returned. Declaration public Vertex ClosestVertex(Vector3 location) Parameters Type Name Description Vector3 location Position to which closest Vertex is searched. Returns Type Description Vertex Closest Vertex CutEdge(Edge, Vector3) Split provided edge by given point. Edge is removed and replaced by two new edges. New vertex position is not required to be in the edge line. Declaration public Vertex CutEdge(Edge edge, Vector3 position) Parameters Type Name Description Edge edge Edge to cut. Vector3 position Cut position where new Vertex is created. Returns Type Description Vertex New Vertex at cut position. GetEdges() Get all Edges. Declaration public List<Edge> GetEdges() Returns Type Description System.Collections.Generic.List < Edge > GetLine(Edge) Get the geometry that represents this Edge or DirectedEdge. Declaration public Line GetLine(Edge edge) Parameters Type Name Description Edge edge Returns Type Description Line GetVertex(UInt64) Get a Vertex by its ID. Declaration public Vertex GetVertex(ulong vertexId) Parameters Type Name Description System.UInt64 vertexId Returns Type Description Vertex GetVertices() Get all Vertices. Declaration public List<Vertex> GetVertices() Returns Type Description System.Collections.Generic.List < Vertex > GetVertices(Edge) Get associated Vertices. Declaration public List<Vertex> GetVertices(Edge edge) Parameters Type Name Description Edge edge Returns Type Description System.Collections.Generic.List < Vertex > InsertSnapshot(List<(Vector3 Start, Vector3 End)>, Transform, Boolean) Duplicate stored edges with transformation applied. Use with InsertSnapshot to move a list of existing or previously existed edges to the new location, for example, copy edges from one elevation to another. Declaration public void InsertSnapshot(List<(Vector3 Start, Vector3 End)> storedEdges, Transform transform, bool connect = true) Parameters Type Name Description System.Collections.Generic.List < System.ValueTuple < Vector3 , Vector3 >> storedEdges Edge positions to duplicate. Transform transform Transformation to apply to all of the new edges. System.Boolean connect Optional. Connect each new vertex with it's original vertex if it still exist. RemoveEdge(Edge) Remove the Edge from the grid. Declaration public void RemoveEdge(Edge edge) Parameters Type Name Description Edge edge Edge to delete RemoveVertex(Vertex) Remove the Vertex from the grid. All it's edges are removed as well, including any neighbor vertices that are left without edges. Declaration public void RemoveVertex(Vertex v) Parameters Type Name Description Vertex v Vertex to delete. SnapshotEdgesOnPlane(Plane, IEnumerable<Edge>) Store points of edges both vertices of which are located at the given plane. Use with InsertSnapshot to duplicate vertices to a new elevation, while allowing modification of the original edges before duplication takes place. Declaration public List<(Vector3 Start, Vector3 End)> SnapshotEdgesOnPlane(Plane plane, IEnumerable<Edge> edgesToCheck = null) Parameters Type Name Description Plane plane Plane to retrieve edges from. System.Collections.Generic.IEnumerable < Edge > edgesToCheck Optional. Edges to check, all by default . Returns Type Description System.Collections.Generic.List < System.ValueTuple < Vector3 , Vector3 >> Position pair for each edge stored. SubtractObstacle(Obstacle) Intersect the grid with an obstacle, defined from a set of points with offset. Declaration public bool SubtractObstacle(Obstacle obstacle) Parameters Type Name Description Obstacle obstacle Obstacle object. Returns Type Description System.Boolean True if obstacle intersects with any edge on the grid. SubtractObstacles(IEnumerable<Obstacle>) Intersect the grid with a list of obstacles. Declaration public bool SubtractObstacles(IEnumerable<Obstacle> obstacles) Parameters Type Name Description System.Collections.Generic.IEnumerable < Obstacle > obstacles List of obstacles. Returns Type Description System.Boolean True if any obstacle intersects with any edge on the grid. TryGetVertexIndex(Vector3, out UInt64) Whether a vertex location already exists in the AdaptiveGrid. A vertex with each coordinate less than AdaptiveGrid.Tolerance away is considered suitable. Declaration public bool TryGetVertexIndex(Vector3 point, out ulong id) Parameters Type Name Description Vector3 point System.UInt64 id The ID of the Vertex, if a match is found. Returns Type Description System.Boolean True if any Vertex is close enough."
  },
  "api/Elements.Spatial.AdaptiveGrid.AdaptiveGrid.VerticesInsertionMethod.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.AdaptiveGrid.VerticesInsertionMethod.html",
    "title": "Enum AdaptiveGrid.VerticesInsertionMethod | Hypar Docs",
    "keywords": "Enum AdaptiveGrid.VerticesInsertionMethod Execution style for AddVertices function. Each option performs more operations than the previous one. Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public enum VerticesInsertionMethod Fields Name Description Connect Insert vertices and connect them to each other. Inserted vertices are returned in order. ConnectAndCut Insert vertices and connect them to each other. New vertices are inserted where new edges intersect with existing edges. All vertices are returned in order from first vertex to the last including all intersection vertices. ConnectAndSelfIntersect Insert vertices and connect them to each other. Find any intersections between new edges. Inserted vertices are returned in order including self intersection vertices twice. ConnectCutAndExtend Insert vertices and connect them to each other. New vertices are inserted where new edges intersect with existing edges. Each vertex is extended in direction of two neighbor edges until first hit. Extensions are done even if vertex is already on an edge. All vertices are returned in order from first vertex to the last including all intersection and extension vertices. Insert Just put vertices into the grid without connecting them. Inserted vertices are returned in order."
  },
  "api/Elements.Spatial.AdaptiveGrid.BranchSide.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.BranchSide.html",
    "title": "Enum BranchSide | Hypar Docs",
    "keywords": "Enum BranchSide Enumeration that indicates one of two possible paths in routing. There are cases when we need to collect more than one path and only after some time we can decide which one is better. Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public enum BranchSide Fields Name Description Left Indicator that first, \"left\", path is preferred. Right Indicator that second, \"right\" path is preferred."
  },
  "api/Elements.Spatial.AdaptiveGrid.ConnectVertexStrategy.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.ConnectVertexStrategy.html",
    "title": "Class ConnectVertexStrategy | Hypar Docs",
    "keywords": "Class ConnectVertexStrategy Connect strategy creates edges between new vertex created from base position and any number of given vertices. Inheritance System.Object ConnectVertexStrategy Implements IAddVertexStrategy Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class ConnectVertexStrategy : IAddVertexStrategy Constructors ConnectVertexStrategy(Vertex[]) Create new Connect strategy. Declaration public ConnectVertexStrategy(params Vertex[] connections) Parameters Type Name Description Vertex [] connections Vertices to connect with. Methods Add(AdaptiveGrid, Vector3, Boolean) Function called by grid were new vertices are added and connected. Declaration public Vertex Add(AdaptiveGrid grid, Vector3 position, bool cut) Parameters Type Name Description AdaptiveGrid grid Grid to add vertices into Vector3 position Position of base vertex. System.Boolean cut Should new edges be automatically cut with the rest of the grid. Returns Type Description Vertex Implements IAddVertexStrategy"
  },
  "api/Elements.Spatial.AdaptiveGrid.ConnectVertexWithAngleStrategy.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.ConnectVertexWithAngleStrategy.html",
    "title": "Class ConnectVertexWithAngleStrategy | Hypar Docs",
    "keywords": "Class ConnectVertexWithAngleStrategy ConnectWithAngle strategy that connects two points in a way so incoming edge of other vertex has certain angle with given direction. Creates one middle vertex to achieve this but it can be skipped if two points are already aligned. Inheritance System.Object ConnectVertexWithAngleStrategy Implements IAddVertexStrategy Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class ConnectVertexWithAngleStrategy : IAddVertexStrategy Constructors ConnectVertexWithAngleStrategy(Vector3, Vector3, Double) Create new ConnectWithAngle strategy. Declaration public ConnectVertexWithAngleStrategy(Vector3 other, Vector3 direction, double angle) Parameters Type Name Description Vector3 other Other position to connect. Vector3 direction Reference direction. System.Double angle Required angle between edge incoming into other vertex and referenced direction. Properties EndVertex Created end vertex. Declaration public Vertex EndVertex { get; } Property Value Type Description Vertex MiddleVertex Created middle vertex. Declaration public Vertex MiddleVertex { get; } Property Value Type Description Vertex Methods Add(AdaptiveGrid, Vector3, Boolean) Function called by grid were new vertices are added and connected. Declaration public Vertex Add(AdaptiveGrid grid, Vector3 position, bool cut) Parameters Type Name Description AdaptiveGrid grid Grid to add vertices into Vector3 position Position of base vertex. System.Boolean cut Should new edges be automatically cut with the rest of the grid. Returns Type Description Vertex Implements IAddVertexStrategy"
  },
  "api/Elements.Spatial.AdaptiveGrid.Edge.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.Edge.html",
    "title": "Class Edge | Hypar Docs",
    "keywords": "Class Edge A unique edge in a adaptive grid, connecting two vertices. Don't have a particular direction. Class is forked from CellComplex.Edge. Inheritance System.Object Edge Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class Edge Fields EndId ID of end Vertex. Declaration public ulong EndId Field Value Type Description System.UInt64 StartId ID of start Vertex. Declaration public ulong StartId Field Value Type Description System.UInt64 Properties Id ID of this child. Declaration public ulong Id { get; } Property Value Type Description System.UInt64 Methods Equals(Object) Used to handle comparisons for when we make HashSets of this type. Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) GetHashCode() Used to return a unique identifier for when we make HashSets of this type. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() OtherVertexId(UInt64) ID of other Vertex of this Edge. Declaration public ulong OtherVertexId(ulong vertexId) Parameters Type Name Description System.UInt64 vertexId ID of one of edge vertices. Exception is thrown if not present. Returns Type Description System.UInt64"
  },
  "api/Elements.Spatial.AdaptiveGrid.EdgeFlags.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.EdgeFlags.html",
    "title": "Enum EdgeFlags | Hypar Docs",
    "keywords": "Enum EdgeFlags Bit set of flags storing information about edge. Each flag is set to it's own number - power of 2, so they can be safely combined. Use | or |= to combine flags: flag = Hint2D | HasVerticalChange = 1 + 4 = 001 + 100 = 101 = 5. Use & or &= to check of one or more flags: flags & Hint3D == 101 & 010 == 0 == None, but flags & Hint2D == 101 & 001 == 001 == Hint2D. Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax [Flags] public enum EdgeFlags Fields Name Description HasVerticalChange Are edge end points on different elevations. HiddenHint Is edge affected by hidden hint line. HiddenHint2D Is edge affected by hidden 2D hint line. HiddenHint3D Is edge affected by hidden 2D hint line. None No flags set. UserDefinedHint Is edge affected by hidden hint line. UserDefinedHint2D Is edge affected by user defined 2D hint line. UserDefinedHint3D Is edge affected by user defined 3D hint line."
  },
  "api/Elements.Spatial.AdaptiveGrid.EdgeInfo.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.EdgeInfo.html",
    "title": "Struct EdgeInfo | Hypar Docs",
    "keywords": "Struct EdgeInfo Precalculated information about the edge. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public struct EdgeInfo Constructors EdgeInfo(AdaptiveGrid, Edge, Double) Construct new EdgeInfo structure. Declaration public EdgeInfo(AdaptiveGrid grid, Edge edge, double factor = 1) Parameters Type Name Description AdaptiveGrid grid Grid, edge belongs to. Edge edge The edge. System.Double factor Edge traveling factor. Fields Edge The Edge. Declaration public readonly Edge Edge Field Value Type Description Edge Factor Edge traveling factor. Declaration public readonly double Factor Field Value Type Description System.Double Length Length of the edge. Declaration public readonly double Length Field Value Type Description System.Double Properties HasVerticalChange Are edge end points on different elevations. Declaration public readonly bool HasVerticalChange { get; } Property Value Type Description System.Boolean Methods AddFlags(EdgeFlags) Add a flag or combinations of flags. Adding a flag more than once has no effect. Declaration public void AddFlags(EdgeFlags flags) Parameters Type Name Description EdgeFlags flags Flag or combination of flags to add. For example: AddFlags(Hint2D) or AddFlags(Hint2D | Hint3D). HasAnyFlag(EdgeFlags) Check if edge info has a certain flag or combination of flags set. Declaration public bool HasAnyFlag(EdgeFlags flag) Parameters Type Name Description EdgeFlags flag Flag or combination of flags to check. For example: HasAnyFlag(Hint2D) or HasAnyFlag(Hint2D | Hint3D). Returns Type Description System.Boolean True if edge have the flag included."
  },
  "api/Elements.Spatial.AdaptiveGrid.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.html",
    "title": "Namespace Elements.Spatial.AdaptiveGrid | Hypar Docs",
    "keywords": "Namespace Elements.Spatial.AdaptiveGrid Classes AdaptiveGraphRouting Class for routing through an AdaptiveGrid. AdaptiveGrid A graph like edge-vertex structure with planar spaces connected by vertical edges. The grid doesn't do any intersections when new sections are added, they are stitched only by common vertices. Make sure that regions that are added into the graph are aligned with respect to boundaries and split points. ConnectVertexStrategy Connect strategy creates edges between new vertex created from base position and any number of given vertices. ConnectVertexWithAngleStrategy ConnectWithAngle strategy that connects two points in a way so incoming edge of other vertex has certain angle with given direction. Creates one middle vertex to achieve this but it can be skipped if two points are already aligned. Edge A unique edge in a adaptive grid, connecting two vertices. Don't have a particular direction. Class is forked from CellComplex.Edge. Obstacle AdaptiveGrid obstacle represented by a set of points with extra parameters. Points are used to created bounding box that is aligned with transformation parameter with extra offset. Since offset is applied on the box, distance on corners is even larger. Can be constructed from different objects. RoutingHintLine Structure that holds information about polylines that are used to guide routing. TreeNode Node that represents a vertex in a routed tree. Vertex A unique vertex in a adaptive grid. Class is forked from CellComplex.Vertex. WeightModifier Object that lets you apply an edge weight factor to edges that meet a Condition filter function. If an edge meets the condition of several WeightModifier objects they will be grouped by group name and factor aggregator function will be applied to WeightModifiers SetWeightModifiersGroupAggregator(String, Func<Double, Double, Double>) . By default - the lowest factor of group is chosen. Factors of all groups will be multiplied. Structs EdgeInfo Precalculated information about the edge. RoutingConfiguration Object that holds common parameters that affect routing. RoutingVertex Structure that holds additional information about inlet vertex Interfaces IAddVertexStrategy Interface for adding new vertices based on chosen strategy. Enums AdaptiveGrid.VerticesInsertionMethod Execution style for AddVertices function. Each option performs more operations than the previous one. BranchSide Enumeration that indicates one of two possible paths in routing. There are cases when we need to collect more than one path and only after some time we can decide which one is better. EdgeFlags Bit set of flags storing information about edge. Each flag is set to it's own number - power of 2, so they can be safely combined. Use | or |= to combine flags: flag = Hint2D | HasVerticalChange = 1 + 4 = 001 + 100 = 101 = 5. Use & or &= to check of one or more flags: flags & Hint3D == 101 & 010 == 0 == None, but flags & Hint2D == 101 & 001 == 001 == Hint2D. TreeOrder Order at which leaf terminal are connected into the tree. Delegates AdaptiveGraphRouting.RoutingFilter Filter function definition."
  },
  "api/Elements.Spatial.AdaptiveGrid.IAddVertexStrategy.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.IAddVertexStrategy.html",
    "title": "Interface IAddVertexStrategy | Hypar Docs",
    "keywords": "Interface IAddVertexStrategy Interface for adding new vertices based on chosen strategy. Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public interface IAddVertexStrategy Methods Add(AdaptiveGrid, Vector3, Boolean) Function called by grid were new vertices are added and connected. Declaration Vertex Add(AdaptiveGrid grid, Vector3 position, bool cut) Parameters Type Name Description AdaptiveGrid grid Grid to add vertices into Vector3 position Position of base vertex. System.Boolean cut Should new edges be automatically cut with the rest of the grid. Returns Type Description Vertex"
  },
  "api/Elements.Spatial.AdaptiveGrid.Obstacle.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.Obstacle.html",
    "title": "Class Obstacle | Hypar Docs",
    "keywords": "Class Obstacle AdaptiveGrid obstacle represented by a set of points with extra parameters. Points are used to created bounding box that is aligned with transformation parameter with extra offset. Since offset is applied on the box, distance on corners is even larger. Can be constructed from different objects. Inheritance System.Object Element GeometricElement Obstacle Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class Obstacle : GeometricElement, INotifyPropertyChanged Constructors Obstacle(Polygon, Double, Double, Boolean, Boolean, Transform) Create an obstacle from a list of points. Declaration public Obstacle(Polygon boundary, double height, double offset, bool addPerimeterEdges, bool allowOutsideBoundary, Transform orientation) Parameters Type Name Description Polygon boundary Boundary of an obstacle System.Double height Height of an obstacle System.Double offset Extra space around obstacle bounding box. System.Boolean addPerimeterEdges Should edges be created around obstacle. System.Boolean allowOutsideBoundary Should edges be created when obstacle is outside of Boundaries Transform orientation Orientation of the obstacle in space. Helpful for better bounding box creation. Properties AddPerimeterEdges Should edges be created around obstacle. If false - any intersected edges are just discarded. If true - intersected edges are cut to obstacle and perimeter edges are inserted. Declaration public bool AddPerimeterEdges { get; set; } Property Value Type Description System.Boolean AllowOutsideBoudary Should edges be created when obstacle is outside Boundaries , it will work only when AddPerimeterEdges property is true /> Declaration public bool AllowOutsideBoudary { get; set; } Property Value Type Description System.Boolean Boundary Perimeter defining obstacle. Declaration public Polygon Boundary { get; set; } Property Value Type Description Polygon Height Obstacle height, offset by Boundary normal vector Declaration public double Height { get; set; } Property Value Type Description System.Double Offset Offset of bounding box created from the list of points. Declaration public double Offset { get; set; } Property Value Type Description System.Double Orientation Additional information about obstacle orientation in space. Use inverted orientation to work in local space of the obstacle. Declaration public Transform Orientation { get; set; } Property Value Type Description Transform Points List of points defining obstacle. Declaration public List<Vector3> Points { get; } Property Value Type Description System.Collections.Generic.List < Vector3 > Methods FromBBox(BBox3, Double, Boolean, Boolean) Create an obstacle from a bounding box. Declaration public static Obstacle FromBBox(BBox3 box, double offset = 0, bool addPerimeterEdges = false, bool allowOutsideBoundary = false) Parameters Type Name Description BBox3 box Bounding box to avoid. System.Double offset Extra space around obstacle bounding box. System.Boolean addPerimeterEdges Should edges be created around obstacle. System.Boolean allowOutsideBoundary Should edges be created when obstacle is outside of Boundaries Returns Type Description Obstacle New obstacle object. FromColumn(Column, Double, Boolean, Boolean) Create an obstacle from a column. Declaration public static Obstacle FromColumn(Column column, double offset = 0, bool addPerimeterEdges = false, bool allowOutsideBoundary = false) Parameters Type Name Description Column column Column to avoid. System.Double offset Extra space around obstacle bounding box. System.Boolean addPerimeterEdges Should edges be created around obstacle. System.Boolean allowOutsideBoundary Should edges be created when obstacle is outside of Boundaries Returns Type Description Obstacle New obstacle object. FromLine(Line, Double, Boolean, Boolean) Create an obstacle from a line. Declaration public static Obstacle FromLine(Line line, double offset = 0.1, bool addPerimeterEdges = false, bool allowOutsideBoundary = false) Parameters Type Name Description Line line Line to avoid. System.Double offset Extra space around obstacle bounding box. Should be larger than 0. System.Boolean addPerimeterEdges Should edges be created around obstacle. System.Boolean allowOutsideBoundary Should edges be created when obstacle is outside of Boundaries Returns Type Description Obstacle New obstacle object. FromWall(StandardWall, Double, Boolean, Boolean) Create an obstacle from a wall. Declaration public static Obstacle FromWall(StandardWall wall, double offset = 0, bool addPerimeterEdges = false, bool allowOutsideBoundary = false) Parameters Type Name Description StandardWall wall Wall to avoid. System.Double offset Extra space around obstacle bounding box. System.Boolean addPerimeterEdges Should edges be created around obstacle. System.Boolean allowOutsideBoundary Should edges be created when obstacle is outside of Boundaries Returns Type Description Obstacle New obstacle object. Intersects(Line, Double) Check if line intersects with obstacle Declaration public bool Intersects(Line line, double tolerance = 1E-05) Parameters Type Name Description Line line Line to check System.Double tolerance Tolerance of checks Returns Type Description System.Boolean Result of check Intersects(Polyline, Double) Check if any segment of polyline intersects with obstacle or is inside of obstacle Declaration public bool Intersects(Polyline polyline, double tolerance = 1E-05) Parameters Type Name Description Polyline polyline Polyline to check System.Double tolerance Tolerance of checks Returns Type Description System.Boolean Result of check UpdateRepresentations() Create visual representation of obstacle Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Spatial.AdaptiveGrid.RoutingConfiguration.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.RoutingConfiguration.html",
    "title": "Struct RoutingConfiguration | Hypar Docs",
    "keywords": "Struct RoutingConfiguration Object that holds common parameters that affect routing. Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public struct RoutingConfiguration Constructors RoutingConfiguration(Double, List<Double>) Construct new RoutingConfiguration structure. Declaration public RoutingConfiguration(double turnCost = 0, List<double> supportedAngles = null) Parameters Type Name Description System.Double turnCost Travel cost penalty if route changes it's direction. System.Collections.Generic.List < System.Double > supportedAngles List of angles route can turn. Fields SupportedAngles List of angles route can turn. Angles are between 0 and 90. 0 is auto-included. For turn angle bigger than 90 degrees - 180 degrees minus angle is checked. For example, 135 is the same as 45. Declaration public readonly List<double> SupportedAngles Field Value Type Description System.Collections.Generic.List < System.Double > TurnCost Travel cost penalty if route changes it's direction. Declaration public readonly double TurnCost Field Value Type Description System.Double"
  },
  "api/Elements.Spatial.AdaptiveGrid.RoutingHintLine.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.RoutingHintLine.html",
    "title": "Class RoutingHintLine | Hypar Docs",
    "keywords": "Class RoutingHintLine Structure that holds information about polylines that are used to guide routing. Inheritance System.Object RoutingHintLine Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class RoutingHintLine Constructors RoutingHintLine(Polyline, Double, Double, Boolean, Boolean) Construct new RoutingHintLine structure. Declaration public RoutingHintLine(Polyline polyline, double factor, double influence, bool userDefined, bool is2D) Parameters Type Name Description Polyline polyline Geometry of HintLine. System.Double factor Cost multiplier. System.Double influence How far it affects. System.Boolean userDefined Is user defined. System.Boolean is2D Should polyline be virtually extended by Z coordinate. Fields Factor Cost multiplier for edges that lie within the Influence distance to the line. Declaration public readonly double Factor Field Value Type Description System.Double InfluenceDistance How far away from the line, edge travel cost is affected. Both sides of an edge and its middle point should be within influence range. Declaration public readonly double InfluenceDistance Field Value Type Description System.Double Is2D Should polyline be virtually extended by Z coordinate. Declaration public readonly bool Is2D Field Value Type Description System.Boolean Polyline 2D Polyline geometry representation with an influence that is extended on both sides in Z direction. Declaration public readonly Polyline Polyline Field Value Type Description Polyline UserDefined Is line created by the user or from internal parameters? User defined lines are preferred for input Vertex connection. Declaration public readonly bool UserDefined Field Value Type Description System.Boolean Methods Affects(Vector3, Vector3, Double) Check if hint line affects the line represented by two points. Both points must be withing influence radius of the polyline. Only edges parallel to polyline segments are affected. Declaration public bool Affects(Vector3 start, Vector3 end, double tolerance = 1E-05) Parameters Type Name Description Vector3 start Start of the line point. Vector3 end End of the line point. System.Double tolerance Minimum allowed distance to polyline, even if influence is 0. Returns Type Description System.Boolean Intersects(Vector3, Vector3) Check if hint line intersects the line represented by two points withing influence radius of the polyline. Declaration public bool Intersects(Vector3 start, Vector3 end) Parameters Type Name Description Vector3 start Start of the line point. Vector3 end End of the line point. Returns Type Description System.Boolean IsNearby(Vector3, Double) Check if point is within influence of the hint line. If hint line is 2D than only 2D distance is calculated, ignoring Z coordinate. Declaration public bool IsNearby(Vector3 point, double tolerance = 1E-05) Parameters Type Name Description Vector3 point Point to check. System.Double tolerance Minimum allowed distance to polyline, even if influence is 0. Returns Type Description System.Boolean True if point is close enough to the polyline."
  },
  "api/Elements.Spatial.AdaptiveGrid.RoutingVertex.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.RoutingVertex.html",
    "title": "Struct RoutingVertex | Hypar Docs",
    "keywords": "Struct RoutingVertex Structure that holds additional information about inlet vertex Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public struct RoutingVertex Constructors RoutingVertex(UInt64, Double) Construct new RoutingVertex structure. Declaration public RoutingVertex(ulong id, double isolationRadius) Parameters Type Name Description System.UInt64 id Id of the vertex in the grid. System.Double isolationRadius Distance, other sections of the route can't travel near this vertex. Fields Id Id of the vertex in the grid. Declaration public ulong Id Field Value Type Description System.UInt64 IsolationRadius Distance closer than which, other sections of the route can't travel near this vertex. Distance is in base plane of the gird, without elevation. Declaration public double IsolationRadius Field Value Type Description System.Double"
  },
  "api/Elements.Spatial.AdaptiveGrid.TreeNode.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.TreeNode.html",
    "title": "Class TreeNode | Hypar Docs",
    "keywords": "Class TreeNode Node that represents a vertex in a routed tree. Inheritance System.Object TreeNode Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class TreeNode Constructors TreeNode(UInt64) Create new node from vertex id without any connections. Declaration public TreeNode(ulong id) Parameters Type Name Description System.UInt64 id Id of vertex. Fields Id Id of corresponding vertex in the gird. Declaration public ulong Id Field Value Type Description System.UInt64 Leafs List of incoming nodes. Declaration public List<TreeNode> Leafs Field Value Type Description System.Collections.Generic.List < TreeNode > Trunk Outgoing node. Declaration public TreeNode Trunk Field Value Type Description TreeNode Methods Disconnect() Remove all incoming and outgoing connections from the grid. Removed nodes will also be disconnected from this node. Declaration public void Disconnect() RemoveLeaf(TreeNode) Remove leaf connection and set its trunk to null. Declaration public void RemoveLeaf(TreeNode leaf) Parameters Type Name Description TreeNode leaf SetTrunk(TreeNode) Set trunk node and add this node as leaf to it. Declaration public void SetTrunk(TreeNode trunk) Parameters Type Name Description TreeNode trunk"
  },
  "api/Elements.Spatial.AdaptiveGrid.TreeOrder.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.TreeOrder.html",
    "title": "Enum TreeOrder | Hypar Docs",
    "keywords": "Enum TreeOrder Order at which leaf terminal are connected into the tree. Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public enum TreeOrder Fields Name Description ClosestToFurthest Closest from remaining terminals is routed first. FurthestToClosest Furthest from remaining terminals is routed first."
  },
  "api/Elements.Spatial.AdaptiveGrid.Vertex.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.Vertex.html",
    "title": "Class Vertex | Hypar Docs",
    "keywords": "Class Vertex A unique vertex in a adaptive grid. Class is forked from CellComplex.Vertex. Inheritance System.Object Vertex Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class Vertex Fields Edges All Edges connected to this Vertex. Declaration [JsonIgnore] public HashSet<Edge> Edges Field Value Type Description System.Collections.Generic.HashSet < Edge > Properties Id ID of this Vertex. Declaration public ulong Id { get; } Property Value Type Description System.UInt64 Point Position of this Vertex in 3D space Declaration public Vector3 Point { get; set; } Property Value Type Description Vector3 Methods Equals(Object) Used to handle comparisons for when we make HashSets of this type. Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) GetEdge(UInt64) Find edge between this Vertex and Vertex with given ID. Declaration public Edge GetEdge(ulong otherId) Parameters Type Name Description System.UInt64 otherId Id of other vertex. Returns Type Description Edge Edge between this and Vertex with given ID. Null if not found. GetHashCode() Used to return a unique identifier for when we make HashSets of this type. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode()"
  },
  "api/Elements.Spatial.AdaptiveGrid.WeightModifier.html": {
    "href": "api/Elements.Spatial.AdaptiveGrid.WeightModifier.html",
    "title": "Class WeightModifier | Hypar Docs",
    "keywords": "Class WeightModifier Object that lets you apply an edge weight factor to edges that meet a Condition filter function. If an edge meets the condition of several WeightModifier objects they will be grouped by group name and factor aggregator function will be applied to WeightModifiers SetWeightModifiersGroupAggregator(String, Func<Double, Double, Double>) . By default - the lowest factor of group is chosen. Factors of all groups will be multiplied. Inheritance System.Object WeightModifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.AdaptiveGrid Assembly : Hypar.Elements.dll Syntax public class WeightModifier Constructors WeightModifier(String, Func<Vertex, Vertex, Boolean>, Double, String) Basic constructor for a WeightModifier Declaration public WeightModifier(string name, Func<Vertex, Vertex, bool> condition, double factor, string group = null) Parameters Type Name Description System.String name Name of the modifier. System.Func < Vertex , Vertex , System.Boolean > condition Filter function. System.Double factor Weight to be applied. System.String group Group name of the modifier. Fields Condition Filter function that determines if this WeightModifier applies to an edge. Declaration public Func<Vertex, Vertex, bool> Condition Field Value Type Description System.Func < Vertex , Vertex , System.Boolean > Factor Weight to be applied according to this WeightModifier. Declaration public double Factor Field Value Type Description System.Double Group Group name of the modifier. Declaration public readonly string Group Field Value Type Description System.String Name WeightModifier name. Declaration public readonly string Name Field Value Type Description System.String"
  },
  "api/Elements.Spatial.CellComplex.Cell.html": {
    "href": "api/Elements.Spatial.CellComplex.Cell.html",
    "title": "Class Cell | Hypar Docs",
    "keywords": "Class Cell A cell is a 3-dimensional closed extrusion within a complex. Inheritance System.Object ChildBase < Cell , Extrude > Cell Implements IDistanceTo IHasNeighbors < Cell , Extrude > Inherited Members ChildBase<Cell, Extrude>.Id ChildBase<Cell, Extrude>.CellComplex ChildBase<Cell, Extrude>.GetHashCode() ChildBase<Cell, Extrude>.DistanceTo(Vector3) ChildBase<Cell, Extrude>.Equals(Object) ChildBase<Cell, Extrude>.GetGeometry() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public class Cell : ChildBase<Cell, Extrude>, IDistanceTo, IHasNeighbors<Cell, Extrude> Fields BottomFaceId The ID of this cell's bottom face. If set, it is also expected to be duplicated in list of faces. In the current implementation of CellComplex, this should always be set. This may not be the case in the future, if Cells are no longer constrained to vertical extrusions. Declaration public ulong? BottomFaceId Field Value Type Description System.Nullable < System.UInt64 > FaceIds The IDs of all the faces which belong to this Cell. Declaration public List<ulong> FaceIds Field Value Type Description System.Collections.Generic.List < System.UInt64 > TopFaceId The ID of this cell's top face. If set, it is also expected to be duplicated in list of faces. In the current implementation of CellComplex, this should always be set. This may not be the case in the future, if Cells are no longer constrained to vertical extrusions. Declaration public ulong? TopFaceId Field Value Type Description System.Nullable < System.UInt64 > Methods DistanceTo(Vector3) Get the shortest distance from a point to the geometry representing this cell. Declaration public override double DistanceTo(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double Overrides Elements.Spatial.CellComplex.ChildBase<Elements.Spatial.CellComplex.Cell, Elements.Geometry.Solids.Extrude>.DistanceTo(Elements.Geometry.Vector3) GetBottomFace() Get bottom face, if defined. Declaration public Face GetBottomFace() Returns Type Description Face GetClosestEdge(Vector3) Get the associated Edge that is closest to a point. Declaration public Edge GetClosestEdge(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Edge GetClosestFace(Vector3) Get the closest associated face to the supplied position. Declaration public Face GetClosestFace(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Face GetClosestNeighbor(Vector3) Get the closest associated cell to the supplied point. Declaration public Cell GetClosestNeighbor(Vector3 target) Parameters Type Name Description Vector3 target Returns Type Description Cell GetClosestVertex(Vector3) Get the associated vertex that is closest to a point Declaration public Vertex GetClosestVertex(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Vertex GetEdges() Get associated Edges. Declaration public List<Edge> GetEdges() Returns Type Description System.Collections.Generic.List < Edge > GetFaces() Get associated Faces. Declaration public List<Face> GetFaces() Returns Type Description System.Collections.Generic.List < Face > GetGeometry() Get a Solid Extrusion representing this Cell. Declaration public override Extrude GetGeometry() Returns Type Description Extrude Overrides Elements.Spatial.CellComplex.ChildBase<Elements.Spatial.CellComplex.Cell, Elements.Geometry.Solids.Extrude>.GetGeometry() GetNeighbors() Get list of Cells that are neighbors. Declaration public List<Cell> GetNeighbors() Returns Type Description System.Collections.Generic.List < Cell > GetNeighbors(Face) Get the neighbor that shares a specific Face with this cell. Can be null if the face is not shared. Declaration public Cell GetNeighbors(Face face) Parameters Type Name Description Face face Shared face Returns Type Description Cell GetTopFace() Get top face, if defined. Declaration public Face GetTopFace() Returns Type Description Face GetVertices(Nullable<Vector3>) Get associated Vertices. Declaration public List<Vertex> GetVertices(Vector3? point = null) Parameters Type Name Description System.Nullable < Vector3 > point Returns Type Description System.Collections.Generic.List < Vertex > TraverseNeighbors(Vector3, Double) Traverse the neighbors of this Cell toward the target point. Declaration public List<Cell> TraverseNeighbors(Vector3 target, double completedRadius = 0) Parameters Type Name Description Vector3 target System.Double completedRadius If provided, ends the traversal when the neighbor is within this distance to the target point. Returns Type Description System.Collections.Generic.List < Cell > A collection of traversed Cells, including the starting Cell. Implements IDistanceTo IHasNeighbors<ChildClass, GeometryType>"
  },
  "api/Elements.Spatial.CellComplex.CellComplex.html": {
    "href": "api/Elements.Spatial.CellComplex.CellComplex.html",
    "title": "Class CellComplex | Hypar Docs",
    "keywords": "Class CellComplex A non-manifold cellular structure. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Spatial_CellComplex_CellComplex.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Assemble CellComplex from Grid2d var numLevels = 10; var levelHeight = 1; var cellSize = 2; var complex = new CellComplex(); var boundary = new Circle(new Vector3(), 10).ToPolygon(); var grid = new Grid2d(boundary, Vector3.Origin, Vector3.XAxis, Vector3.YAxis); var pathMaterial = new Material(\"Path\", new Color(1, 0, 0, 0.75)); grid.U.DivideByFixedLength(cellSize); grid.V.DivideByFixedLength(cellSize); for (var i = 0; i < numLevels; i++) { foreach (var cell in grid.GetCells()) { foreach (var crv in cell.GetTrimmedCellGeometry()) { complex.AddCell((Polygon)crv, levelHeight, i * levelHeight, grid.U, grid.V); } } } // Draw base CellComplex foreach (var face in complex.GetFaces()) { this.Model.AddElement(new Panel(face.GetGeometry(), BuiltInMaterials.Mass)); } // Traverse CellComplex var start = new Vector3(15, 15, 15); var end = new Vector3(-15, -15, -15); // Draw lines from start and end to closest points, for reference foreach (var pt in new List<Vector3>() { start, end }) { var closest = complex.GetClosestVertex(pt).GetGeometry(); this.Model.AddElement(new ModelCurve(new Line(pt, closest), pathMaterial)); } var curCell = complex.GetClosestCell(start); var traversedCells = curCell.TraverseNeighbors(end); foreach (var cell in traversedCells) { var rep = new Representation(new[] { cell.GetGeometry() }); this.Model.AddElement(new GeometricElement(new Transform(), pathMaterial, rep, false, Guid.NewGuid(), \"Path\")); } Inheritance System.Object Element CellComplex Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public class CellComplex : Element, INotifyPropertyChanged Constructors CellComplex(Guid, String) Create a CellComplex. Declaration public CellComplex(Guid id = default(Guid), string name = null) Parameters Type Name Description System.Guid id Optional ID: If blank, a new Guid will be created. System.String name Optional name of your CellComplex. Fields Tolerance Tolerance for points being considered the same. Applies individually to X, Y, and Z coordinates, not the cumulative difference! Declaration public double Tolerance Field Value Type Description System.Double Methods AddCell(Polygon, Double, Double, Grid1d, Grid1d) Add a cell to the CellComplex. Declaration public Cell AddCell(Polygon polygon, double height, double elevation, Grid1d uGrid = null, Grid1d vGrid = null) Parameters Type Name Description Polygon polygon The polygon that forms the base of this cell. System.Double height The height of the cell. System.Double elevation The elevation of the bottom of this cell. Grid1d uGrid An optional but highly recommended U grid that allows the cell's top and bottom faces to store intended directionality. Grid1d vGrid An optional but highly recommended V grid that allows the cell's top and bottom faces to store intended directionality. Returns Type Description Cell The created Cell. GetCell(UInt64) Get a Cell by its ID. Declaration public Cell GetCell(ulong cellId) Parameters Type Name Description System.UInt64 cellId Returns Type Description Cell GetCells() Get all Cells. Declaration public List<Cell> GetCells() Returns Type Description System.Collections.Generic.List < Cell > GetClosestCell(Vector3) Get the associated Cell that is closest to a point. Declaration public Cell GetClosestCell(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Cell GetClosestEdge(Vector3) Get the associated Edge that is closest to a point. Declaration public Edge GetClosestEdge(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Edge GetClosestFace(Vector3) Get the associated Face that is closest to a point. Declaration public Face GetClosestFace(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Face GetClosestVertex(Vector3) Get the associated Vertex that is closest to a point. Declaration public Vertex GetClosestVertex(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Vertex GetEdge(UInt64) Get a Edge by its ID. Declaration public Edge GetEdge(ulong edgeId) Parameters Type Name Description System.UInt64 edgeId Returns Type Description Edge GetEdges() Get all Edges. Declaration public List<Edge> GetEdges() Returns Type Description System.Collections.Generic.List < Edge > GetFace(Nullable<UInt64>) Get a Face by its ID. Declaration public Face GetFace(ulong? faceId) Parameters Type Name Description System.Nullable < System.UInt64 > faceId Returns Type Description Face GetFaces() Get all Faces. Declaration public List<Face> GetFaces() Returns Type Description System.Collections.Generic.List < Face > GetOrientation(Nullable<UInt64>) Get a U or V direction by its ID. Declaration public Orientation GetOrientation(ulong? orientationId) Parameters Type Name Description System.Nullable < System.UInt64 > orientationId Returns Type Description Orientation GetVertex(UInt64) Get a Vertex by its ID. Declaration public Vertex GetVertex(ulong vertexId) Parameters Type Name Description System.UInt64 vertexId Returns Type Description Vertex GetVertices() Get all Vertices. Declaration public List<Vertex> GetVertices() Returns Type Description System.Collections.Generic.List < Vertex > GetVerticesMatchingXY(Double, Double, Nullable<Double>) Get all vertices matching an X/Y coordinate, regardless of Z. Declaration public List<Vertex> GetVerticesMatchingXY(double x, double y, double? fuzzyFactor = null) Parameters Type Name Description System.Double x X coordinate. System.Double y Y coordinate. System.Nullable < System.Double > fuzzyFactor Amount of tolerance in the search against each component of the coordinate. Returns Type Description System.Collections.Generic.List < Vertex > VertexExists(Vector3, out UInt64, Nullable<Double>) Whether a vertex location already exists in the CellComplex. Declaration public bool VertexExists(Vector3 point, out ulong id, double? fuzzyFactor = null) Parameters Type Name Description Vector3 point System.UInt64 id The ID of the Vertex, if a match is found. System.Nullable < System.Double > fuzzyFactor Amount of tolerance in the search against each component of the coordinate. Returns Type Description System.Boolean Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Spatial.CellComplex.ChildBase-2.html": {
    "href": "api/Elements.Spatial.CellComplex.ChildBase-2.html",
    "title": "Class ChildBase<ChildClass, GeometryType> | Hypar Docs",
    "keywords": "Class ChildBase<ChildClass, GeometryType> An abstract base for the children of CellComplex. Inheritance System.Object ChildBase<ChildClass, GeometryType> Cell EdgeBase<ChildClass> Face VertexBase<ChildClass> Implements IDistanceTo Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public abstract class ChildBase<ChildClass, GeometryType> : IDistanceTo where ChildClass : ChildBase<ChildClass, GeometryType> Type Parameters Name Description ChildClass GeometryType Properties CellComplex The CellComplex that this child belongs to. Declaration [JsonIgnore] public CellComplex CellComplex { get; } Property Value Type Description CellComplex Id ID of this child. Declaration public ulong Id { get; } Property Value Type Description System.UInt64 Methods DistanceTo(Vector3) Get the shortest distance from a point to the geometry representing this child. Declaration public abstract double DistanceTo(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double Equals(Object) Used to handle comparisons for when we make HashSets of children of this type. Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) GetGeometry() Get the associated geometry for this child. Declaration public abstract GeometryType GetGeometry() Returns Type Description GeometryType GetHashCode() Used to return a unique identifier for when we make HashSets of children of this type. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Implements IDistanceTo"
  },
  "api/Elements.Spatial.CellComplex.Edge.html": {
    "href": "api/Elements.Spatial.CellComplex.Edge.html",
    "title": "Class Edge | Hypar Docs",
    "keywords": "Class Edge A unique edge in a cell complex, regardless of directionality when it comes to face traversal. Directional edges for this purpose are in associated DirectedEdges. There is a maximum of two DirectedEdges per Edge. Inheritance System.Object ChildBase < Edge , Line > EdgeBase < Edge > Edge Implements IDistanceTo IHasNeighbors < Edge , Line > Inherited Members EdgeBase<Edge>.StartVertexId EdgeBase<Edge>.EndVertexId EdgeBase<Edge>.GetGeometry() EdgeBase<Edge>.DistanceTo(Vector3) ChildBase<Edge, Line>.Id ChildBase<Edge, Line>.CellComplex ChildBase<Edge, Line>.GetHashCode() ChildBase<Edge, Line>.DistanceTo(Vector3) ChildBase<Edge, Line>.Equals(Object) ChildBase<Edge, Line>.GetGeometry() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public class Edge : EdgeBase<Edge>, IDistanceTo, IHasNeighbors<Edge, Line> Methods GetCells() Get associated Cells Declaration public List<Cell> GetCells() Returns Type Description System.Collections.Generic.List < Cell > GetClosestCell(Vector3) Get the associated Cell that is closest to a point. Declaration public Cell GetClosestCell(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Cell GetClosestFace(Vector3) Get the associated Face that is closest to a point. Declaration public Face GetClosestFace(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Face GetClosestNeighbor(Vector3) Get the closest neighboring Edge to a point. Declaration public Edge GetClosestNeighbor(Vector3 target) Parameters Type Name Description Vector3 target Returns Type Description Edge GetClosestVertex(Vector3) Get the associated Vertex that is closest to a point. Declaration public Vertex GetClosestVertex(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Vertex GetFaces() Get associated Faces. Declaration public List<Face> GetFaces() Returns Type Description System.Collections.Generic.List < Face > GetNeighbors() Get a list of all neighboring Edges that share a Vertex. Declaration public List<Edge> GetNeighbors() Returns Type Description System.Collections.Generic.List < Edge > GetVertices() Get associated Vertices. Declaration public List<Vertex> GetVertices() Returns Type Description System.Collections.Generic.List < Vertex > TraverseNeighbors(Vector3, Double) Traverse the neighbors of this Edge toward the target point. Declaration public List<Edge> TraverseNeighbors(Vector3 target, double completedRadius = 0) Parameters Type Name Description Vector3 target System.Double completedRadius If provided, ends the traversal when the neighbor is within this distance to the target point. Returns Type Description System.Collections.Generic.List < Edge > A collection of traversed Edges, including the starting Edge. Implements IDistanceTo IHasNeighbors<ChildClass, GeometryType>"
  },
  "api/Elements.Spatial.CellComplex.EdgeBase-1.html": {
    "href": "api/Elements.Spatial.CellComplex.EdgeBase-1.html",
    "title": "Class EdgeBase<ChildClass> | Hypar Docs",
    "keywords": "Class EdgeBase<ChildClass> A unique edge or directed edge in a cell complex. Inheritance System.Object ChildBase <ChildClass, Line > EdgeBase<ChildClass> Edge Implements IDistanceTo Inherited Members ChildBase<ChildClass, Line>.Id ChildBase<ChildClass, Line>.CellComplex ChildBase<ChildClass, Line>.GetHashCode() ChildBase<ChildClass, Line>.DistanceTo(Vector3) ChildBase<ChildClass, Line>.Equals(Object) ChildBase<ChildClass, Line>.GetGeometry() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public abstract class EdgeBase<ChildClass> : ChildBase<ChildClass, Line>, IDistanceTo where ChildClass : ChildBase<ChildClass, Line> Type Parameters Name Description ChildClass Constructors EdgeBase(UInt64, CellComplex) Create an EdgeBase (just calls CellChild constructor). Declaration protected EdgeBase(ulong id, CellComplex cellComplex) Parameters Type Name Description System.UInt64 id CellComplex cellComplex Fields EndVertexId ID of end Vertex. Declaration public ulong EndVertexId Field Value Type Description System.UInt64 StartVertexId ID of start Vertex. Declaration public ulong StartVertexId Field Value Type Description System.UInt64 Methods DistanceTo(Vector3) Get the shortest distance from a point to the geometry representing this edge. Declaration public override double DistanceTo(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double Overrides Elements.Spatial.CellComplex.ChildBase<ChildClass, Elements.Geometry.Line>.DistanceTo(Elements.Geometry.Vector3) GetGeometry() Get the geometry that represents this Edge or DirectedEdge. Declaration public override Line GetGeometry() Returns Type Description Line Overrides Elements.Spatial.CellComplex.ChildBase<ChildClass, Elements.Geometry.Line>.GetGeometry() Implements IDistanceTo"
  },
  "api/Elements.Spatial.CellComplex.Face.html": {
    "href": "api/Elements.Spatial.CellComplex.Face.html",
    "title": "Class Face | Hypar Docs",
    "keywords": "Class Face A Face within a cell. Multiple cells can share the same Face. Inheritance System.Object ChildBase < Face , Polygon > Face Implements IDistanceTo IHasNeighbors < Face , Polygon > Inherited Members ChildBase<Face, Polygon>.Id ChildBase<Face, Polygon>.CellComplex ChildBase<Face, Polygon>.GetHashCode() ChildBase<Face, Polygon>.DistanceTo(Vector3) ChildBase<Face, Polygon>.Equals(Object) ChildBase<Face, Polygon>.GetGeometry() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public class Face : ChildBase<Face, Polygon>, IDistanceTo, IHasNeighbors<Face, Polygon> Fields DirectedEdgeIds Directed edge IDs. Declaration public List<ulong> DirectedEdgeIds Field Value Type Description System.Collections.Generic.List < System.UInt64 > Methods DistanceTo(Vector3) Get the shortest distance from a point to the geometry representing this face. Declaration public override double DistanceTo(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double Overrides Elements.Spatial.CellComplex.ChildBase<Elements.Spatial.CellComplex.Face, Elements.Geometry.Polygon>.DistanceTo(Elements.Geometry.Vector3) GetCells() Get associated Cells. Declaration public List<Cell> GetCells() Returns Type Description System.Collections.Generic.List < Cell > GetClosestCell(Vector3) Get the associated Cell that is closest to a point. Declaration public Cell GetClosestCell(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Cell GetClosestEdge(Vector3) Get the associated Edge that is closest to a point. Declaration public Edge GetClosestEdge(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Edge GetClosestNeighbor(Vector3) Get the closest associated Face to a given point. Declaration public Face GetClosestNeighbor(Vector3 target) Parameters Type Name Description Vector3 target Returns Type Description Face GetClosestNeighbor(Vector3, Boolean, Boolean) Get the closest associated Face to a given point. Declaration public Face GetClosestNeighbor(Vector3 target, bool parallel = false, bool includeSharedVertices = false) Parameters Type Name Description Vector3 target System.Boolean parallel If true, only checks faces that are oriented the same way as this Face. System.Boolean includeSharedVertices If true, checks Faces that share a Vertex as well as Faces that share a Edge. Returns Type Description Face GetClosestVertex(Vector3) Get the associated Vertex that is closest to a point. Declaration public Vertex GetClosestVertex(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Vertex GetEdges() Get associated Edges. Declaration public List<Edge> GetEdges() Returns Type Description System.Collections.Generic.List < Edge > GetGeometry() Get the geometry for this Face. Declaration public override Polygon GetGeometry() Returns Type Description Polygon Overrides Elements.Spatial.CellComplex.ChildBase<Elements.Spatial.CellComplex.Face, Elements.Geometry.Polygon>.GetGeometry() GetNeighbors() Get a list of all neighbors of this Face. A neighbor is defined as a Face which shares any Edge. Declaration public List<Face> GetNeighbors() Returns Type Description System.Collections.Generic.List < Face > GetNeighbors(Edge, Boolean) Get a list of neighboring Faces that share a specific Edge. Declaration public List<Face> GetNeighbors(Edge edge, bool parallel = false) Parameters Type Name Description Edge edge Edge that the neighbor should share. System.Boolean parallel Whether to only return Faces that are parallel to this Face. Returns Type Description System.Collections.Generic.List < Face > GetNeighbors(Boolean, Boolean) Get a list of all neighbors of this Face. A neighbor is defined as a Face which shares any Edge. Declaration public List<Face> GetNeighbors(bool parallel = false, bool includeSharedVertices = false) Parameters Type Name Description System.Boolean parallel If true, only returns Faces that are oriented the same way as this Face. System.Boolean includeSharedVertices If true, includes Faces that share a Vertex as well as Faces that share an Edge. Returns Type Description System.Collections.Generic.List < Face > GetOrientation() Get the user-set U and V Orientatinos of this face. Declaration public (Orientation U, Orientation V) GetOrientation() Returns Type Description System.ValueTuple < Orientation , Orientation > GetVertices() Get associated Vertices. Declaration public List<Vertex> GetVertices() Returns Type Description System.Collections.Generic.List < Vertex > TraverseNeighbors(Vector3, Boolean, Boolean, Double) Traverse the neighbors of this Face toward the target point. Declaration public List<Face> TraverseNeighbors(Vector3 target, bool parallel = false, bool includeSharedVertices = false, double completedRadius = 0) Parameters Type Name Description Vector3 target System.Boolean parallel If true, only checks faces that are oriented the same way as this Face. System.Boolean includeSharedVertices If true, checks Faces that share a Vertex as well as Faces that share a Edge. System.Double completedRadius If provided, ends the traversal when the neighbor is within this distance to the target point. Returns Type Description System.Collections.Generic.List < Face > A collection of traversed Faces, including the starting Face. TraverseNeighbors(Vector3, Double) Traverse the neighbors of this Face toward the target point. Declaration public List<Face> TraverseNeighbors(Vector3 target, double completedRadius = 0) Parameters Type Name Description Vector3 target System.Double completedRadius Returns Type Description System.Collections.Generic.List < Face > Implements IDistanceTo IHasNeighbors<ChildClass, GeometryType>"
  },
  "api/Elements.Spatial.CellComplex.html": {
    "href": "api/Elements.Spatial.CellComplex.html",
    "title": "Namespace Elements.Spatial.CellComplex | Hypar Docs",
    "keywords": "Namespace Elements.Spatial.CellComplex Classes Cell A cell is a 3-dimensional closed extrusion within a complex. CellComplex A non-manifold cellular structure. ChildBase<ChildClass, GeometryType> An abstract base for the children of CellComplex. Edge A unique edge in a cell complex, regardless of directionality when it comes to face traversal. Directional edges for this purpose are in associated DirectedEdges. There is a maximum of two DirectedEdges per Edge. EdgeBase<ChildClass> A unique edge or directed edge in a cell complex. Face A Face within a cell. Multiple cells can share the same Face. Orientation A unique orientation direction in a CellComplex. Vertex A unique Vertex in a CellComplex. VertexBase<ChildClass> A unique Vertex or Orientation in a cell complex."
  },
  "api/Elements.Spatial.CellComplex.Interfaces.html": {
    "href": "api/Elements.Spatial.CellComplex.Interfaces.html",
    "title": "Namespace Elements.Spatial.CellComplex.Interfaces | Hypar Docs",
    "keywords": "Namespace Elements.Spatial.CellComplex.Interfaces Interfaces IDistanceTo This interface is used when we expect a class to have a DistanceTo method. IHasNeighbors<ChildClass, GeometryType> An interface for children of cell complex that have easily defined neighbors of the same class."
  },
  "api/Elements.Spatial.CellComplex.Interfaces.IDistanceTo.html": {
    "href": "api/Elements.Spatial.CellComplex.Interfaces.IDistanceTo.html",
    "title": "Interface IDistanceTo | Hypar Docs",
    "keywords": "Interface IDistanceTo This interface is used when we expect a class to have a DistanceTo method. Namespace : Elements.Spatial.CellComplex.Interfaces Assembly : Hypar.Elements.dll Syntax public interface IDistanceTo Methods DistanceTo(Vector3) Provides the closest distance from an element to the provided point. Declaration double DistanceTo(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double"
  },
  "api/Elements.Spatial.CellComplex.Interfaces.IHasNeighbors-2.html": {
    "href": "api/Elements.Spatial.CellComplex.Interfaces.IHasNeighbors-2.html",
    "title": "Interface IHasNeighbors<ChildClass, GeometryType> | Hypar Docs",
    "keywords": "Interface IHasNeighbors<ChildClass, GeometryType> An interface for children of cell complex that have easily defined neighbors of the same class. Namespace : Elements.Spatial.CellComplex.Interfaces Assembly : Hypar.Elements.dll Syntax public interface IHasNeighbors<ChildClass, GeometryType> Type Parameters Name Description ChildClass GeometryType Methods GetClosestNeighbor(Vector3) Get the closest associated neighbor of this element to the target point. Declaration ChildClass GetClosestNeighbor(Vector3 target) Parameters Type Name Description Vector3 target Returns Type Description ChildClass GetNeighbors() Get all associated neighbors of this element. Declaration List<ChildClass> GetNeighbors() Returns Type Description System.Collections.Generic.List <ChildClass> TraverseNeighbors(Vector3, Double) Traverse the neighbors of this element toward the target point. Declaration List<ChildClass> TraverseNeighbors(Vector3 target, double completedRadius = 0) Parameters Type Name Description Vector3 target System.Double completedRadius Returns Type Description System.Collections.Generic.List <ChildClass>"
  },
  "api/Elements.Spatial.CellComplex.Orientation.html": {
    "href": "api/Elements.Spatial.CellComplex.Orientation.html",
    "title": "Class Orientation | Hypar Docs",
    "keywords": "Class Orientation A unique orientation direction in a CellComplex. Inheritance System.Object ChildBase < Orientation , Vector3 > VertexBase < Orientation > Orientation Implements IDistanceTo Inherited Members VertexBase<Orientation>.Value VertexBase<Orientation>.Name VertexBase<Orientation>.GetGeometry() ChildBase<Orientation, Vector3>.Id ChildBase<Orientation, Vector3>.CellComplex ChildBase<Orientation, Vector3>.GetHashCode() ChildBase<Orientation, Vector3>.DistanceTo(Vector3) ChildBase<Orientation, Vector3>.Equals(Object) ChildBase<Orientation, Vector3>.GetGeometry() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public class Orientation : VertexBase<Orientation>, IDistanceTo Methods DistanceTo(Vector3) Do not use this method: it just throws an exception. Orientations are relative directions and do not exist at any point in absolute space. A distance cannot be calculated for orientations. Declaration public override double DistanceTo(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double Overrides Elements.Spatial.CellComplex.VertexBase<Elements.Spatial.CellComplex.Orientation>.DistanceTo(Elements.Geometry.Vector3) Implements IDistanceTo"
  },
  "api/Elements.Spatial.CellComplex.Vertex.html": {
    "href": "api/Elements.Spatial.CellComplex.Vertex.html",
    "title": "Class Vertex | Hypar Docs",
    "keywords": "Class Vertex A unique Vertex in a CellComplex. Inheritance System.Object ChildBase < Vertex , Vector3 > VertexBase < Vertex > Vertex Implements IDistanceTo Inherited Members VertexBase<Vertex>.Value VertexBase<Vertex>.Name VertexBase<Vertex>.GetGeometry() VertexBase<Vertex>.DistanceTo(Vector3) ChildBase<Vertex, Vector3>.Id ChildBase<Vertex, Vector3>.CellComplex ChildBase<Vertex, Vector3>.GetHashCode() ChildBase<Vertex, Vector3>.DistanceTo(Vector3) ChildBase<Vertex, Vector3>.Equals(Object) ChildBase<Vertex, Vector3>.GetGeometry() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public class Vertex : VertexBase<Vertex>, IDistanceTo Methods GetCells() Get associated Cells. Declaration public List<Cell> GetCells() Returns Type Description System.Collections.Generic.List < Cell > GetClosestCell(Vector3) Get the associated Cell that is closest to a point. Declaration public Cell GetClosestCell(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Cell GetClosestEdge(Vector3) Get the associated Edge that is closest to a point. Declaration public Edge GetClosestEdge(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Edge GetClosestFace(Vector3) Get the associated Face that is closest to a point. Declaration public Face GetClosestFace(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description Face GetEdges() Get associated Edges. Declaration public List<Edge> GetEdges() Returns Type Description System.Collections.Generic.List < Edge > GetFaces() Get associated Faces. Declaration public List<Face> GetFaces() Returns Type Description System.Collections.Generic.List < Face > Implements IDistanceTo"
  },
  "api/Elements.Spatial.CellComplex.VertexBase-1.html": {
    "href": "api/Elements.Spatial.CellComplex.VertexBase-1.html",
    "title": "Class VertexBase<ChildClass> | Hypar Docs",
    "keywords": "Class VertexBase<ChildClass> A unique Vertex or Orientation in a cell complex. Inheritance System.Object ChildBase <ChildClass, Vector3 > VertexBase<ChildClass> Orientation Vertex Implements IDistanceTo Inherited Members ChildBase<ChildClass, Vector3>.Id ChildBase<ChildClass, Vector3>.CellComplex ChildBase<ChildClass, Vector3>.GetHashCode() ChildBase<ChildClass, Vector3>.DistanceTo(Vector3) ChildBase<ChildClass, Vector3>.Equals(Object) ChildBase<ChildClass, Vector3>.GetGeometry() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial.CellComplex Assembly : Hypar.Elements.dll Syntax public abstract class VertexBase<ChildClass> : ChildBase<ChildClass, Vector3>, IDistanceTo where ChildClass : ChildBase<ChildClass, Vector3> Type Parameters Name Description ChildClass Fields Value Location in space if this is a Vertex, or a vector direction if this is an Orientation. Declaration public Vector3 Value Field Value Type Description Vector3 Properties Name An optional user-supplied name. Declaration public string Name { get; set; } Property Value Type Description System.String Methods DistanceTo(Vector3) Get the shortest distance from a point to the geometry representing this vertex. Declaration public override double DistanceTo(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double Overrides Elements.Spatial.CellComplex.ChildBase<ChildClass, Elements.Geometry.Vector3>.DistanceTo(Elements.Geometry.Vector3) GetGeometry() Get the Vector3 that represents this Vertex or Orientation. Declaration public override Vector3 GetGeometry() Returns Type Description Vector3 Overrides Elements.Spatial.CellComplex.ChildBase<ChildClass, Elements.Geometry.Vector3>.GetGeometry() Implements IDistanceTo"
  },
  "api/Elements.Spatial.EvenDivisionMode.html": {
    "href": "api/Elements.Spatial.EvenDivisionMode.html",
    "title": "Enum EvenDivisionMode | Hypar Docs",
    "keywords": "Enum EvenDivisionMode Describe how a target length should be treated Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum EvenDivisionMode Fields Name Description Nearest Closest match for a target length, can be greater or smaller in practice. RoundDown Round down the count  Only divide into segments longer than the target length RoundUp Round up the count  Only divide into segments shorter than the target length"
  },
  "api/Elements.Spatial.FixedDivisionMode.html": {
    "href": "api/Elements.Spatial.FixedDivisionMode.html",
    "title": "Enum FixedDivisionMode | Hypar Docs",
    "keywords": "Enum FixedDivisionMode Different ways to handle the \"remainder\" when dividing an arbitrary length by a fixed size Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum FixedDivisionMode Fields Name Description RemainderAtBothEnds Take the remainder and split it across both ends of the grid RemainderAtEnd Locate the remainder at the end of the grid RemainderAtStart Locate the remainder at the start of the grid RemainderNearMiddle Locate the remainder at or near the middle of the grid."
  },
  "api/Elements.Spatial.Grid1d.html": {
    "href": "api/Elements.Spatial.Grid1d.html",
    "title": "Class Grid1d | Hypar Docs",
    "keywords": "Class Grid1d Represents a \"1-dimensional grid\", akin to a number line that can be subdivided. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Spatial_Grid1d.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a 1d Grid from a line var line = new Line(new Vector3(5, 0, 0), new Vector3(60, 0, 0)); var grid = new Grid1d(line); // Divide the grid into sections of length 10, and leave remainders // at both ends grid.DivideByFixedLength(10, FixedDivisionMode.RemainderAtBothEnds); // Take the second grid segment and subdivide it // into 5 equal length segments grid[1].DivideByCount(5); // Take the third grid segment and subdivide it into // segments of approximate length 3 grid[2].DivideByApproximateLength(3); // Take the fourth grid segment and subdivide it by a repeating pattern var pattern = new[] { 1.0, 1.5 }; grid[3].DivideByPattern(pattern); // Retrieve all bottom-level cells. // Note that grid.Cells gets the top-level cells only, and // grid.GetCells() recursively gets the bottom-level individual cells. var cells = grid.GetCells(); // Get lines representing each cell var lines = cells.Select(c => c.GetCellGeometry()).OfType<Line>(); // Create walls from lines, and assign a random color material List<Wall> walls = new List<Wall>(); var rand = new Random(); foreach (var wallLine in lines) { var color = new Color(rand.NextDouble(), rand.NextDouble(), rand.NextDouble(), 1.0); walls.Add(new StandardWall(wallLine, 0.1, 3.0, new Material(color.ToString(), color, 0, 0, null, false, false))); } // Create rectangles from top-level grid cells var topLevelCells = grid.Cells.Select(c => c.GetCellGeometry()).OfType<Line>(); var cellRects = new List<ModelCurve>(); foreach (var topLevelCell in topLevelCells) { var rect = Polygon.Rectangle(topLevelCell.Start - new Vector3(0, 2, 0), topLevelCell.End + new Vector3(0, 2, 0)); cellRects.Add(new ModelCurve(rect)); } Inheritance System.Object Grid1d Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class Grid1d Constructors Grid1d(Domain1d) Construct a 1D grid from a numerical domain. The geometry will be assumed to lie along the X axis. Declaration public Grid1d(Domain1d domain) Parameters Type Name Description Domain1d domain The 1-dimensional domain for the grid extents. Grid1d(BoundedCurve) Construct a 1D grid from a curve. Declaration public Grid1d(BoundedCurve curve) Parameters Type Name Description BoundedCurve curve The curve from which to generate the grid. Grid1d(Grid1d) Construct a 1D Grid from another 1D Grid Declaration public Grid1d(Grid1d other) Parameters Type Name Description Grid1d other Grid1d(Double) Default constructor with optional length parameter Declaration public Grid1d(double length = 1) Parameters Type Name Description System.Double length Length of the grid domain Properties Cells Child cells of this Grid. If null, this Grid is a complete cell with no subdivisions. Declaration [JsonProperty(\"Cells\", NullValueHandling = NullValueHandling.Ignore)] public List<Grid1d> Cells { get; } Property Value Type Description System.Collections.Generic.List < Grid1d > Curve The base curve at the top level of this grid. Declaration [JsonIgnore] public BoundedCurve Curve { get; } Property Value Type Description BoundedCurve Domain Numerical domain of this Grid Declaration public Domain1d Domain { get; } Property Value Type Description Domain1d IsSingleCell Returns true if this 1D Grid has no subdivisions / sub-grids. Declaration public bool IsSingleCell { get; } Property Value Type Description System.Boolean Item[Int32] Retrieve a cell by index Declaration [JsonIgnore] public Grid1d this[int i] { get; } Parameters Type Name Description System.Int32 i The index Property Value Type Description Grid1d A Grid1d representing the selected cell/segment. Type An optional type designation for this cell. Declaration public string Type { get; set; } Property Value Type Description System.String Methods ClosestPosition(Vector3) Get the position along the grid's domain closest to a supplied point. Declaration public double ClosestPosition(Vector3 point) Parameters Type Name Description Vector3 point Returns Type Description System.Double DivideByApproximateLength(Double, EvenDivisionMode) Divide a grid by an approximate length. The length will be adjusted to generate whole-number subdivisions, governed by an optional DivisionMode. Declaration public void DivideByApproximateLength(double targetLength, EvenDivisionMode divisionMode = EvenDivisionMode.Nearest) Parameters Type Name Description System.Double targetLength The approximate length by which to divide the grid. EvenDivisionMode divisionMode Whether to permit any size cell, or only larger or smaller cells by rounding up or down. DivideByCount(Int32) Divide the grid into N even subdivisions. Grids that are already subdivided will fail. Declaration public void DivideByCount(int n) Parameters Type Name Description System.Int32 n Number of subdivisions DivideByFixedLength(Double, FixedDivisionMode, Int32) Divide a grid by constant length subdivisions, with a variable division mode to control how leftover space is handled. Declaration public void DivideByFixedLength(double length, FixedDivisionMode divisionMode = FixedDivisionMode.RemainderAtEnd, int sacrificialPanels = 0) Parameters Type Name Description System.Double length The division length FixedDivisionMode divisionMode How to handle leftover / partial remainder panels System.Int32 sacrificialPanels How many full length panels to sacrifice to make remainder panels longer. DivideByFixedLengthFromPoint(Double, Vector3) Divide a grid by constant length subdivisions, starting from a point location. Declaration public void DivideByFixedLengthFromPoint(double length, Vector3 point) Parameters Type Name Description System.Double length The length of subdivisions Vector3 point The point at which to begin subdividing. DivideByFixedLengthFromPosition(Double, Double) Divide a grid by constant length subdivisions, starting from a position. Declaration public void DivideByFixedLengthFromPosition(double length, double position) Parameters Type Name Description System.Double length The length of subdivisions System.Double position The position along the domain at which to begin subdividing. DivideByPattern(IList<Double>, PatternMode, FixedDivisionMode) Divide a grid by a pattern of lengths. Type names will be automatically generated, repetition will be governed by PatternMode, and remainder handling will be governed by DivisionMode. Declaration public void DivideByPattern(IList<double> lengthPattern, PatternMode patternMode = PatternMode.Cycle, FixedDivisionMode divisionMode = FixedDivisionMode.RemainderAtEnd) Parameters Type Name Description System.Collections.Generic.IList < System.Double > lengthPattern A pattern of lengths to apply to the grid PatternMode patternMode How to apply/repeat the pattern FixedDivisionMode divisionMode How to handle leftover/remainder length DivideByPattern(IList<(String typeName, Double length)>, PatternMode, FixedDivisionMode) Divide a grid by a pattern of named lengths. Repetition will be governed by PatternMode, and remainder handling will be governed by DivisionMode. Declaration public void DivideByPattern(IList<(string typeName, double length)> lengthPattern, PatternMode patternMode = PatternMode.Cycle, FixedDivisionMode divisionMode = FixedDivisionMode.RemainderAtEnd) Parameters Type Name Description System.Collections.Generic.IList < System.ValueTuple < System.String , System.Double >> lengthPattern A pattern of lengths to apply to the grid PatternMode patternMode How to apply/repeat the pattern FixedDivisionMode divisionMode How to handle leftover/remainder length FindCellAtPosition(Double) Retrieve the grid cell (as a Grid1d) at a length along the domain. Declaration public Grid1d FindCellAtPosition(double pos) Parameters Type Name Description System.Double pos The position in the grid's domain to find Returns Type Description Grid1d The cell at this position, if found, or this grid if it is a single cell. GetCellDomains(Boolean) Get domain parameters at the ends and in-between all cells. Declaration public List<double> GetCellDomains(bool recursive = false) Parameters Type Name Description System.Boolean recursive If true, domains will be retrieved from child cells as well. Returns Type Description System.Collections.Generic.List < System.Double > A list of double representing the domain across cells. GetCellGeometry() Retrieve geometric representation of a cell (currently just a line) Declaration public BoundedCurve GetCellGeometry() Returns Type Description BoundedCurve A curve representing the extents of this grid / cell. GetCells() Retrieve all grid segment cells recursively. For just top-level cells, get the Cells property. Declaration public List<Grid1d> GetCells() Returns Type Description System.Collections.Generic.List < Grid1d > A list of all the bottom-level cells / child cells of this grid. GetCellSeparators(Boolean) Get the points at the ends and in-between all cells. Declaration public List<Vector3> GetCellSeparators(bool recursive = false) Parameters Type Name Description System.Boolean recursive If true, separators will be retrieved from child cells as well. Returns Type Description System.Collections.Generic.List < Vector3 > A list of Vector3d points representing the boundaries between cells. SplitAtOffset(Double, Boolean, Boolean) Split a cell at a relative position measured from its domain start or end. Declaration public void SplitAtOffset(double position, bool fromEnd = false, bool ignoreOutsideDomain = false) Parameters Type Name Description System.Double position The relative position at which to split. System.Boolean fromEnd If true, measure the position from the end rather than the start System.Boolean ignoreOutsideDomain If true, splits at offsets outside the domain will be silently ignored. SplitAtOffsets(IEnumerable<Double>, Boolean) Split a cell at a list of relative positions measured from its domain start or end. Declaration public void SplitAtOffsets(IEnumerable<double> positions, bool fromEnd = false) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > positions The relative positions at which to split. System.Boolean fromEnd If true, measure the position from the end rather than the start SplitAtParameter(Double) Split the grid at a normalized parameter from 0 to 1 along its domain. Declaration public void SplitAtParameter(double t) Parameters Type Name Description System.Double t The parameter at which to split. SplitAtParameters(IEnumerable<Double>) Split the grid at a list of normalized parameters from 0 to 1 along its domain. Declaration public void SplitAtParameters(IEnumerable<double> parameters) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > parameters A list of parameters at which to split the grid. SplitAtPoint(Vector3) Split the grid at a point in world space. Note that for curved grids an approximate point will be used. Declaration public void SplitAtPoint(Vector3 point) Parameters Type Name Description Vector3 point SplitAtPoints(IEnumerable<Vector3>) Split the grid at points in world space. Note that for curved grids an approximate point will be used. Declaration public void SplitAtPoints(IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The points at which to split. SplitAtPosition(Double) Split the grid at a fixed position from the start or end Declaration public void SplitAtPosition(double position) Parameters Type Name Description System.Double position The length along the grid at which to split. SplitAtPositions(IEnumerable<Double>) Split the grid at a list of fixed positions from the start or end Declaration public void SplitAtPositions(IEnumerable<double> positions) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Double > positions The lengths along the grid at which to split."
  },
  "api/Elements.Spatial.Grid2d.html": {
    "href": "api/Elements.Spatial.Grid2d.html",
    "title": "Class Grid2d | Hypar Docs",
    "keywords": "Class Grid2d Represents a 2-dimensional grid which can be subdivided import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Spatial_Grid2d.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a 2d grid that's 40 x 30 in size var grid = new Grid2d(40, 30); // Access the U and V axes directly and use 1d subdivision methods on them grid.U.DivideByFixedLength(7, FixedDivisionMode.RemainderAtBothEnds); grid.V.DivideByPattern(new[] { 2.0, 5.0 }); // Get a row by index var fifthRow = grid.GetRowAtIndex(4); // Divide U axis of all cells in row into panels of approximate width 1 fifthRow.ForEach(c => c.U.DivideByApproximateLength(1)); // Get a cell by u, v indices var cell = grid[1, 1]; // Divide the cell in the V direction cell.V.DivideByCount(4); // Create a floor from the entire grid's boundary var floor = new Floor(new Profile((Polygon)grid.GetCellGeometry()), 0.5, new Transform(0, 0, -0.51)); // Create model curves from all subdivided cells of the grid var modelCurves = grid.ToModelCurves(); Inheritance System.Object Grid2d Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class Grid2d Constructors Grid2d() Construct a Grid2d with default domain (0,0) to (1,1) Declaration public Grid2d() Grid2d(Polygon, Transform) Create a Grid2d from a polygon and optional Transform. If the plane is null or not supplied, the identity transform will be used for the grid origin and orientation. Currently only transforms parallel to the supplied polygons are supported. The polygon's bounding box parallel to the supplied transform will be used as the grid extents. Declaration public Grid2d(Polygon boundary, Transform transform = null) Parameters Type Name Description Polygon boundary The external boundary of this grid system. Transform transform A transform representing the alignment of the grid. Grid2d(Polygon, Vector3, Vector3, Vector3) Create a grid from a single boundary, an origin, and its U and V directions Declaration public Grid2d(Polygon boundary, Vector3 origin, Vector3 uDirection, Vector3 vDirection) Parameters Type Name Description Polygon boundary Vector3 origin Vector3 uDirection Vector3 vDirection Grid2d(Polygon, Grid1d, Grid1d) Create a grid from a boundary and custom U and V grids Declaration public Grid2d(Polygon boundary, Grid1d u, Grid1d v) Parameters Type Name Description Polygon boundary Grid1d u Grid1d v Grid2d(Grid1d, Grid1d) Construct a Grid2d from two Grid1ds in the U and V directions Declaration public Grid2d(Grid1d u, Grid1d v) Parameters Type Name Description Grid1d u Grid1d v Grid2d(Grid2d) Construct a Grid2d from another Grid2d Declaration public Grid2d(Grid2d other) Parameters Type Name Description Grid2d other Grid2d(Grid2d, Grid1d, Grid1d) Construct a Grid2d using another Grid2d as the base, but with different Grid1ds as its axes. Declaration public Grid2d(Grid2d other, Grid1d u, Grid1d v) Parameters Type Name Description Grid2d other The Grid2d to base this one on. Grid1d u The Grid1d representing the U Axis. Grid1d v The Grid1d representing the V Axis. Grid2d(IList<Polygon>, Transform) Create a Grid2d from a list of boundary polygons and an optional transform. If the transform is null or not supplied, a transform will be generated automatically from the boundaries' normal. Currently only transforms parallel to the supplied polygons are supported. The polygons' bounding box parallel to the supplied transform will be used as the grid extents. Declaration public Grid2d(IList<Polygon> boundaries, Transform transform = null) Parameters Type Name Description System.Collections.Generic.IList < Polygon > boundaries The external boundaries of this grid system. Transform transform A transform representing the alignment of the grid. Grid2d(IList<Polygon>, Vector3, Vector3, Vector3) Create a grid from a list of boundaries, an origin, and its U and V directions Declaration public Grid2d(IList<Polygon> boundaries, Vector3 origin, Vector3 uDirection, Vector3 vDirection) Parameters Type Name Description System.Collections.Generic.IList < Polygon > boundaries Vector3 origin Vector3 uDirection Vector3 vDirection Grid2d(IList<Polygon>, Grid1d, Grid1d) Create a grid from a list of boundaries and custom U and V grids Declaration public Grid2d(IList<Polygon> boundaries, Grid1d u, Grid1d v) Parameters Type Name Description System.Collections.Generic.IList < Polygon > boundaries Grid1d u Grid1d v Grid2d(Double, Double) Construct a Grid2d with specified dimensions for the U and V direction. Declaration public Grid2d(double uDimension, double vDimension) Parameters Type Name Description System.Double uDimension The size along the U axis System.Double vDimension The size along the V axis Properties Cells Child cells of this Grid. If null, this Grid is a complete cell with no subdivisions. Declaration [JsonIgnore] public List<List<Grid2d>> Cells { get; } Property Value Type Description System.Collections.Generic.List < System.Collections.Generic.List < Grid2d >> CellsFlat A flat list of all the top-level cells in this grid. To get child cells as well, use Grid2d.GetCells() instead. Declaration [JsonIgnore] public List<Grid2d> CellsFlat { get; } Property Value Type Description System.Collections.Generic.List < Grid2d > IsSingleCell Returns true if this 2D Grid has no subdivisions / sub-grids. Declaration [JsonIgnore] public bool IsSingleCell { get; } Property Value Type Description System.Boolean Item[Int32, Int32] Retrieve a single top-level cell at the specified [u,v] indices. Declaration [JsonIgnore] public Grid2d this[int u, int v] { get; } Parameters Type Name Description System.Int32 u The U index System.Int32 v The V index Property Value Type Description Grid2d The cell at these indices Type An optional type designation for this cell. Declaration public string Type { get; set; } Property Value Type Description System.String U The 1d Grid along the U dimension Declaration public Grid1d U { get; } Property Value Type Description Grid1d V The 1d grid along the V dimension Declaration public Grid1d V { get; } Property Value Type Description Grid1d Methods FindCellAtPosition(Double, Double) Retrieve the grid cell (as a Grid1d) at a length along the U and V domains. Declaration public Grid2d FindCellAtPosition(double uPosition, double vPosition) Parameters Type Name Description System.Double uPosition U Position System.Double vPosition V Position Returns Type Description Grid2d GetCellAtIndices(Int32, Int32) Retrieve a single top-level cell at the specified [u,v] indices. Declaration public Grid2d GetCellAtIndices(int u, int v) Parameters Type Name Description System.Int32 u The U index System.Int32 v The V index Returns Type Description Grid2d The cell at these indices GetCellGeometry() Get a rectangular polygon representing this untrimmed cell boundary. Declaration public BoundedCurve GetCellGeometry() Returns Type Description BoundedCurve A rectangle representing this cell in world coordinates. GetCellNodes() Get the points at the corners of all grid cells. /// Declaration public List<Vector3> GetCellNodes() Returns Type Description System.Collections.Generic.List < Vector3 > GetCells() Recursively retrieve all bottom-level cells from this grid. Declaration public List<Grid2d> GetCells() Returns Type Description System.Collections.Generic.List < Grid2d > A list of all bottom-level cells in the grid. GetCellSeparators(GridDirection, Boolean) Get the top-level lines separating cells from one another. Declaration public List<ICurve> GetCellSeparators(GridDirection direction, bool trim = false) Parameters Type Name Description GridDirection direction The grid direction in which you want to get separators. System.Boolean trim Whether or not to trim cell separators with the trimmed cell boundary Returns Type Description System.Collections.Generic.List < ICurve > The lines between cells, running parallel to the grid direction selected. GetColumnAtIndex(Int32) Get a list of all the top-level cells at a given u index. Declaration public List<Grid2d> GetColumnAtIndex(int u) Parameters Type Name Description System.Int32 u The u index Returns Type Description System.Collections.Generic.List < Grid2d > A list of the column of all cells with this u index. GetRowAtIndex(Int32) Get a list of all the top-level cells at a given v index. Declaration public List<Grid2d> GetRowAtIndex(int v) Parameters Type Name Description System.Int32 v The v index Returns Type Description System.Collections.Generic.List < Grid2d > A list of the row of all cells with this v index. GetTrimmedCellGeometry() Get a list of polygons representing this cell boundary, trimmed by any polygon boundary. If the cell falls completely outside of the boundary, an empty array will be returned. Declaration public BoundedCurve[] GetTrimmedCellGeometry() Returns Type Description BoundedCurve [] Curves representing this cell in world coordinates. GetTrimmedCellProfiles() Get a list of profiles representing this cell boundary, trimmed by any polygon boundary. Internal polygons that are completely inside the cell and are clockwise, will be added as profile voids. If the cell falls completely outside of the boundary, an empty array will be returned. Declaration public IEnumerable<Profile> GetTrimmedCellProfiles() Returns Type Description System.Collections.Generic.IEnumerable < Profile > Curves representing this cell in world coordinates. IsOutside() Test if the cell is fully outside the boundary. Declaration public bool IsOutside() Returns Type Description System.Boolean True if the grid cell is totally outside the boundary. IsTrimmed(Boolean) Test if the cell is trimmed by a boundary. Declaration public bool IsTrimmed(bool treatFullyOutsideAsTrimmed = true) Parameters Type Name Description System.Boolean treatFullyOutsideAsTrimmed Should cells that fall entirely outside of the boundary be treated as trimmed? True by default. Returns Type Description System.Boolean True if the cell is trimmed by the grid boundary. SplitAtPoint(Vector3) Split the grid at a point in world space Declaration public void SplitAtPoint(Vector3 point) Parameters Type Name Description Vector3 point The point at which to split. SplitAtPoints(IEnumerable<Vector3>) Split the grid at points in world space Declaration public void SplitAtPoints(IEnumerable<Vector3> points) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > points The points at which to split SplitAtPosition(Vector3) Split the grid at a position in the grid's coordinate system Declaration public void SplitAtPosition(Vector3 position) Parameters Type Name Description Vector3 position The position at which to split, with X = U and Y = V. SplitAtPosition(Double, Double) Split the grid at a position in the grid's coordinate system Declaration public void SplitAtPosition(double uPosition, double vPosition) Parameters Type Name Description System.Double uPosition The U position System.Double vPosition The V position SplitAtPositions(IEnumerable<Vector3>) Split the grid at positions in the grid's coordinate system Declaration public void SplitAtPositions(IEnumerable<Vector3> positions) Parameters Type Name Description System.Collections.Generic.IEnumerable < Vector3 > positions The positions at which to split, with X = U and Y = V. Extension Methods ModelCurveExtensions.ToModelCurves(Grid2d, Transform, Material)"
  },
  "api/Elements.Spatial.GridDirection.html": {
    "href": "api/Elements.Spatial.GridDirection.html",
    "title": "Enum GridDirection | Hypar Docs",
    "keywords": "Enum GridDirection A direction/dimension on a 2d grid. Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum GridDirection Fields Name Description U The U Direction V The V Direction"
  },
  "api/Elements.Spatial.HalfEdgeGraph2d.html": {
    "href": "api/Elements.Spatial.HalfEdgeGraph2d.html",
    "title": "Class HalfEdgeGraph2d | Hypar Docs",
    "keywords": "Class HalfEdgeGraph2d Represents a 2D Graph with Half-edge connectivity, useful for finding polygons bounded by intersecting or overlapping edges. Inheritance System.Object HalfEdgeGraph2d Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public class HalfEdgeGraph2d Properties EdgesPerVertex The index pairs, grouped by starting vertex, representing unique half edges. Declaration public List<List<(int from, int to, int? tag)>> EdgesPerVertex { get; set; } Property Value Type Description System.Collections.Generic.List < System.Collections.Generic.List < System.ValueTuple < System.Int32 , System.Int32 , System.Nullable < System.Int32 >>>> Vertices The unique vertices of this graph Declaration public List<Vector3> Vertices { get; set; } Property Value Type Description System.Collections.Generic.List < Vector3 > Methods Construct(Polygon, Polyline) Construct a 2D Half Edge Graph from a polygon and an intersecting polyline. Declaration public static HalfEdgeGraph2d Construct(Polygon pg, Polyline pl) Parameters Type Name Description Polygon pg The polygon. Polyline pl The polyline. Returns Type Description HalfEdgeGraph2d Construct(IEnumerable<Line>, Boolean) Construct a 2D half-edge graph from a collection of lines. Declaration public static HalfEdgeGraph2d Construct(IEnumerable<Line> lines, bool bothWays = false) Parameters Type Name Description System.Collections.Generic.IEnumerable < Line > lines The line segments from which to construct the graph. System.Boolean bothWays If true, each line will create two half edges  one running each way. Returns Type Description HalfEdgeGraph2d Construct(IEnumerable<Polygon>, IEnumerable<Polyline>) Construct a 2D Half Edge Graph from a collection of polygons and a collection of intersecting polylines. Declaration public static HalfEdgeGraph2d Construct(IEnumerable<Polygon> pg, IEnumerable<Polyline> pl) Parameters Type Name Description System.Collections.Generic.IEnumerable < Polygon > pg The polygons. System.Collections.Generic.IEnumerable < Polyline > pl The polylines. Returns Type Description HalfEdgeGraph2d Polygonize(Func<Nullable<Int32>, Boolean>, Vector3) Calculate the closed polygons in this graph. Declaration public List<Polygon> Polygonize(Func<int?, bool> predicate = null, Vector3 normal = default(Vector3)) Parameters Type Name Description System.Func < System.Nullable < System.Int32 >, System.Boolean > predicate A predicate used during the final step of polygonization to determine if edges are valid. Vector3 normal The normal of the plane in which graph traversal for polygon construction will occur. If no normal is provided, the +Z axis is used. Returns Type Description System.Collections.Generic.List < Polygon > A collection of polygons. Polylinize(Func<Nullable<Int32>, Boolean>, Vector3) Calculate the closed polylines in this graph. Declaration public List<Polyline> Polylinize(Func<int?, bool> predicate = null, Vector3 normal = default(Vector3)) Parameters Type Name Description System.Func < System.Nullable < System.Int32 >, System.Boolean > predicate A predicate used during the final step of polylinization to determine if edges are valid. Vector3 normal The normal of the plane in which graph traversal for polyline construction will occur. If no normal is provided, the +Z axis is used. Returns Type Description System.Collections.Generic.List < Polyline > A collection of polylines."
  },
  "api/Elements.Spatial.html": {
    "href": "api/Elements.Spatial.html",
    "title": "Namespace Elements.Spatial | Hypar Docs",
    "keywords": "Namespace Elements.Spatial Classes Grid1d Represents a \"1-dimensional grid\", akin to a number line that can be subdivided. Grid2d Represents a 2-dimensional grid which can be subdivided HalfEdgeGraph2d Represents a 2D Graph with Half-edge connectivity, useful for finding polygons bounded by intersecting or overlapping edges. MercatorProjection Methods for computing geographic coordinates using the Mercator projection. WebMercatorProjection Methods for computing web mercator projection tiles and coordinates. Enums EvenDivisionMode Describe how a target length should be treated FixedDivisionMode Different ways to handle the \"remainder\" when dividing an arbitrary length by a fixed size GridDirection A direction/dimension on a 2d grid. PatternMode Methods for repeating a pattern of lengths or types"
  },
  "api/Elements.Spatial.MercatorProjection.html": {
    "href": "api/Elements.Spatial.MercatorProjection.html",
    "title": "Class MercatorProjection | Hypar Docs",
    "keywords": "Class MercatorProjection Methods for computing geographic coordinates using the Mercator projection. Inheritance System.Object MercatorProjection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public static class MercatorProjection Methods LatLonToMeters(Position, Double, Double) Convert Latitude and Longitude to meters relative to a base position. Declaration public static Vector3 LatLonToMeters(Position relativeToOrigin, double lat, double lon) Parameters Type Name Description Position relativeToOrigin A position marking the latitude and longitude of (0,0) System.Double lat The latitude in degrees System.Double lon The longitude in degrees Returns Type Description Vector3 A Vector3 in meters specifying the offset from the origin for this location. LatToY(Double) Get the y coordinate, in the Mercator projection, of the specified latitude. The units will be in meters at the equator, and distorted elsewhere. Utilize LatLonToMeters() for a conversion relative to a basepoint. Declaration public static double LatToY(double lat) Parameters Type Name Description System.Double lat The latitude to convert, within the range [-89.5, 89.5]. Values outside this range will be clamped. Returns Type Description System.Double LonToX(Double) Get the x coordinate, in the Mercator projection, of the specified longitude. The units will be in meters at the equator, and distorted elsewhere. Utilize LatLonToMeters() for a conversion relative to a basepoint. Declaration public static double LonToX(double lon) Parameters Type Name Description System.Double lon Returns Type Description System.Double MetersToLatLon(Position, Vector3) Convert a position in space to a latitude and longitude. Declaration public static Position MetersToLatLon(Position relativeToOrigin, Vector3 location) Parameters Type Name Description Position relativeToOrigin A position marking the latitude and longitude of (0,0). Vector3 location The position to convert to latitude and longitude. Returns Type Description Position A position indicating the latitude and longitude of the location. ToGeoCoord(Double, Double) Get the latitude and longitude of the specified x and y coordinates. Declaration public static double[] ToGeoCoord(double x, double y) Parameters Type Name Description System.Double x System.Double y Returns Type Description System.Double [] An array of doubles containing the longitude and latitude in degrees. ToPixel(Double, Double) Get the coordinates of the longitude and latitude. Declaration public static double[] ToPixel(double lon, double lat) Parameters Type Name Description System.Double lon System.Double lat Returns Type Description System.Double [] An array of doubles containing the x, and y coordintes, in the Mercator projection. XToLon(Double) Get the longitude of the specified x coordinate. Declaration public static double XToLon(double x) Parameters Type Name Description System.Double x The x coordinate in the Mercator projection. Returns Type Description System.Double The longitude in degrees. YToLat(Double) Get the latitude of the specified y coordinate. Declaration public static double YToLat(double y) Parameters Type Name Description System.Double y The y coordinate in the Mercator projection. Returns Type Description System.Double The latitude in degrees."
  },
  "api/Elements.Spatial.PatternMode.html": {
    "href": "api/Elements.Spatial.PatternMode.html",
    "title": "Enum PatternMode | Hypar Docs",
    "keywords": "Enum PatternMode Methods for repeating a pattern of lengths or types Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public enum PatternMode Fields Name Description Cycle For a pattern [A, B, C], split at A, B, C, A, B, C, A... Flip For a pattern [A, B, C], split at A, B, C, B, A, B, C, B, A None No Repeat. For a pattern [A, B, C], split A, B, C panels, and treat the remaining length according to FixedDivisionMode settings."
  },
  "api/Elements.Spatial.WebMercatorProjection.html": {
    "href": "api/Elements.Spatial.WebMercatorProjection.html",
    "title": "Class WebMercatorProjection | Hypar Docs",
    "keywords": "Class WebMercatorProjection Methods for computing web mercator projection tiles and coordinates. Inheritance System.Object WebMercatorProjection Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Spatial Assembly : Hypar.Elements.dll Syntax public static class WebMercatorProjection Methods GetTileSizeMeters(Double, Int32) Get the tile size, in meters. Declaration public static double GetTileSizeMeters(double lat, int zoom) Parameters Type Name Description System.Double lat The latitude of the tile, in degrees. System.Int32 zoom The zoom level of the tile. Returns Type Description System.Double TileIdToCenterWebMercator(Int32, Int32, Int32) Get the center of the mercator web tile. Declaration public static Vector3 TileIdToCenterWebMercator(int x, int y, int zoom) Parameters Type Name Description System.Int32 x System.Int32 y System.Int32 zoom Returns Type Description Vector3"
  },
  "api/Elements.SpotLight.html": {
    "href": "api/Elements.SpotLight.html",
    "title": "Class SpotLight | Hypar Docs",
    "keywords": "Class SpotLight A spot light. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_SpotLight.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Visualize the light with a small, constant-colored \"light bulb\". var lightMaterial = new Material(\"Light\", Colors.White, unlit: true); var t = new Transform(0, 0, 5); var lightBulb = new Mass(Polygon.Rectangle(0.1, 0.1), 0.1, lightMaterial, transform: t); var floor = new Floor(Polygon.Rectangle(20, 20), 0.1); var spotLight = new SpotLight(Colors.White, t, 20, 0, 1.0); Inheritance System.Object Element Light SpotLight Implements System.ComponentModel.INotifyPropertyChanged Inherited Members Light.LightType Light.Intensity Light.Color Light.Transform Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class SpotLight : Light, INotifyPropertyChanged Constructors SpotLight(Color, Transform, Double, Double, Double, Guid, String) Construct a spot light. Declaration public SpotLight(Color color, Transform transform, double intensity = 1, double innerConeAngle = 0, double outerConeAngle = 0.78539816339744828, Guid id = default(Guid), string name = null) Parameters Type Name Description Color color The light's color. Transform transform The light's transform. System.Double intensity The light's intensity measured in candela. System.Double innerConeAngle The light's inner cone angle. System.Double outerConeAngle The light's outer cone angle. System.Guid id The light's unique identifier. System.String name The light's name. Properties InnerConeAngle The inner cone angle in radians. Declaration public double InnerConeAngle { get; set; } Property Value Type Description System.Double OuterConeAngle The outer cone angle in radians. Declaration public double OuterConeAngle { get; set; } Property Value Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.StandardWall.html": {
    "href": "api/Elements.StandardWall.html",
    "title": "Class StandardWall | Hypar Docs",
    "keywords": "Class StandardWall A wall defined by a planar curve, a height, and a thickness. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_StandardWall.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Create a wall. var line = new Line(new Vector3(0, 0, 0), new Vector3(10, 10, 0)); var wall = new StandardWall(line, 0.1, 3.0); wall.AddOpening(1, 2, 1, 1); wall.AddOpening(3, 1, 3.5, 1.5); Inheritance System.Object Element GeometricElement Wall StandardWall Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members Wall.Profile Wall.Openings GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class StandardWall : Wall, INotifyPropertyChanged, IHasOpenings Constructors StandardWall(Line, Double, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a wall along a line. Declaration public StandardWall(Line centerLine, double thickness, double height, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Line centerLine The center line of the wall. System.Double thickness The thickness of the wall. System.Double height The height of the wall. Material material The wall's material. Transform transform The transform of the wall. This transform will be concatenated to the transform created to describe the wall in 2D. Representation representation The wall's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the wall. System.String name The name of the wall. Properties CenterLine The center line of the wall. Declaration public Line CenterLine { get; } Property Value Type Description Line Height The height of the wall. Declaration public double Height { get; protected set; } Property Value Type Description System.Double Thickness The thickness of the wall. Declaration public double Thickness { get; set; } Property Value Type Description System.Double Methods AddOpening(Polygon, Double, Double, Double, Double) Add an Opening in the Wall. The Opening x and y sets the position relative to the Wall's Centerline.Start point in the wall elevation coordinate system. The x and y will position the origin of the polygon opening. Declaration public Opening AddOpening(Polygon perimeter, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description Polygon perimeter The perimeter of the opening. System.Double x The distance to the origin of the perimeter opening along the center line of the wall. System.Double y The height to the origin of the perimeter along the center line of the wall. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening AddOpening(Double, Double, Double, Double, Double, Double) Add an Opening in the Wall. The Opening x and y sets the position relative to the Wall's Centerline.Start point in the wall elevation coordinate system. The x and y will position origin of the rectangular opening. Declaration public Opening AddOpening(double width, double height, double x, double y, double depthFront = 1, double depthBack = 1) Parameters Type Name Description System.Double width The width of the opening. System.Double height The height of the opening. System.Double x The distance to the center of the opening along the center line of the wall. System.Double y The height to the center of the opening along the center line of the wall. System.Double depthFront The depth of the opening along the opening's +Z axis. System.Double depthBack The depth of the opening along the opening's -Z axis. Returns Type Description Opening UpdateRepresentations() Update solid operations. Declaration public override void UpdateRepresentations() Overrides Wall.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.StringExtensions.html": {
    "href": "api/Elements.StringExtensions.html",
    "title": "Class StringExtensions | Hypar Docs",
    "keywords": "Class StringExtensions String utilities and extension methods. Inheritance System.Object StringExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class StringExtensions Methods NumberToString(Int32) Create a string A, B, C, ... AA, AB ... from an int value Declaration public static string NumberToString(int value) Parameters Type Name Description System.Int32 value The value to turn into a character string Returns Type Description System.String A string of Upper-case characters e.g. 1=A, 2=B, 27=AA"
  },
  "api/Elements.StructuralFraming.html": {
    "href": "api/Elements.StructuralFraming.html",
    "title": "Class StructuralFraming | Hypar Docs",
    "keywords": "Class StructuralFraming A structural element with a profile swept along a curve. Inheritance System.Object Element GeometricElement StructuralFraming Beam Brace Column Joist Implements System.ComponentModel.INotifyPropertyChanged Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public abstract class StructuralFraming : GeometricElement, INotifyPropertyChanged Constructors StructuralFraming() Construct a framing element. Declaration public StructuralFraming() StructuralFraming(BoundedCurve, Profile, Material, Double, Double, Double, Transform, Representation, Boolean, Guid, String) Construct a beam. Declaration public StructuralFraming(BoundedCurve curve, Profile profile, Material material = null, double startSetback = 0, double endSetback = 0, double rotation = 0, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description BoundedCurve curve The center line of the beam. Profile profile The structural framing's profile. Material material The structural framing's material. System.Double startSetback The setback distance of the beam's extrusion at its start. System.Double endSetback The setback distance of the beam's extrusion at its end. System.Double rotation An optional rotation in degrees of the transform around its z axis. Transform transform The element's Transform. Representation representation The structural framing's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The structural framing's id. System.String name The structural framing's name. Properties Curve The center line of the framing element. Declaration public BoundedCurve Curve { get; set; } Property Value Type Description BoundedCurve EndSetback The setback of the framing's extrusion at the end. Declaration public double EndSetback { get; set; } Property Value Type Description System.Double Profile The structural framing's profile. Declaration public Profile Profile { get; set; } Property Value Type Description Profile Rotation The profile rotation around the center curve of the beam in degrees. Declaration public double Rotation { get; set; } Property Value Type Description System.Double StartSetback The setback of the framing's extrusion at the start. Declaration public double StartSetback { get; set; } Property Value Type Description System.Double Methods ProfileTransformed() Get the cross-section profile of the framing element transformed by the element's transform. Declaration public Profile ProfileTransformed() Returns Type Description Profile UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Volume() Calculate the volume of the element. Declaration public double Volume() Returns Type Description System.Double Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Symbol.html": {
    "href": "api/Elements.Symbol.html",
    "title": "Class Symbol | Hypar Docs",
    "keywords": "Class Symbol An alternate representation of an object. Inheritance System.Object Symbol Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Symbol Constructors Symbol(GeometryReference, SymbolCameraPosition) Construct a symbol. Declaration [JsonConstructor] public Symbol(GeometryReference geometry, SymbolCameraPosition cameraPosition) Parameters Type Name Description GeometryReference geometry The geometry of the symbol. SymbolCameraPosition cameraPosition A named camera position for this representation. Properties CameraPosition A named camera position for this representation, indicating the direction from which the camera is looking (a top view looks from top down, a north view looks from north to south.) Declaration [JsonProperty(\"CameraPosition\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] [JsonConverter(typeof(StringEnumConverter))] public SymbolCameraPosition CameraPosition { get; set; } Property Value Type Description SymbolCameraPosition Geometry The geometry of the symbol. Declaration [JsonProperty(\"Geometry\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public GeometryReference Geometry { get; set; } Property Value Type Description GeometryReference Methods GetGeometryAsync() Get the geometry from this symbol. Declaration public async Task<IEnumerable<object>> GetGeometryAsync() Returns Type Description System.Threading.Tasks.Task < System.Collections.Generic.IEnumerable < System.Object >>"
  },
  "api/Elements.SymbolCameraPosition.html": {
    "href": "api/Elements.SymbolCameraPosition.html",
    "title": "Enum SymbolCameraPosition | Hypar Docs",
    "keywords": "Enum SymbolCameraPosition An enumeration of typical camera positions. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum SymbolCameraPosition Fields Name Description East East North North South South Top Top West West"
  },
  "api/Elements.TiledCeiling.html": {
    "href": "api/Elements.TiledCeiling.html",
    "title": "Class TiledCeiling | Hypar Docs",
    "keywords": "Class TiledCeiling A tiled ceiling. Inheritance System.Object Element GeometricElement BaseCeiling TiledCeiling Implements System.ComponentModel.INotifyPropertyChanged Inherited Members BaseCeiling.Elevation BaseCeiling.Perimeter GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class TiledCeiling : BaseCeiling, INotifyPropertyChanged Constructors TiledCeiling(Polygon, Double, Double, Double, Transform, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling from tiles. Declaration public TiledCeiling(Polygon perimeter, double tileWidth, double tileLength, double spaceBetween, Transform gridOrientation = null, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan perimeter of the ceiling. It must lie on the XY plane. Z coordinate will be used as elevation System.Double tileWidth The tile width. System.Double tileLength The tile length. System.Double spaceBetween The space between tiles. Transform gridOrientation The grid orientation. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. TiledCeiling(Polygon, Double, Double, Double, Double, Transform, Material, Transform, Representation, Boolean, Guid, String) Construct a ceiling from tiles. Declaration public TiledCeiling(Polygon perimeter, double elevation, double tileWidth, double tileLength, double spaceBetween, Transform gridOrientation = null, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double elevation The elevation of the ceiling. System.Double tileWidth The tile width. System.Double tileLength The tile length. System.Double spaceBetween The space between tiles. Transform gridOrientation The grid orientation. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the ceiling. System.String name The name of the ceiling. TiledCeiling(Polygon, Double, Double, Double, Double, Transform, Guid, Material, Transform, Representation, Boolean, String) Construct a ceiling from tiles. It's a private constructor that doesn't add elevation to transform Declaration [JsonConstructor] protected TiledCeiling(Polygon perimeter, double elevation, double tileWidth, double tileLength, double spaceBetween, Transform gridOrientation = null, Guid id = default(Guid), Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, string name = null) Parameters Type Name Description Polygon perimeter The plan profile of the ceiling. It must lie on the XY plane. The Z coordinate will be ignored System.Double elevation The elevation of the ceiling. System.Double tileWidth System.Double tileLength System.Double spaceBetween Transform gridOrientation System.Guid id The id of the ceiling. Material material The material of the ceiling. Transform transform An optional transform for the ceiling. Representation representation The ceiling's representation. System.Boolean isElementDefinition Is this an element definition? System.String name The name of the ceiling. Properties GridOrientation The grid orientation. Declaration public Transform GridOrientation { get; protected set; } Property Value Type Description Transform SpaceBetween The space between tiles. Declaration public double SpaceBetween { get; protected set; } Property Value Type Description System.Double TileLength The tile length. Declaration public double TileLength { get; protected set; } Property Value Type Description System.Double TileWidth The tile width. Declaration public double TileWidth { get; protected set; } Property Value Type Description System.Double Methods GetCountOfUCells() Get count of U cells. Declaration public int GetCountOfUCells() Returns Type Description System.Int32 Count of U cells. GetCountOfVCells() Get count of V cells. Declaration public int GetCountOfVCells() Returns Type Description System.Int32 Count of v cells. GetGrid() Get an underlying grid. Declaration public Grid2d GetGrid() Returns Type Description Grid2d An underlying grid. GetTileCells() Get the tile cells as Grid2d. Declaration public List<Grid2d> GetTileCells() Returns Type Description System.Collections.Generic.List < Grid2d > List of tiles grids. GetTiles() Get tiles. Declaration public List<Polygon> GetTiles() Returns Type Description System.Collections.Generic.List < Polygon > List of tiles. UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Topography.html": {
    "href": "api/Elements.Topography.html",
    "title": "Class Topography | Hypar Docs",
    "keywords": "Class Topography A topographic mesh defined by an array of elevation values. import { Scene, PerspectiveCamera, WebGLRenderer, HemisphereLight, AxesHelper, Color, GridHelper, Box3, sRGBEncoding, Vector3, DirectionalLight} from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; var scene = new Scene(); var div = document.getElementById(\"model\") var camera = new PerspectiveCamera( 75, div.clientWidth/div.clientHeight, 0.1, 1000 ); var renderer = new WebGLRenderer({ alpha: true, antialias: true }); renderer.physicallyCorrectLights = true; renderer.outputEncoding = sRGBEncoding; renderer.setSize( div.clientWidth, div.clientHeight ); renderer.setClearColor( 0x000000, 0 ); div.appendChild( renderer.domElement ); var controls = new OrbitControls( camera, renderer.domElement ); var light = new HemisphereLight( 0xffffbb, 0x080820, 1 ); scene.add( light ); const directionalLight = new DirectionalLight( 0xffffff, 1.0 ); scene.add( directionalLight ); var axesHelper = new AxesHelper( 2 ); scene.add( axesHelper ); window.addEventListener( 'resize', onWindowResize, false ); // Instantiate a loader var loader = new GLTFLoader(); // Load a glTF resource loader.load( // resource URL '../models/Elements_Topography.glb', // called when the resource is loaded function ( gltf ) { scene.add( gltf.scene ); fitCameraToObject(scene, 2.0, controls); }, // called while loading is progressing function ( xhr ) { console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' ); }, // called when loading has errors function ( error ) { console.log( 'An error happened' ); } ); var animate = function () { requestAnimationFrame( animate ); renderer.render( scene, camera ); }; function onWindowResize(){ var div = document.getElementById(\"model\"); camera.aspect = div.clientWidth / div.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( div.clientWidth, div.clientHeight ); }; const fitCameraToObject = function ( object, offset, orbitControls ) { let boundingBox = new Box3(); boundingBox.setFromObject( object, true ); const center = new Vector3(); boundingBox.getCenter(center); const size = new Vector3(); boundingBox.getSize(size); // get the max side of the bounding box const maxDim = Math.max( size.x, size.y, size.z ) * 3; const fov = camera.fov * ( Math.PI / 180 ); let cameraZ = Math.abs( maxDim / 4 * Math.tan( fov * 2 ) ); // offset the camera as desired - usually a value of ~ 1.25 is good to prevent // object filling the whole canvas if( offset !== undefined && offset !== 0 ) { cameraZ *= offset; } camera.position.set( center.x, center.y, cameraZ ); // set the far plane of the camera so that it easily encompasses the whole object const minZ = boundingBox.min.z; const cameraToFarEdge = ( minZ < 0 ) ? -minZ + cameraZ : cameraZ - minZ; camera.far = cameraToFarEdge * 3; camera.updateProjectionMatrix(); if ( orbitControls !== undefined ) { // set camera to rotate around center of loaded object orbitControls.target = center; // prevent camera from zooming out far enough to create far plane cutoff orbitControls.maxDistance = cameraToFarEdge * 2; } }; animate(); Examples // Read topo elevations from a file. var data = JsonConvert.DeserializeObject<Dictionary<string, double[]>>(File.ReadAllText(\"./elevations.json\")); var latitude = 45; var elevations = data[\"points\"]; var tileSize = WebMercatorProjection.GetTileSizeMeters(latitude, 15); // Create a topography. var topo = new Topography(Vector3.Origin, tileSize, elevations); Inheritance System.Object Element GeometricElement MeshElement Topography Implements System.ComponentModel.INotifyPropertyChanged ITessellate Inherited Members MeshElement._mesh MeshElement.Mesh MeshElement.Tessellate(Mesh, Transform, Color) GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Topography : MeshElement, INotifyPropertyChanged, ITessellate Constructors Topography(Mesh, Material, Transform, Guid, String) Create a topography from a custom mesh. It is assumed that the mesh is an open mesh that's roughly parallel to the XY plane. Declaration public Topography(Mesh mesh, Material material, Transform transform, Guid id, string name) Parameters Type Name Description Mesh mesh The mesh geometry of the topography. Material material The topography's material. Transform transform The topography's transform. System.Guid id The topography's id. System.String name The topography's name. Topography(Vector3, Double, Double[], Material, Transform, Guid, String) Create a topography. Declaration public Topography(Vector3 origin, double width, double[] elevations, Material material = null, Transform transform = null, Guid id = default(Guid), string name = null) Parameters Type Name Description Vector3 origin The origin of the topography. System.Double width The width the topography. When constructed from a set of elevations, the width and the length of the topography will be the same. System.Double [] elevations An array of elevation samples which will be converted to a square array of width. Material material The topography's material. Transform transform The topography's transform. System.Guid id The topography's id. System.String name The topography's name. Topography(Topography) Construct a new Topography by duplicating another one. Declaration public Topography(Topography topography) Parameters Type Name Description Topography topography Properties AbsoluteMinimumElevation The absolute minimum elevation of the topography's mass. Declaration public double? AbsoluteMinimumElevation { get; set; } Property Value Type Description System.Nullable < System.Double > If this value is not null, DepthBelowMinimumElevation will be ignored. CellHeight The height of a cell. Declaration public double CellHeight { get; } Property Value Type Description System.Double CellWidth The width of a cell. Declaration public double CellWidth { get; } Property Value Type Description System.Double DepthBelowMinimumElevation The depth of the the topography's mass below the topography's minimum elevation. Declaration public double DepthBelowMinimumElevation { get; set; } Property Value Type Description System.Double Elevations A flat list of elevation data which is used to generate the topographic mesh's vertices. The elevations will be used with the RowWidth property to convert the flat list into a square grid. Declaration public double[] Elevations { get; } Property Value Type Description System.Double [] MaxElevation The maximum elevation of the topography. Declaration public double MaxElevation { get; } Property Value Type Description System.Double MinElevation The minimum elevation of the topography. Declaration public double MinElevation { get; } Property Value Type Description System.Double Origin The origin of the topography. Declaration public Vector3 Origin { get; } Property Value Type Description Vector3 RowWidth The number of cells 'across' the topography. Declaration public int RowWidth { get; } Property Value Type Description System.Int32 Methods AverageEdges(Topography, Units.CardinalDirection) Average the vertex placement along the specified edge of this topography with the vertex placement along the corresponding edge of a target topography. Declaration public void AverageEdges(Topography target, Units.CardinalDirection edgeToAverage) Parameters Type Name Description Topography target Units.CardinalDirection edgeToAverage CutAndFill(IList<Polygon>, Double, out List<Mesh>, out List<Mesh>, Double) Cut and or fill the topography with the specified perimeter to the specified elevation. Declaration public (double CutVolume, double FillVolume) CutAndFill(IList<Polygon> perimeters, double elevation, out List<Mesh> cuts, out List<Mesh> fills, double batterAngle = 45) Parameters Type Name Description System.Collections.Generic.IList < Polygon > perimeters The perimeters of the cut and fill areas. System.Double elevation The final elevation of the cut and fill. System.Collections.Generic.List < Mesh > cuts Meshes representing the cut volume in the topography. System.Collections.Generic.List < Mesh > fills Meshes representing the fill volume in the topography. System.Double batterAngle The angle of the battering surrounding the fill area in degrees. Returns Type Description System.ValueTuple < System.Double , System.Double > The sum of all cut and fill volumes. GetEdgeVertices(Units.CardinalDirection) Get the vertices along the specified edge of a square topography. Declaration public Vertex[] GetEdgeVertices(Units.CardinalDirection direction) Parameters Type Name Description Units.CardinalDirection direction The edge of vertices to return. Returns Type Description Vertex [] A collection of vertices. TopMesh() Returns a new mesh that represents the top surface of this topography. Declaration public Mesh TopMesh() Returns Type Description Mesh Trim(Profile) Trim the topography with the specified perimeter. Declaration public void Trim(Profile perimeter) Parameters Type Name Description Profile perimeter The perimeter of the trimmed topography. Trimmed(Profile) Returns a new Topography that is a trimmed version of the current Topography. Declaration public Topography Trimmed(Profile perimeter) Parameters Type Name Description Profile perimeter The perimeter of the trimmed topography. Returns Type Description Topography Tunnel(BoundedCurve, Double) Cut a tunnel through a topography. Declaration public void Tunnel(BoundedCurve path, double diameter) Parameters Type Name Description BoundedCurve path The path of the tunnel. System.Double diameter The diameter of the tunnel. UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged ITessellate Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.Units.CardinalDirection.html": {
    "href": "api/Elements.Units.CardinalDirection.html",
    "title": "Enum Units.CardinalDirection | Hypar Docs",
    "keywords": "Enum Units.CardinalDirection Cardinal directions. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum CardinalDirection Fields Name Description East East North North South South West West"
  },
  "api/Elements.Units.html": {
    "href": "api/Elements.Units.html",
    "title": "Class Units | Hypar Docs",
    "keywords": "Class Units Unit conversions and utilities. Inheritance System.Object Units Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public static class Units Fields PI_2 Pi/2 Declaration public const double PI_2 = 1.5707963267948966 Field Value Type Description System.Double Methods DegreesToRadians(Double) Convert from degrees to radians Declaration public static double DegreesToRadians(double degrees) Parameters Type Name Description System.Double degrees Returns Type Description System.Double The provided value converted to radians FeetToFeetAndFractionalInches(Double, Int32, Double) Convert from decimal feet to feet and fractional inches. Declaration public static string FeetToFeetAndFractionalInches(double decimalFeet, int roundDigits = 5, double precision = 0.015625) Parameters Type Name Description System.Double decimalFeet The value to convert to a fractional inches representation. System.Int32 roundDigits The number of fractional digits in the return value. System.Double precision Fractional precision described as a double. i.e. 1/64th -> 0.015625 Returns Type Description System.String FeetToMeters(Double) Convert from feet to meters. Declaration public static double FeetToMeters(double feet) Parameters Type Name Description System.Double feet Returns Type Description System.Double The provided value converted to meters. GetConversionToMeters(Units.LengthUnit) Get the conversion factor from the provided length unit to meters. Declaration public static double GetConversionToMeters(Units.LengthUnit from) Parameters Type Name Description Units.LengthUnit from The length unit. Returns Type Description System.Double InchesToFractionalInches(Double, Int32, Double) Convert from decimal inches to fractional inches Declaration public static string InchesToFractionalInches(double decimalInches, int roundDigits = 5, double precision = 0.015625) Parameters Type Name Description System.Double decimalInches The value to convert to a fractional inches representation. System.Int32 roundDigits The number of fractional digits in the return value. System.Double precision Fractional precision described as a double. i.e. 1/64th -> 0.015625 Returns Type Description System.String InchesToMeters(Double) Convert from inches to meters. Declaration public static double InchesToMeters(double inches) Parameters Type Name Description System.Double inches A value of inches. Returns Type Description System.Double The provided value converted to meters. MetersToFeet(Double) Convert from meters to feet. Declaration public static double MetersToFeet(double meters) Parameters Type Name Description System.Double meters Returns Type Description System.Double The provided value converted to feet. MetersToInches(Double) Convert from meters to inches. Declaration public static double MetersToInches(double meters) Parameters Type Name Description System.Double meters Returns Type Description System.Double The provided value converted to inches. RadiansToDegrees(Double) Convert from radians to degrees. Declaration public static double RadiansToDegrees(double radians) Parameters Type Name Description System.Double radians Returns Type Description System.Double The provided value converted to radians."
  },
  "api/Elements.Units.LengthUnit.html": {
    "href": "api/Elements.Units.LengthUnit.html",
    "title": "Enum Units.LengthUnit | Hypar Docs",
    "keywords": "Enum Units.LengthUnit Units of length. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum LengthUnit Fields Name Description Centimeter Centimeter Foot Foot Inch Inch Kilometer Kilometer Meter Meter Millimeter Millimeter"
  },
  "api/Elements.Units.UnitType.html": {
    "href": "api/Elements.Units.UnitType.html",
    "title": "Enum Units.UnitType | Hypar Docs",
    "keywords": "Enum Units.UnitType Unit types. Namespace : Elements Assembly : Hypar.Elements.dll Syntax public enum UnitType Fields Name Description Area Area Force Force Length Length Mass Mass None None PlaneAngle Plane Angle Pressure Pressure Time Time Volume Volume"
  },
  "api/Elements.Validators.ArcValidator.html": {
    "href": "api/Elements.Validators.ArcValidator.html",
    "title": "Class ArcValidator | Hypar Docs",
    "keywords": "Class ArcValidator Inheritance System.Object ArcValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class ArcValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.ColorValidator.html": {
    "href": "api/Elements.Validators.ColorValidator.html",
    "title": "Class ColorValidator | Hypar Docs",
    "keywords": "Class ColorValidator Inheritance System.Object ColorValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class ColorValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.ElementValidator.html": {
    "href": "api/Elements.Validators.ElementValidator.html",
    "title": "Class ElementValidator | Hypar Docs",
    "keywords": "Class ElementValidator Inheritance System.Object ElementValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class ElementValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.ExtrudeValidator.html": {
    "href": "api/Elements.Validators.ExtrudeValidator.html",
    "title": "Class ExtrudeValidator | Hypar Docs",
    "keywords": "Class ExtrudeValidator Inheritance System.Object ExtrudeValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class ExtrudeValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.GeometricElementValidator.html": {
    "href": "api/Elements.Validators.GeometricElementValidator.html",
    "title": "Class GeometricElementValidator | Hypar Docs",
    "keywords": "Class GeometricElementValidator Inheritance System.Object GeometricElementValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class GeometricElementValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.html": {
    "href": "api/Elements.Validators.html",
    "title": "Namespace Elements.Validators | Hypar Docs",
    "keywords": "Namespace Elements.Validators Classes ArcValidator ColorValidator ElementValidator ExtrudeValidator GeometricElementValidator LaminaValidator LineValidator MaterialValidator MatrixValidator PlaneValidator PolygonValidator PolylineValidator ProfileValidator SweepValidator Validator The supplier of validation logic for for element construction. Vector3Validator Interfaces IValidator Implement this interface to act as a validator."
  },
  "api/Elements.Validators.IValidator.html": {
    "href": "api/Elements.Validators.IValidator.html",
    "title": "Interface IValidator | Hypar Docs",
    "keywords": "Interface IValidator Implement this interface to act as a validator. Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public interface IValidator Properties ValidatesType The type to be validated. Declaration Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Post construction logic. Declaration void PostConstruct(object obj) Parameters Type Name Description System.Object obj The constructed object. PreConstruct(Object[]) Validate the object with the provided arguments. Declaration void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args"
  },
  "api/Elements.Validators.LaminaValidator.html": {
    "href": "api/Elements.Validators.LaminaValidator.html",
    "title": "Class LaminaValidator | Hypar Docs",
    "keywords": "Class LaminaValidator Inheritance System.Object LaminaValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class LaminaValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.LineValidator.html": {
    "href": "api/Elements.Validators.LineValidator.html",
    "title": "Class LineValidator | Hypar Docs",
    "keywords": "Class LineValidator Inheritance System.Object LineValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class LineValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.MaterialValidator.html": {
    "href": "api/Elements.Validators.MaterialValidator.html",
    "title": "Class MaterialValidator | Hypar Docs",
    "keywords": "Class MaterialValidator Inheritance System.Object MaterialValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class MaterialValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.MatrixValidator.html": {
    "href": "api/Elements.Validators.MatrixValidator.html",
    "title": "Class MatrixValidator | Hypar Docs",
    "keywords": "Class MatrixValidator Inheritance System.Object MatrixValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class MatrixValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.PlaneValidator.html": {
    "href": "api/Elements.Validators.PlaneValidator.html",
    "title": "Class PlaneValidator | Hypar Docs",
    "keywords": "Class PlaneValidator Inheritance System.Object PlaneValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class PlaneValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.PolygonValidator.html": {
    "href": "api/Elements.Validators.PolygonValidator.html",
    "title": "Class PolygonValidator | Hypar Docs",
    "keywords": "Class PolygonValidator Inheritance System.Object PolygonValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class PolygonValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.PolylineValidator.html": {
    "href": "api/Elements.Validators.PolylineValidator.html",
    "title": "Class PolylineValidator | Hypar Docs",
    "keywords": "Class PolylineValidator Inheritance System.Object PolylineValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class PolylineValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.ProfileValidator.html": {
    "href": "api/Elements.Validators.ProfileValidator.html",
    "title": "Class ProfileValidator | Hypar Docs",
    "keywords": "Class ProfileValidator Inheritance System.Object ProfileValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class ProfileValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.SweepValidator.html": {
    "href": "api/Elements.Validators.SweepValidator.html",
    "title": "Class SweepValidator | Hypar Docs",
    "keywords": "Class SweepValidator Inheritance System.Object SweepValidator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class SweepValidator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Validators.Validator.html": {
    "href": "api/Elements.Validators.Validator.html",
    "title": "Class Validator | Hypar Docs",
    "keywords": "Class Validator The supplier of validation logic for for element construction. Inheritance System.Object Validator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax public class Validator Properties DisableValidationOnConstruction Should geometry validation be disabled during construction? Note: Disabling validation can have unforeseen consequences. Use with caution. Declaration public static bool DisableValidationOnConstruction { get; set; } Property Value Type Description System.Boolean Instance The validator singleton. Declaration [Obsolete] public static Validator Instance { get; } Property Value Type Description Validator Methods GetFirstValidatorForType<T>() Gets the first validator for the supplied T. Declaration [Obsolete(\"Please include validation logic in the constructor of your object. Use the DisableValidationOnConstruction property to disable validation logic.\")] public IValidator GetFirstValidatorForType<T>() Returns Type Description IValidator A validator for T, or null if no validator for T can be found. Type Parameters Name Description T"
  },
  "api/Elements.Validators.Vector3Validator.html": {
    "href": "api/Elements.Validators.Vector3Validator.html",
    "title": "Class Vector3Validator | Hypar Docs",
    "keywords": "Class Vector3Validator Inheritance System.Object Vector3Validator Implements IValidator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements.Validators Assembly : Hypar.Elements.dll Syntax [Obsolete] public class Vector3Validator : IValidator Properties ValidatesType Declaration public Type ValidatesType { get; } Property Value Type Description System.Type Methods PostConstruct(Object) Declaration public void PostConstruct(object obj) Parameters Type Name Description System.Object obj PreConstruct(Object[]) Declaration public void PreConstruct(object[] args) Parameters Type Name Description System.Object [] args Implements IValidator"
  },
  "api/Elements.Wall.html": {
    "href": "api/Elements.Wall.html",
    "title": "Class Wall | Hypar Docs",
    "keywords": "Class Wall A wall defined by a planar profile extruded to a height. Inheritance System.Object Element GeometricElement Wall StandardWall WallByProfile Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax public class Wall : GeometricElement, INotifyPropertyChanged, IHasOpenings Constructors Wall(Profile, Double, Material, Transform, Representation, Boolean, Guid, String) Construct a wall by extruding a profile. Declaration [JsonConstructor] public Wall(Profile profile, double height, Material material = null, Transform transform = null, Representation representation = null, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Profile profile The plan profile of the wall. System.Double height The height of the wall. Material material The material of the wall. Transform transform An option transform for the wall. Representation representation The wall's representation. System.Boolean isElementDefinition Is this an element definition? System.Guid id The id of the wall. System.String name The name of the wall. Wall(Transform, Material, Representation, Boolean, Guid, String) A pass-through constructor to set the id, name, and transform. Declaration protected Wall(Transform transform, Material material, Representation representation, bool isElementDefinition = false, Guid id = default(Guid), string name = null) Parameters Type Name Description Transform transform Material material Representation representation System.Boolean isElementDefinition Is this an element definition? System.Guid id System.String name Properties Height The height of the wall. Declaration [Obsolete(\"The height property on the Wall base class is obsolete, check the methods of an inherited class like StandardWall or WallByProfile.\")] public double Height { get; protected set; } Property Value Type Description System.Double Openings A collection of openings in the wall. Declaration public List<Opening> Openings { get; } Property Value Type Description System.Collections.Generic.List < Opening > Profile The profile of the wall. Declaration [Obsolete(\"The profile property on the Wall base class is obsolete, check the methods of an inherited class like StandardWall or WallByProfile.\")] public Profile Profile { get; protected set; } Property Value Type Description Profile Methods UpdateRepresentations() Update the representations. Declaration public override void UpdateRepresentations() Overrides GeometricElement.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "api/Elements.WallByProfile.html": {
    "href": "api/Elements.WallByProfile.html",
    "title": "Class WallByProfile | Hypar Docs",
    "keywords": "Class WallByProfile A wall drawn using the elevation profile Inheritance System.Object Element GeometricElement Wall WallByProfile Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Inherited Members Wall.Height Wall.Profile Wall.Openings GeometricElement.Bounds GeometricElement.Transform GeometricElement.Material GeometricElement.Representation GeometricElement.IsElementDefinition GeometricElement.ModifyVertexAttributes GeometricElement.UpdateBoundsAndComputeSolid(Boolean) GeometricElement.CreateInstance(Transform, String) GeometricElement.ToMesh(Boolean) GeometricElement.HasGeometry() GeometricElement.Intersects(Plane, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Polygon>>, Dictionary<Guid, List<Line>>) GeometricElement.TryToGraphicsBuffers(List<GraphicsBuffers>, String, Nullable<MeshPrimitive.ModeEnum>) Element.Id Element.Name Element.AdditionalProperties Element.PropertyChanged Element.RaisePropertyChanged(String) Element.SetMapping(String, MappingBase) Element.GetMapping(String) Element.GetMapping<T>(String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Elements Assembly : Hypar.Elements.dll Syntax [JsonConverter(typeof(JsonInheritanceConverter), new object[]{\"discriminator\"})] public class WallByProfile : Wall, INotifyPropertyChanged, IHasOpenings Constructors WallByProfile(Polygon, Profile, Double, Line, Transform, Material, List<Opening>, Representation, Boolean, Guid, String) Construct a wall by profile. Declaration [JsonConstructor] [Obsolete(\"Do not use. This constructor is only preserved to maintain backwards compatibility upon serialization/deserialization.\")] public WallByProfile(Polygon perimeter, Profile profile, double thickness, Line centerline, Transform transform, Material material, List<Opening> openings, Representation representation, bool isElementDefinition, Guid id, string name) Parameters Type Name Description Polygon perimeter The perimeter of the wall elevation. Profile profile This value should be left null. System.Double thickness The thickness of the wall. Line centerline The centerline of the wall. Transform transform The transform of the wall. Material material The material of the wall. System.Collections.Generic.List < Opening > openings The openings of the wall. Representation representation The representation of the wall. System.Boolean isElementDefinition Is the wall an element definition? System.Guid id The id of the wall. System.String name The name of the wall. WallByProfile(Polygon, Double, Line, Transform, Material, Representation, Boolean, String) Construct a wall by profile. Declaration public WallByProfile(Polygon perimeter, double thickness, Line centerline, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false, string name = \"Wall by Profile\") Parameters Type Name Description Polygon perimeter The perimeter of the wall elevation. System.Double thickness The thickness of the wall. Line centerline The centerline of the wall. Transform transform The transform of the wall. Material material The material of the wall. Representation representation The representation of the wall. System.Boolean isElementDefinition Is the wall an element definition? System.String name The name of the wall. WallByProfile(Profile, Double, Line, Transform, Material, Representation, Boolean) Create a Wall from a Profile and thickness. If centerline is not included it will be computed from the Profile. The Profile will be projected to the centerline Plane, and used to find Openings of the Wall. Declaration public WallByProfile(Profile profile, double thickness, Line centerline = null, Transform transform = null, Material material = null, Representation representation = null, bool isElementDefinition = false) Parameters Type Name Description Profile profile System.Double thickness Line centerline Transform transform Material material Representation representation System.Boolean isElementDefinition Properties Centerline The Centerline of the wall Declaration [JsonProperty(\"Centerline\", Required = Required.Default, NullValueHandling = NullValueHandling.Ignore)] public Line Centerline { get; set; } Property Value Type Description Line Perimeter The perimeter of the Wall's elevation. It is assumed to be in the same Plane as the Centerline, and will often be projected to that Plane during internal operations. Declaration [JsonProperty(\"Perimeter\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public Polygon Perimeter { get; set; } Property Value Type Description Polygon Thickness The overall thickness of the Wall Declaration [JsonProperty(\"Thickness\", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)] public double Thickness { get; set; } Property Value Type Description System.Double Methods AddOpening(Polygon, Double, Double) Add an Opening to the Wall. Declaration public void AddOpening(Polygon perimeter, double depthFront = 1, double depthBack = 1) Parameters Type Name Description Polygon perimeter System.Double depthFront System.Double depthBack GetHeight() The computed height of the Wall. Declaration public double GetHeight() Returns Type Description System.Double GetProfile() The Profile of the Wall computed from its Perimeter and the Openings. Declaration public Profile GetProfile() Returns Type Description Profile UpdateRepresentations() Update the geometric representation of this Wall. Declaration public override void UpdateRepresentations() Overrides Wall.UpdateRepresentations() Implements System.ComponentModel.INotifyPropertyChanged IHasOpenings Extension Methods ElementProxyExtensions.Proxy<T>(T, String) Identity.AddOverrideIdentity(Element, IOverride) Identity.AddOverrideIdentity(Element, String, String, Object) Identity.AddOverrideValue(Element, String, Object) Identity.OverrideIds<T>(Element, String)"
  },
  "index.html": {
    "href": "index.html",
    "title": "What is Elements? | Hypar Docs",
    "keywords": "What is Elements? Elements is a cross-platform library for creating building elements. It's meant to be used by architects, engineers, and other building professionals who want to write code that generates buildings. When we started Hypar we needed a library that would generate building elements and run at the core of each function on the platform. Because we don't like rebuilding the wheel, we looked around for existing libraries that fulfilled the following requirements: The library must be small and fast. Elements is currently ~300kb and we're working every day to make it smaller. The library must be cross-platform. The library must have great visual documentation. If we're going to pass this library on as a recommendation to developers on Hypar, we want great docs. The library must be free of dependencies on host applications like Rhino or Revit or geometry kernels like Open Cascade which, while really cool, become a black box in your system. The library must be able to serialize data to formats like JSON, IFC ,and glTF , that are useful to architects, engineers, contractors, and people building real-time visualization applications for AEC. The library must be written in a language that supports developer productivity through things like type safety, and which supports code re-use in other popular AEC applications like Dynamo, Grasshopper, Revit, and Unity. Serialization and deserialization of types that extend Element should be possible provided that those types are made up of primitives defined in this library. We couldn't find anything quite right. So we started building this."
  },
  "releases.html": {
    "href": "releases.html",
    "title": "Release Notes | Hypar Docs",
    "keywords": "Release Notes See links and brief summaries about major releases to elements library here. 2.0 We have change the internal parameterization of curves to adhere to common industry standards, and to allow for more flexibility in the future. This change is not backwards compatible, and will require some changes to your code. We have also added a new BoundedCurve class that is the base class for curves that have a fixed domain. For more details see the documentation in the elements repository."
  }
}